At	O	O
the	O	O
first	O	B-API
step	O	B-API
I	O	O
used	O	O
`	O	O
df.T	B-API	O
`	O	O
to	O	O
transpose	O	B-API
the	O	O
dataframe	O	O
,	O	O
and	O	O
tried	O	O
something	O	O
like	O	O
`	O	O
df.value_counts()	O	B-API
`	O	O
,	O	O
however	O	O
I'd	O	O

Replace	O	O
NaN	O	O
in	O	O
a	O	O
dataframe	O	O
with	O	O
random	O	B-API
values	O	B-API

I	O	O
want	O	O
to	O	O
replace	O	B-API
all	O	B-API
the	O	O
NaN	O	O
with	O	O
some	O	O
random	O	B-API
values	O	B-API
like	O	O
.	O	O

#CODE	O	O

Resample	B-API	O
function	O	B-API
throwing	O	O
error	O	O
with	O	O
Twitter	O	O
Data	O	O

I	O	O
then	O	O
try	O	O
to	O	O
resample	O	B-API
for	O	O
analysis	O	O
#CODE	O	O

I'm	O	O
writing	O	O
several	O	O
pivot	O	B-API
tables	O	O
using	O	O
pandas	O	O
.	O	O

For	O	O
many	O	O
of	O	O
them	O	O
,	O	O
I	O	O
need	O	O
to	O	O
return	O	O
unique	O	B-API
values	O	B-API
.	O	O

In	O	O
a	O	O
two-dimensional	O	O
pivot	O	B-API
table	O	B-API
,	O	O
the	O	O
below	O	O
code	O	O
works	O	O
as	O	O
it	O	O
should	O	O
.	O	O

When	O	O
I	O	O
add	O	B-API
a	O	O
third	O	O
dimension	O	O
,	O	O
the	O	O
code	O	O
returns	O	O
the	O	O
count	O	B-API
rather	O	O
than	O	O
the	O	O
unique	O	B-API
count	O	B-API
.	O	O

I	O	O
suspect	O	O
this	O	O
has	O	O
something	O	O
to	O	O
do	O	O
with	O	O
the	O	O
aggfunc	B-API	O
,	O	O
but	O	O
can't	O	O
determine	O	O
to	O	O
what	O	O
it	O	O
should	O	O
be	O	O
changed	O	B-API
.	O	O

Use	O	O
a	O	O
groupby	B-API	O
to	O	O
get	O	B-API
at	O	B-API
each	O	O
combination	O	O
of	O	O
`	O	O
col_1	O	O
`	O	O
and	O	O
`	O	O
col_3	O	O
`	O	O
,	O	O
then	O	O
unstack	B-API	B-API
to	O	O
get	O	B-API
the	O	O
`	O	O
col_3	O	O
`	O	O
values	O	B-API
as	O	O
columns	O	O
:	O	O
#CODE	O	O

Python	O	O
pandas	O	O
merge	O	B-API
or	O	O
concat	O	B-API
dataframes	O	O

The	O	O
data	O	B-API
is	O	O
for	O	O
2	O	O
products	O	O
(	O	O
BBG.XAMS.UL.S_pnl_pos_cost	O	O
and	O	O
BBG.XAMS.UNA.S_pnl_pos_cost	O	O
)	O	O
by	O	O
date	O	B-API
,	O	O
in	O	O
the	O	O
future	O	O
there	O	O
will	O	O
be	O	O
more	O	O
products	O	O
.	O	O

I	O	O
want	O	O
to	O	O
concat	O	B-API
or	O	O
merge	O	B-API
(	O	O
not	O	O
sure	O	O
which	O	O
)	O	O
the	O	O
list	O	B-API
of	O	O
dataframes	O	O
into	O	O
one	O	O
data	O	B-API
frame	O	O
(	O	O
called	O	O
result	O	O
)	O	O
so	O	O
they	O	O
look	O	O
like	O	O
:	O	O
#CODE	O	O

where	O	B-API
axis	O	B-API
is	O	O
the	O	O
date	O	B-API
.	O	O

It	O	O
looks	O	O
like	O	O
the	O	O
data	O	B-API
is	O	O
merged	O	O
by	O	O
date	O	B-API
,	O	O
but	O	O
I	O	O
am	O	O
missing	O	O
the	O	O
data	O	B-API
for	O	O
the	O	O
week	O	B-API
beginning	O	O
2015-03-23	O	O
.	O	O

My	O	O
current	O	O
concat	O	B-API
result	O	O
dataframe	O	O
looks	O	O
like	O	O
:	O	O
#CODE	O	O

Try	O	O
using	O	O
axis=0	O	O
.	O	O

This	O	O
should	O	O
concat	O	B-API
column-wise	O	O
,	O	O
assuming	O	O
each	O	O
dataframe	O	O
has	O	O
the	O	O
same	O	O
column	O	O
names	O	B-API
.	O	O

possible	O	O
duplicate	O	O
of	O	O
[	O	O
Pandas	O	O
join	B-API	B-API
/	O	O
merge	B-API	B-API
/	O	O
concat	B-API	B-API
two	O	O
dataframes	O	O
]	O	O
(	O	O
#URL	O	O
)	O	O

Also	O	O
,	O	O
how	O	O
do	O	O
you	O	O
join	O	B-API
this	O	O
back	O	B-API
to	O	O
original	O	O
dataframe	O	O
?	O	O

We	O	O
can	O	O
resample	O	B-API
this	O	O
to	O	O
days	O	B-API
;	O	O
it'll	O	O
be	O	O
a	O	O
much	O	O
longer	O	O
timeseries	O	O
,	O	O
of	O	O
course	O	O
,	O	O
but	O	O
memory	O	O
is	O	O
cheap	O	O
and	O	O
I'm	O	O
lazy	O	O
:	O	O
#CODE	O	O

How	O	O
do	O	O
I	O	O
merge	O	B-API
the	O	O
birth	O	O
rate	O	B-API
back	O	B-API
to	O	O
the	O	O
original	O	O
table	O	B-API
?	O	O

Indexes	O	O
aren't	O	O
compatible	O	O
...	O	O

Turns	O	O
out	O	O
size	O	B-API
isn't	O	O
such	O	O
an	O	O
issue	O	O
.	O	O

Python	O	O
&	O	O
Pandas	O	O
:	O	O
Unable	O	O
to	O	O
drop	O	B-API
columns	O	O

I	O	O
try	O	O
to	O	O
drop	O	B-API
the	O	O
data	O	B-API
,	O	O
but	O	O
it	O	O
reports	O	O
some	O	O
column	O	O
does	O	O
not	O	O
exist	O	O
.	O	O

#CODE	O	O

@USER	O	O
,	O	O
that's	O	O
possible	O	O
,	O	O
but	O	O
I	O	O
don't	O	O
know	O	O
how	O	O
to	O	O
deal	O	O
with	O	O
it	O	O
.	O	O

In	O	O
my	O	O
previous	O	O
experience	O	O
with	O	O
pandas	O	O
,	O	O
it	O	O
will	O	O
automatically	O	O
turn	O	O
the	O	O
second	O	B-API
`	O	O
Q	O	O
`	O	O
into	O	O
`	O	O
Q.1	O	O
`	O	O
when	O	O
reading	O	O
the	O	O
data	O	B-API
.	O	O

However	O	O
,	O	O
in	O	O
my	O	O
case	O	O
,	O	O
it	O	O
failed	O	O
to	O	O
do	O	O
it	O	O
,	O	O
and	O	O
I	O	O
don't	O	O
know	O	O
why	O	O
.	O	O

However	O	O
,	O	O
This	O	O
it	O	O
cannot	O	O
`	O	O
drop	B-API	B-API
`	O	O
`	O	O
NCDC	O	O
`	O	O
either	O	O
.	O	O

You	O	O
can	O	O
then	O	O
drop	O	B-API
your	O	O
columns	O	O
:	O	O
#CODE	O	O

I	O	O
would	O	O
like	O	O
to	O	O
take	O	B-API
a	O	O
given	O	O
row	O	O
from	O	O
a	O	O
DataFrame	O	B-API
and	O	O
prepend	O	O
or	O	O
append	O	B-API
to	O	O
the	O	O
same	O	O
DataFrame	O	B-API
.	O	O

Rather	O	O
than	O	O
concat	O	B-API
I	O	O
would	O	O
just	O	O
assign	O	B-API
directly	O	O
to	O	O
the	O	O
df	O	O
after	O	O
`	O	O
shift	O	B-API
`	O	O
ing	O	O
,	O	O
then	O	O
use	O	B-API
`	O	O
iloc	B-API	O
`	O	O
to	O	O
reference	O	O
the	O	O
position	O	O
you	O	O
want	O	O
to	O	O
assign	O	B-API
the	O	O
row	O	O
,	O	O
you	O	O
have	O	O
to	O	O
call	O	O
`	O	O
squeeze	B-API	B-API
`	O	O
so	O	O
that	O	O
you	O	O
assign	O	B-API
just	O	O
the	O	O
values	O	B-API
and	O	O
lose	O	O
the	O	O
original	O	O
index	O	B-API
value	O	O
otherwise	O	O
it'll	O	O
raise	O	O
a	O	O
`	O	O
ValueError	O	O
`	O	O
:	O	O
#CODE	O	O

To	O	O
insert	O	B-API
at	O	B-API
the	O	O
end	O	O
:	O	O
#CODE	O	O

I'm	O	O
not	O	O
sure	O	O
exactly	O	O
what	O	O
you're	O	O
expecting	O	O
,	O	O
but	O	O
you	O	O
could	O	O
replace	O	B-API
your	O	O
lists	O	O
with	O	O
numpy	O	O
arrays	O	O
(	O	O
I	O	O
don't	O	O
think	O	O
it'll	O	O
improve	O	O
your	O	O
specific	O	O
code	O	O
):	O	O
#CODE	O	O

What	O	O
is	O	O
the	O	O
best	O	O
way	O	O
for	O	O
me	O	O
to	O	O
get	O	B-API
this	O	O
data	O	B-API
into	O	O
Pandas	O	O
?	O	O

Is	O	O
there	O	O
a	O	O
standard	O	O
way	O	O
I	O	O
could	O	O
use	O	B-API
`	O	O
read_table	B-API	O
`	O	O
or	O	O
some	O	O
similar	O	O
function	O	B-API
to	O	O
read	O	O
this	O	O
file	O	O
directly	O	O
?	O	O

Should	O	O
I	O	O
write	O	O
a	O	O
script	O	O
to	O	O
insert	O	B-API
commas	O	O
where	O	B-API
all	O	B-API
the	O	O
column	O	O
breaks	O	O
are	O	O
and	O	O
then	O	O
read	O	O
it	O	O
in	O	O
as	O	O
CSV	O	O
?	O	O

(	O	O
I'd	O	O
just	O	O
do	O	O
the	O	O
latter	O	O
,	O	O
but	O	O
I'm	O	O
also	O	O
interested	O	O
in	O	O
becoming	O	O
better	O	O
with	O	O
Pandas	O	O
so	O	O
if	O	O
there's	O	O
an	O	O
out-of-the-box	O	O
way	O	O
I'd	O	O
like	O	O
to	O	O
know	O	O
it	O	O
.	O	O
)	O	O

Any	O	O
ideas	O	O
on	O	O
how	O	O
to	O	O
get	O	B-API
this	O	O
file	O	O
to	O	O
load	O	B-API
?	O	O

Unfortunately	O	O
I	O	O
can't	O	O
just	O	O
strip	O	B-API
out	O	O
accents	O	O
,	O	O
as	O	O
I	O	O
have	O	O
to	O	O
interface	O	O
with	O	O
software	O	O
that	O	O
requires	O	O
the	O	O
proper	O	O
name	O	B-API
,	O	O
and	O	O
I	O	O
have	O	O
a	O	O
ton	O	O
of	O	O
files	O	O
to	O	O
format	O	B-API
(	O	O
not	O	O
just	O	O
the	O	O
one	O	O
)	O	O
.	O	O

Thanks	O	O
!	O	O

pls	O	O
show	O	B-API
your	O	O
input	O	O
and	O	O
what	O	O
is	O	O
the	O	O
expected	O	O
output	O	O
,	O	O
in	O	O
a	O	O
copy-pastable	O	O
form	O	O
.	O	O

What	O	O
you	O	O
are	O	O
doing	O	O
is	O	O
very	O	O
inefficient	O	O
.	O	O

A	O	O
groupby	B-API	O
should	O	O
try	O	O
to	O	O
use	O	B-API
vectorized	O	O
functions	O	O
when	O	O
possible	O	O
.	O	O

Then	O	O
join	O	B-API
them	O	O
up	O	O
at	O	B-API
the	O	O
end	O	O
.	O	O

Hi	O	O
Tom	O	O
,	O	O
it	O	O
doesn't	O	O
look	O	O
like	O	O
this	O	O
works	O	O
.	O	O

It	O	O
outputs	O	O
just	O	O
one	O	O
array	O	B-API
and	O	O
is	O	O
equivalent	O	O
to	O	O
df2	O	O
[	O	O
'	O	O
array	O	B-API
']	O	O
.sum()	B-API	B-API
.	O	O

But	O	O
you	O	O
have	O	O
given	O	O
me	O	O
an	O	O
idea	O	O
with	O	O
apply	B-API	B-API
.	O	O

Let	O	O
me	O	O
see	O	O
if	O	O
I	O	O
can	O	O
figure	O	B-API
something	O	O
out	O	O
.	O	O

You	O	O
need	O	O
`	O	O
apply	B-API	B-API
(	O	O
your_func	O	O
,	O	O
axis=1	O	O
)`	O	O
to	O	O
work	O	O
on	O	O
a	O	O
row-by-row	O	O
basis	O	O
.	O	O

#CODE	O	O

Another	O	O
way	O	O
would	O	O
be	O	O
to	O	O
call	O	O
`	O	O
unique	B-API	B-API
`	O	O
on	O	O
the	O	O
transpose	O	B-API
of	O	O
your	O	O
df	O	O
:	O	O
#CODE	O	O

Drop	O	O
values	O	B-API
satisfying	O	O
condition	O	O
plus	O	O
arbitrary	O	O
number	O	O
of	O	O
next	O	B-API
values	O	B-API
in	O	O
a	O	O
pandas	O	O
DataFrame	O	B-API

So	O	O
my	O	O
final	O	O
goal	O	O
is	O	O
to	O	O
drop	B-API	B-API
values	O	B-API
in	O	O
one	O	O
column	O	O
of	O	O
a	O	O
`	O	O
pandas	O	O
`	O	O
`	O	O
DataFrame	O	B-API
`	O	O
according	O	O
to	O	O
some	O	O
condition	O	O
on	O	O
another	O	O
column	O	O
of	O	O
the	O	O
same	O	O
`	O	O
DataFrame	O	B-API
`	O	O
,	O	O
plus	O	O
several	O	O
next	O	B-API
values	O	B-API
e.g.	O	B-API
:	O	O
#CODE	O	O

So	O	O
this	O	O
will	O	O
drop	O	B-API
the	O	O
records	O	O
where	O	B-API
the	O	O
condition	O	O
is	O	O
satisfied	O	O
,	O	O
but	O	O
how	O	O
do	O	O
I	O	O
drop	O	B-API
the	O	O
next	O	B-API
3	O	O
records	O	O
after	O	O
the	O	O
condition	O	O
was	O	O
satisfied	O	O
too	O	O
?	O	O

My	O	O
desired	O	O
output	O	O
would	O	O
look	O	O
something	O	O
like	O	O
this	O	O
:	O	O
#CODE	O	O

We	O	O
can	O	O
use	O	B-API
the	O	O
boolean	O	O
condition	O	O
index	O	B-API
to	O	O
slice	O	B-API
the	O	O
df	O	O
using	O	O
`	O	O
loc	B-API	B-API
`	O	O
and	O	O
set	O	B-API
the	O	O
following	O	O
values	O	B-API
:	O	O
#CODE	O	O

Panda's	O	O
boxplot	O	B-API
but	O	O
not	O	O
showing	O	O
the	O	O
box	O	B-API

Note	O	O
,	O	O
`	O	O
showbox	O	O
`	O	O
and	O	O
`	O	O
whiskerprops	O	O
`	O	O
are	O	O
the	O	O
`	O	O
kwds	O	O
`	O	O
of	O	O
boxplot	O	B-API
,	O	O
which	O	O
are	O	O
in	O	O
turn	O	O
passed	O	O
to	O	O
`	O	O
matplotlib.boxplot	B-API	B-API
`	O	O
.	O	O

Applying	O	O
aggregate	B-API	B-API
function	O	B-API
on	O	O
columns	O	O
of	O	O
Pandas	O	O
pivot	O	B-API
table	O	B-API

I	O	O
generated	O	O
the	O	O
following	O	O
pivot	O	B-API
table	O	B-API
via	O	O
taking	O	O
maximum	O	B-API
of	O	O
values	O	B-API
in	O	O
`	O	O
Z	O	O
`	O	O
column	O	O
:	O	O
#CODE	O	O

Here's	O	O
a	O	O
fairly	O	O
general	O	O
solution	O	O
you	O	O
can	O	O
apply	O	B-API
to	O	O
multiple	O	O
columns	O	O
.	O	O

The	O	O
'	O	O
To	O	O
'	O	O
column	O	O
doesn't	O	O
need	O	O
to	O	O
be	O	O
rounded	O	O
,	O	O
I	O	O
just	O	O
included	O	O
it	O	O
for	O	O
the	O	O
generality	O	O
of	O	O
two	O	O
columns	O	O
rather	O	O
than	O	O
one	O	O
:	O	O
#CODE	O	O

428	O	O
base	O	B-API
,	O	O
mult	O	O
=	O	O
_gfc	O	O
(	O	O
freq	O	B-API
)	O	O

-->	O	O
429	O	O
return	O	O
tslib.dt64arr_to_periodarr	O	B-API
(	O	O
data.view	O	B-API
(	O	O
'	O	O
i8	O	O
')	O	O
,	O	O
base	O	B-API
,	O	O
tz	O	B-API
)	O	O

I	O	O
could	O	O
do	O	O
a	O	O
left	O	O
merge	B-API	B-API
,	O	O
but	O	O
I	O	O
would	O	O
end	O	O
up	O	O
with	O	O
a	O	O
huge	O	O
file	O	O
.	O	O

Is	O	O
there	O	O
any	O	B-API
way	O	O
to	O	O
add	O	B-API
specific	O	O
rows	O	O
from	O	O
df2	O	O
to	O	O
df1	O	O
using	O	O
merge	B-API	B-API
?	O	O

Unclear	O	O
why	O	O
you	O	O
think	O	O
a	O	O
left	O	O
merge	B-API	B-API
would	O	O
produce	O	O
a	O	O
huge	O	O
file	O	O
,	O	O
by	O	O
performing	O	O
a	O	O
left	O	O
merge	B-API	B-API
on	O	O
the	O	O
product	O	B-API
id	O	O
you	O	O
are	O	O
stating	O	O
that	O	O
you	O	O
are	O	O
only	O	O
interested	O	O
in	O	O
matches	O	O
in	O	O
the	O	O
product_id	O	O
column	O	O
only	O	O

Just	O	O
perform	O	O
a	O	O
left	O	O
`	O	O
merge	B-API	B-API
`	O	O
on	O	O
'	O	O
product_id	O	O
'	O	O
column	O	O
:	O	O
#CODE	O	O

What	O	O
would	O	O
be	O	O
the	O	O
Python	O	O
equivalent	O	O
?	O	O

I	O	O
cannot	O	O
think	O	O
of	O	O
a	O	O
way	O	O
to	O	O
translate	O	B-API
this	O	O
where	O	B-API
statement	O	O
into	O	O
pandas	O	O
syntax	O	O
.	O	O

The	O	O
only	O	O
way	O	O
I	O	O
can	O	O
think	O	O
of	O	O
is	O	O
to	O	O
add	O	B-API
an	O	O
arbitrary	O	O
field	O	B-API
to	O	O
people_usa	O	O
(	O	O
e.g.	O	B-API
`	O	O
people_usa	O	O
[	O	O
'	O	O
dummy	O	O
']	O	O
=1	O	O
`)	O	O
,	O	O
do	O	O
a	O	O
left	O	O
join	B-API	B-API
,	O	O
then	O	O
take	O	B-API
only	O	O
the	O	O
records	O	O
where	O	B-API
'	O	O
dummy	O	O
'	O	O
is	O	O
nan	O	O
,	O	O
then	O	O
delete	O	B-API
the	O	O
dummy	O	O
field	O	B-API
-	O	O
which	O	O
seems	O	O
a	O	O
bit	O	O
convoluted	O	O
.	O	O

Does	O	O
this	O	O
work	O	O
only	O	O
on	O	O
the	O	O
index	O	B-API
of	O	O
the	O	O
dataframe	O	O
?	O	O

I'd	O	O
like	O	O
the	O	O
option	O	O
to	O	O
specify	O	O
the	O	O
field	O	B-API
(	O	O
s	O	O
)	O	O
to	O	O
apply	O	B-API
this	O	O
to	O	O

Is	O	O
there	O	O
any	O	B-API
easy	O	O
way	O	O
to	O	O
do	O	O
this	O	O
if	O	O
you	O	O
have	O	O
multiple	O	O
columns	O	O
to	O	O
check	O	O
/	O	O
join	O	B-API
?	O	O

You	O	O
could	O	O
do	O	O
a	O	O
`	O	O
merge	B-API	B-API
`	O	O
and	O	O
then	O	O
eliminate	O	O
the	O	O
rows	O	O
that	O	O
exist	O	O
in	O	O
the	O	O
merged	O	O
df	O	O
otherwise	O	O
you'd	O	O
have	O	O
to	O	O
build	O	O
a	O	O
boolean	O	O
condition	O	O
for	O	O
all	O	B-API
the	O	O
columns	O	O
you	O	O
want	O	O
to	O	O
compare	O	O
but	O	O
presumably	O	O
when	O	O
checking	O	O
the	O	O
multiple	O	O
columns	O	O
you're	O	O
stating	O	O
that	O	O
it's	O	O
unique	O	B-API
for	O	O
those	O	O
columns	O	O
,	O	O
correct	O	O
?	O	O

For	O	O
instance	O	O
it's	O	O
not	O	O
a	O	O
match	O	B-API
if	O	O
say	O	O
col1	O	O
and	O	O
col2	O	O
match	O	B-API
but	O	O
col3	O	O
does	O	O
not	O	O

Yes	O	O
merge	B-API	B-API
is	O	O
what	O	O
I	O	O
have	O	O
been	O	O
doing	O	O
but	O	O
it	O	O
feels	O	O
like	O	O
a	O	O
hassle	O	O
.	O	O

I've	O	O
come	O	O
up	O	O
with	O	O
this	O	O
,	O	O
using	O	O
itertools	B-API	O
,	O	O
to	O	O
find	O	B-API
mid-day	O	O
timestamps	O	O
and	O	O
group	O	B-API
them	O	O
by	O	O
date	O	B-API
,	O	O
and	O	O
now	O	O
I'm	O	O
coming	O	O
up	O	O
short	O	O
trying	O	O
to	O	O
apply	O	B-API
imap	O	O
to	O	O
find	O	B-API
the	O	O
means	O	O
.	O	O

#CODE	O	O

Since	O	O
not	O	O
sure	O	O
what	O	O
your	O	O
end	O	O
output	O	O
should	O	O
look	O	O
like	O	O
,	O	O
just	O	O
create	O	O
a	O	O
time-based	O	O
grouper	B-API	O
manually	O	O
(	O	O
this	O	O
is	O	O
essentially	O	O
a	O	O
resample	B-API	B-API
)	O	O
,	O	O
but	O	O
doesn't	O	O
do	O	O
anything	O	O
with	O	O
the	O	O
final	O	O
results	O	O
(	O	O
its	O	O
just	O	O
a	O	O
list	O	B-API
of	O	O
the	O	O
aggregated	O	O
values	O	B-API
)	O	O
#CODE	O	O

You	O	O
can	O	O
get	O	B-API
reasonable	O	O
fancy	O	O
here	O	O
and	O	O
say	O	O
return	O	O
a	O	O
pandas	O	O
object	O	O
(	O	O
and	O	O
potentially	O	O
`	O	O
concat	O	B-API
`	O	O
them	O	O
)	O	O
.	O	O

and	O	O
I	O	O
want	O	O
to	O	O
pivot	O	B-API
it	O	O
like	O	O
this	O	O
:	O	O
#CODE	O	O

I	O	O
am	O	O
calling	O	O
a	O	O
function	O	B-API
from	O	O
within	O	O
a	O	O
'	O	O
for	O	O
each	O	O
loop	O	O
'	O	O
which	O	O
attempts	O	O
to	O	O
insert	O	B-API
values	O	B-API
into	O	O
a	O	O
Pandas	O	O
DataFrame	O	B-API
based	O	O
on	O	O
a	O	O
specified	O	O
column	O	O
start	O	O
and	O	O
end	O	O
location	O	O
.	O	O

The	O	O
function	O	B-API
is	O	O
this	O	O
:	O	O
#CODE	O	O

My	O	O
issue	O	O
is	O	O
that	O	O
despite	O	O
the	O	O
same	O	O
starting	O	O
conditions	O	O
when	O	O
I	O	O
call	O	O
this	O	O
function	O	B-API
it	O	O
seems	O	O
to	O	O
generate	O	O
a	O	O
list	O	B-API
of	O	O
inconsistent	O	O
length	O	O
.	O	O

e.g.	O	B-API
with	O	O
values	O	B-API
of	O	O
srowb	O	O
=	O	O
1	O	O
and	O	O
erowb	O	O
=	O	O
18	O	O
it	O	O
will	O	O
generate	O	O
a	O	O
list	O	B-API
(	O	O
tmp_brollb	O	O
)	O	O
which	O	O
has	O	O
either	O	O
len	B-API	B-API
(	O	O
tmp_brollb	O	O
)	O	O
=	O	O
17	O	O
or	O	O
len	B-API	B-API
(	O	O
tmp_brollb	O	O
)	O	O
=	O	O
18	O	O

Use	O	O
`	O	O
max	B-API	B-API
`	O	O
and	O	O
check	O	O
for	O	O
equality	O	O
using	O	O
`	O	O
eq	B-API	B-API
`	O	O
and	O	O
cast	O	O
the	O	O
boolean	O	O
df	O	O
to	O	O
int	O	O
using	O	O
`	O	O
astype	B-API	O
`	O	O
,	O	O
this	O	O
will	O	O
convert	O	B-API
`	O	O
True	O	O
`	O	O
and	O	O
`	O	O
False	O	O
`	O	O
to	O	O
`	O	O
1	O	O
`	O	O
and	O	O
`	O	O
0	O	O
`	O	O
:	O	O
#CODE	O	O

Thanks	O	O
@USER	O	O
.	O	O

Did	O	O
you	O	O
try	O	O
my	O	O
original	O	O
post	O	O
?	O	O

I	O	O
would	O	O
be	O	O
interested	O	O
to	O	O
know	O	O
how	O	O
much	O	O
time	O	B-API
this	O	O
one	O	O
is	O	O
taking	O	O
compared	O	O
to	O	O
yours	O	O
?	O	O

`	O	O
for	O	O
i	O	O
in	O	O
range	O	O
(	O	O
len	B-API	B-API
(	O	O
df	O	O
)):	O	O
...	O	O

df.loc	B-API	B-API
[	O	O
i	O	O
]	O	O
[	O	O
df.loc	B-API	B-API
[	O	O
i	O	O
]	O	O
.idxmax	B-API	B-API
(	O	O
axis=1	O	O
)]	O	O
=	O	O
1	O	O
...	O	O

df.loc	B-API	B-API
[	O	O
i	O	O
]	O	O
[	O	O
df.loc	B-API	B-API
[	O	O
i	O	O
]	O	O
!	O	O
=	O	O
1	O	O
]	O	O
=	O	O
0	O	O
`	O	O

I	O	O
am	O	O
trying	O	O
to	O	O
normalize	O	B-API
the	O	O
missing	O	O
values	O	B-API
in	O	O
matrix	O	B-API
.	O	O

Here	O	O
is	O	O
the	O	O
code	O	O
.	O	O

#CODE	O	O

Last	O	O
line	O	O
should	O	O
replace	O	B-API
the	O	O
values	O	B-API
in	O	O
dataset1	O	O
by	O	O
mean	O	B-API
values	O	B-API
from	O	O
`	O	O
ds2_mean	O	O
[	O	O
1	O	O
]`	O	O
.	O	O

But	O	O
it	O	O
does	O	O
not	O	O
do	O	O
.	O	O

Anything	O	O
wrong	O	O
here	O	O
?	O	O

And	O	O
after	O	O
that	O	O
can	O	O
I	O	O
replace	O	B-API
NaN	O	O
with	O	O
the	O	O
average	O	B-API
value	O	O
of	O	O
it's	O	O
neighbours	O	O
in	O	O
dataset1	O	O
?	O	O

it	O	O
does	O	O
wrong	O	O
.	O	O

For	O	O
any	O	B-API
x	O	O
in	O	O
dataset2	O	O
it	O	O
has	O	O
mapped	O	O
value	O	O
in	O	O
col2	O	O
.	O	O

It	O	O
should	O	O
replace	O	B-API
all	O	B-API
values	O	B-API
of	O	O
x	O	O
in	O	O
ds1	O	O
by	O	O
mapped	O	O
value	O	O
.	O	O

But	O	O
this	O	O
also	O	O
does	O	O
not	O	O
do	O	O
it	O	O

Sorry	O	O
can	O	O
you	O	O
explain	O	O
clearer	O	O
,	O	O
what	O	O
are	O	O
you	O	O
mapping	O	O
from	O	O
what	O	O
to	O	O
what	O	O
exactly	O	O
?	O	O

By	O	O
default	O	O
fillna	B-API	O
will	O	O
use	O	B-API
the	O	O
index	O	B-API
so	O	O
how	O	O
do	O	O
you	O	O
want	O	O
the	O	O
mapping	O	O
from	O	O
`	O	O
ds2	O	O
`	O	O
to	O	O
map	O	B-API
to	O	O
the	O	O
missing	O	O
values	O	B-API
in	O	O
`	O	O
ds1	O	O
`	O	O
?	O	O

Are	O	O
you	O	O
wanting	O	O
to	O	O
map	O	B-API
using	O	O
the	O	O
values	O	B-API
in	O	O
`	O	O
ds2	O	O
[	O	O
0	O	O
]`	O	O
as	O	O
the	O	O
index	O	B-API
lookup	O	B-API
?	O	O

So	O	O
use	O	B-API
the	O	O
index	O	B-API
from	O	O
`	O	O
ds1	O	O
`	O	O
find	O	B-API
value	O	O
in	O	O
`	O	O
ds2	O	O
[	O	O
0	O	O
]`	O	O
and	O	O
return	O	O
`	O	O
ds2	O	O
[	O	O
1	O	O
]`	O	O
?	O	O

yes	O	O
,	O	O
I	O	O
want	O	O
to	O	O
use	O	B-API
the	O	O
index	O	B-API
from	O	O
ds1	O	O
find	O	B-API
value	O	O
in	O	O
ds2	O	O
[	O	O
0	O	O
]	O	O
and	O	O
replace	O	B-API
it	O	O
with	O	O
ds2	O	O
[	O	O
1	O	O
]"	O	O
sorry	O	O
for	O	O
inconvenience	O	O

I	O	O
want	O	O
to	O	O
add	O	B-API
a	O	O
new	O	O
column	O	O
which	O	O
contains	O	B-API
values	O	B-API
based	O	O
on	O	O
df	O	O
[	O	O
'	O	O
diff	O	B-API
']	O	O

When	O	O
using	O	O
`	O	O
DataFrame.apply	B-API	B-API
`	O	O
if	O	O
you	O	O
use	O	B-API
`	O	O
axis=0	O	O
`	O	O
it	O	O
applies	O	O
the	O	O
condition	O	O
through	O	O
columns	O	O
,	O	O
to	O	O
use	O	B-API
`	O	O
apply	B-API	B-API
`	O	O
to	O	O
go	O	O
through	O	O
each	O	O
row	O	O
,	O	O
you	O	O
need	O	O
`	O	O
axis=1	O	O
`	O	O
.	O	O

But	O	O
given	O	O
that	O	O
,	O	O
you	O	O
can	O	O
use	O	B-API
`	O	O
Series.apply	B-API	B-API
`	O	O
instead	O	O
of	O	O
`	O	O
DataFrame.apply	B-API	B-API
`	O	O
on	O	O
the	O	O
`'	O	O
diff	B-API	B-API
'`	O	O
series	O	O
.	O	O

Example	O	O
-	O	O
#CODE	O	O

You	O	O
can	O	O
just	O	O
set	O	B-API
all	O	B-API
the	O	O
values	O	B-API
that	O	O
meet	O	O
your	O	O
criteria	O	O
rather	O	O
than	O	O
looping	O	O
over	O	B-API
the	O	O
df	O	O
by	O	O
calling	O	O
`	O	O
apply	B-API	B-API
`	O	O
so	O	O
the	O	O
following	O	O
should	O	O
work	O	O
and	O	O
as	O	O
it's	O	O
vectorised	O	O
will	O	O
scale	O	O
better	O	O
for	O	O
larger	O	O
datasets	O	O
:	O	O
#CODE	O	O

this	O	O
will	O	O
set	O	B-API
all	O	B-API
rows	O	O
that	O	O
meet	O	O
the	O	O
criteria	O	O
,	O	O
the	O	O
problem	O	O
using	O	O
`	O	O
apply	B-API	B-API
`	O	O
is	O	O
that	O	O
it's	O	O
just	O	O
syntactic	O	O
sugar	O	O
for	O	O
a	O	O
`	O	O
for	O	O
`	O	O
loop	O	O
and	O	O
where	O	B-API
possible	O	O
this	O	O
should	O	O
be	O	O
avoided	O	O
where	O	B-API
a	O	O
vectorised	O	O
solution	O	O
exists	O	B-API
.	O	O

Then	O	O
you	O	O
can	O	O
`	O	O
stack	B-API	B-API
`	O	O
(	O	O
first	O	B-API
by	O	O
`'	O	O
Marker	O	O
'`	O	O
then	O	O
by	O	O
`'	O	O
mrk	O	O
'`)	O	O
:	O	O
#CODE	O	O

Python	O	O
DataFrame	O	B-API
-	O	O
apply	O	B-API
different	O	O
calculations	O	O
due	O	O
to	O	O
a	O	O
column's	O	O
value	O	O

You	O	O
could	O	O
do	O	O
this	O	O
using	O	O
2	O	O
`	O	O
loc	B-API	B-API
`	O	O
calls	O	O
:	O	O
#CODE	O	O

There	O	O
are	O	O
two	O	O
reasons	O	O
whiskers	O	O
length	O	O
vary	O	O
from	O	O
one	O	O
boxplot	O	B-API
to	O	O
any	O	B-API
other	O	O
boxplot	O	B-API

Are	O	O
you	O	O
asking	O	O
why	O	O
the	O	O
top	O	O
whisker	O	O
isn't	O	O
the	O	O
same	O	O
length	O	O
as	O	O
the	O	O
bottom	O	O
?	O	O

I	O	O
think	O	O
the	O	O
whiskers	O	O
are	O	O
actually	O	O
the	O	O
lowest	O	O
or	O	O
highest	O	O
data	O	B-API
point	O	O
within	O	O
1.5	O	O
IQR	O	O
.	O	O

So	O	O
if	O	O
there	O	O
are	O	O
no	O	O
data	O	B-API
points	O	O
between	O	B-API
Q3	O	O
and	O	O
Q3	O	O
+	O	O
1.5	O	O
IQR	O	O
,	O	O
then	O	O
the	O	O
top	O	O
whisker	O	O
won't	O	O
show	O	B-API
up	O	O
.	O	O

For	O	O
the	O	O
one	O	O
boxplot	O	B-API
where	O	B-API
the	O	O
are	O	O
outliers	O	O
beyond	O	O
the	O	O
whiskers	O	O
on	O	O
both	O	O
the	O	O
top	O	O
and	O	O
the	O	O
bottom	O	O
,	O	O
the	O	O
whiskers	O	O
do	O	O
look	O	O
about	O	O
the	O	O
same	O	O
size	O	B-API
.	O	O

``	O	O
hist	B-API	B-API
``	O	O
->	O	O
``	O	O
histogram	O	B-API
``	O	O
(	O	O
``	O	O
hist	B-API	B-API
``	O	O
is	O	O
pyplot	B-API	O
or	O	O
something	O	O
)	O	O
.	O	O

There	O	O
is	O	O
a	O	O
pandas	O	O
equivalent	O	O
to	O	O
this	O	O
`	O	O
cut	B-API	B-API
`	O	O
there	O	O
is	O	O
a	O	O
section	O	O
describing	O	O
this	O	O
here	O	O
.	O	O

`	O	O
cut	B-API	B-API
`	O	O
returns	O	O
the	O	O
open	O	B-API
closed	O	O
intervals	O	O
for	O	O
each	O	O
value	O	O
:	O	O
#CODE	O	O

Pandas	O	O
Dataframe	O	O
,	O	O
Apply	B-API	O
Function	O	O
,	O	O
Return	O	O
Index	O	B-API

Then	O	O
I	O	O
can	O	O
apply	O	B-API
the	O	O
function	O	B-API
to	O	O
my	O	O
dataframe	O	O
,	O	O
grouped	O	O
by	O	O
I	O	O
D:	O	O
#CODE	O	O

If	O	O
I	O	O
resample	O	B-API
this	O	O
DataField	O	O
by	O	O
any	O	B-API
frequency	O	O
,	O	O
the	O	O
timezone	O	O
is	O	O
kept	O	O
:	O	O
#CODE	O	O

their	O	O
are	O	O
a	O	O
couple	O	O
of	O	O
outstanding	O	O
bugs	O	O
w.r.t	O	B-API
to	O	O
resample	O	B-API
and	O	O
extra	O	O
binning	O	O
:	O	O
#URL	O	O
if	O	O
you	O	O
would	O	O
like	O	O
to	O	O
investigate	O	O
and	O	O
try	O	O
to	O	O
pinpoint	O	O
(	O	O
or	O	O
better	O	O
yet	O	O
fix	O	B-API
)	O	O
would	O	O
be	O	O
appreciated	O	O
!	O	O

you	O	O
can	O	O
comment	O	O
on	O	O
that	O	O
issue	O	O
directly	O	O

@USER	O	O
;	O	O
You	O	O
mean	O	B-API
to	O	O
the	O	O
stack	O	B-API
exchange	O	O
answer	O	O
?	O	O

I	O	O
think	O	O
that	O	O
I	O	O
understand	O	O
what's	O	O
going	O	O
on	O	O
:	O	O
create	O	O
a	O	O
frequency	O	O
table	O	B-API
of	O	O
ALL	O	O
words	O	O
.	O	O

After	O	O
each	O	O
operation	O	O
,	O	O
drop	O	B-API
all	O	B-API
relevant	O	O
columns	O	O
,	O	O
then	O	O
finally	O	O
count	O	B-API
all	O	B-API
remaining	O	O
columns	O	O
.	O	O

Also	O	O
,	O	O
I	O	O
quickly	O	O
tried	O	O
this	O	O
in	O	O
Python	O	O
3.4.3	O	O
and	O	O
I	O	O
got	O	O
the	O	O
error	O	O
that	O	O
freqDf	O	O
isn't	O	O
defined	O	O
.	O	O

Should	O	O
I	O	O
first	O	B-API
create	O	O
a	O	O
new	O	O
table	O	B-API
named	O	O
freqDf	O	O
?	O	O

`	O	O
df.precedingWord.isin	O	B-API
(	O	O
neuter	O	O
)`	O	O
is	O	O
just	O	O
a	O	O
Series	O	B-API
of	O	O
True	O	O
or	O	O
False	O	O
(	O	O
results	O	O
of	O	O
the	O	O
previous	O	O
test	O	B-API
`	O	O
isin	B-API	O
`)	O	O
,	O	O
and	O	O
pandas	O	O
will	O	O
just	O	O
access	O	O
True	O	O
indexes	O	O
with	O	O
`	O	O
loc	B-API	B-API
`	O	O

I	O	O
have	O	O
tried	O	O
a	O	O
some	O	O
join	B-API	B-API
/	O	O
merge	B-API	B-API
ideas	O	O
but	O	O
can't	O	O
seem	O	O
to	O	O
get	O	B-API
it	O	O
to	O	O
work	O	O
.	O	O

Just	O	O
`	O	O
concat	B-API	B-API
`	O	O
them	O	O
and	O	O
pass	O	O
param	O	O
`	O	O
axis=1	O	O
`	O	O
:	O	O
#CODE	O	O

Or	O	O
`	O	O
merge	B-API	B-API
`	O	O
on	O	O
'	O	O
Symbol	O	O
'	O	O
column	O	O
:	O	O
#CODE	O	O

Pandas	O	O
:	O	O
join	O	B-API
with	O	O
outer	O	B-API
product	O	B-API

How	O	O
to	O	O
join	O	B-API
/	O	O
multiply	O	B-API
the	O	O
DataFrames	O	O
`	O	O
areas	O	O
`	O	O
and	O	O
`	O	O
demand	O	O
`	O	O
together	O	O
in	O	O
a	O	O
decent	O	O
way	O	O
?	O	O

Now	O	O
`	O	O
apply	B-API	B-API
`	O	O
needs	O	O
to	O	O
return	O	O
a	O	O
`	O	O
Series	B-API	B-API
`	O	O
,	O	O
not	O	O
a	O	O
`	O	O
DataFrame	O	B-API
`	O	O
.	O	O

One	O	O
way	O	O
to	O	O
turn	O	O
a	O	O
`	O	O
DataFrame	O	B-API
`	O	O
into	O	O
a	O	O
`	O	O
Series	B-API	B-API
`	O	O
is	O	O
to	O	O
use	O	B-API
`	O	O
stack	B-API	B-API
`	O	O
.	O	O

`	O	O
stack	B-API	B-API
`	O	O
this	O	O
DataFrame	O	B-API
.	O	O

This	O	O
can	O	O
be	O	O
done	O	O
with	O	O
`	O	O
unstack	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

`	O	O
del	O	O
`	O	O
+	O	O
`	O	O
pivot	B-API	B-API
`	O	O
turns	O	O
out	O	O
to	O	O
be	O	O
faster	O	O
than	O	O
`	O	O
pivot_table	B-API	O
`	O	O
in	O	O
this	O	O
case	O	O
.	O	O

Maybe	O	O
the	O	O
reason	O	O
`	O	O
pivot	B-API	B-API
`	O	O
exists	O	B-API
is	O	O
because	O	O
it	O	O
is	O	O
faster	O	O
than	O	O
`	O	O
pivot_table	B-API	O
`	O	O
for	O	O
those	O	O
cases	O	O
where	O	B-API
it	O	O
is	O	O
applicable	O	O
(	O	O
such	O	O
as	O	O
when	O	O
you	O	O
don't	O	O
need	O	O
aggregation	O	O
)	O	O
.	O	O

`	O	O
apply	B-API	B-API
`	O	O
is	O	O
now	O	O
among	O	O
my	O	O
top	O	O
5	O	O
functions	O	O
to	O	O
always	O	O
remember	O	O
.	O	O

Concerning	O	O
the	O	O
`	O	O
pivot_table	B-API	O
`	O	O
solution	O	O
:	O	O
At	O	O
which	O	O
point	O	O
am	O	O
I	O	O
supposed	O	O
to	O	O
enter	O	O
the	O	O
line	O	O
?	O	O

No	O	O
matter	O	O
when	O	O
in	O	O
my	O	O
attempt	O	O
above	O	O
,	O	O
I	O	O
always	O	O
get	O	B-API
`	O	O
no	O	O
item	O	B-API
named	O	O
Edge	O	O
`	O	O
.	O	O

Or	O	O
pass	O	O
`	O	O
axis=0	O	O
`	O	O
to	O	O
`	O	O
loc	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

I've	O	O
got	O	O
2	O	O
pandas	O	O
dataframes	O	O
,	O	O
each	O	O
of	O	O
them	O	O
has	O	O
an	O	O
index	O	B-API
with	O	O
dtype	B-API	O
`	O	O
object	O	O
`	O	O
,	O	O
and	O	O
in	O	O
both	O	O
of	O	O
them	O	O
I	O	O
can	O	O
see	O	O
the	O	O
value	O	O
`	O	O
533	O	O
`	O	O
.	O	O

However	O	O
,	O	O
when	O	O
I	O	O
join	B-API	B-API
them	O	O
the	O	O
result	O	O
is	O	O
empty	O	B-API
,	O	O
as	O	O
one	O	O
of	O	O
them	O	O
is	O	O
the	O	O
number	O	O
`	O	O
533	O	O
`	O	O
and	O	O
the	O	O
other	O	O
is	O	O
a	O	O
string	O	O
`"	O	O
533	O	O
"`	O	O
.	O	O

Ideally	O	O
I	O	O
would	O	O
like	O	O
something	O	O
like	O	O
`	O	O
apply_chunk()	O	O
`	O	O
which	O	O
is	O	O
the	O	O
same	O	O
as	O	O
apply	B-API	B-API
but	O	O
only	O	O
works	O	O
on	O	O
a	O	O
piece	O	O
of	O	O
the	O	O
dataframe	O	O
.	O	O

This	O	O
has	O	O
to	O	O
be	O	O
a	O	O
common	O	O
problem	O	O
though	O	O
,	O	O
is	O	O
there	O	O
a	O	O
design	O	O
pattern	O	O
I	O	O
should	O	O
be	O	O
using	O	O
for	O	O
adding	O	O
columns	O	O
to	O	O
large	O	O
pandas	O	O
dataframes	O	O
?	O	O

whats	O	O
about	O	O
using	O	O
the	O	O
apply	B-API	B-API
method	O	O
?	O	O

Anytime	O	O
you	O	O
find	O	B-API
yourself	O	O
using	O	O
`	O	O
apply	B-API	B-API
`	O	O
or	O	O
`	O	O
iloc	B-API	O
`	O	O
in	O	O
a	O	O
loop	O	O
it's	O	O
likely	O	O
that	O	O
Pandas	O	O
is	O	O
operating	O	O
much	O	O
slower	O	O
than	O	O
is	O	O
optimal	O	O
.	O	O

Convert	O	O
freq	O	B-API
string	O	O
to	O	O
DateOffset	B-API	O
in	O	O
pandas	O	O

In	O	O
pandas	O	O
documentation	O	O
one	O	O
can	O	O
read	O	O
"	O	O
Under	O	O
the	O	O
hood	O	O
,	O	O
these	O	O
frequency	O	O
strings	O	O
are	O	O
being	O	O
translated	O	O
into	O	O
an	O	O
instance	O	O
of	O	O
pandas	O	O
DateOffset	B-API	O
"	O	O
when	O	O
speaking	O	O
of	O	O
freq	O	B-API
string	O	O
such	O	O
as	O	O
"	O	O
W	O	O
"	O	O
or	O	O
"	O	O
W-SUN	O	O
"	O	O
.	O	O

stack	O	B-API
/	O	O
unstack	O	B-API
/	O	O
pivot	O	B-API
dataframe	O	O
on	O	O
python	O	O
/	O	O
pandas	O	O

yes	O	O
,	O	O
`	O	O
isnull	B-API	B-API
`	O	O
will	O	O
create	O	O
a	O	O
boolean	O	O
series	O	O
,	O	O
`	O	O
all	B-API	B-API
`	O	O
returns	O	O
`	O	O
True	O	O
`	O	O
if	O	O
all	O	B-API
are	O	O
`	O	O
True	O	O
`	O	O

Then	O	O
merge	O	B-API
the	O	O
sub-tables	O	O
back	O	B-API
together	O	O
in	O	O
a	O	O
way	O	O
that	O	O
replaces	O	O
NaN	O	O
values	O	B-API
when	O	O
there	O	O
is	O	O
data	O	B-API
in	O	O
one	O	O
of	O	O
the	O	O
tables	O	O
.	O	O

I	O	O
regularly	O	O
work	O	O
with	O	O
very	O	O
large	O	O
data	O	B-API
sets	O	O
that	O	O
are	O	O
too	O	O
big	O	O
to	O	O
manipulate	O	O
in	O	O
memory	O	O
.	O	O

I	O	O
would	O	O
like	O	O
to	O	O
read	O	O
in	O	O
a	O	O
csv	O	O
file	O	O
iteratively	O	O
,	O	O
append	O	B-API
each	O	O
chunk	O	O
into	O	O
HDFStore	B-API	O
object	O	O
,	O	O
and	O	O
then	O	O
work	O	O
with	O	O
subsets	O	O
of	O	O
the	O	O
data	O	B-API
.	O	O

If	O	O
you	O	O
replace	O	B-API
that	O	O
line	O	O
with	O	O
:	O	O

I	O	O
wanted	O	O
to	O	O
merge	O	B-API
these	O	O
files	O	O
so	O	O
that	O	O
i	O	O
have	O	O
something	O	O
like	O	O
this	O	O
#CODE	O	O

If	O	O
it's	O	O
six	O	O
,	O	O
then	O	O
you	O	O
can	O	O
use	O	B-API
join	B-API	B-API
method	O	O
by	O	O
@USER	O	O
Hayden	O	O
.	O	O

Then	O	O
you	O	O
can	O	O
simply	O	O
`	O	O
join	B-API	B-API
`	O	O
them	O	O
:	O	O
#CODE	O	O

@USER	O	O
when	O	O
you	O	O
do	O	O
a	O	O
join	B-API	B-API
with	O	O
2x2	O	O
duplicates	O	O
you	O	O
get	O	B-API
4	O	O
in	O	O
the	O	O
joined	O	B-API
DataFrame	O	B-API
.	O	O

It's	O	O
unclear	O	O
how	O	O
pandas	O	O
should	O	O
join	O	B-API
in	O	O
this	O	O
case	O	O
,	O	O
so	O	O
you	O	O
need	O	O
to	O	O
be	O	O
more	O	O
explicit	O	O
to	O	O
it	O	O
(	O	O
and	O	O
tell	O	O
it	O	O
what	O	O
do	O	O
you	O	O
want	O	O
)	O	O
.	O	O

On	O	O
the	O	O
similar	O	O
note	O	O
,	O	O
is	O	O
there	O	O
a	O	O
way	O	O
to	O	O
merge	O	B-API
values	O	B-API
based	O	O
on	O	O
index	O	B-API
.	O	O

For	O	O
example	O	O
,	O	O
instead	O	O
of	O	O
listing	O	O
Bact5	O	O
in	O	O
two	O	O
rows	O	O
,	O	O
can	O	O
we	O	O
merge	O	B-API
its	O	O
value	O	O
corresponding	O	O
to	O	O
file2	O	O
in	O	O
one	O	O
row	O	O
separated	O	O
by	O	O
a	O	O
delimeter	O	O
?	O	O

Pandas	O	O
dataframe	O	O
insert	O	B-API
rows	O	O

I	O	O
want	O	O
to	O	O
insert	O	B-API
rows	O	O
in	O	O
DF	O	O
and	O	O
modify	O	O
its	O	O
related	O	O
values	O	B-API
:	O	O

The	O	O
code	O	O
can	O	O
only	O	O
append	O	B-API
rows	O	O
but	O	O
how	O	O
to	O	O
modify	O	O
its	O	O
values	O	B-API
in	O	O
a	O	O
faster	O	O
way	O	O
?	O	O

I	O	O
want	O	O
to	O	O
use	O	B-API
a	O	O
function	O	B-API
from	O	O
an	O	O
add-in	O	O
in	O	O
excel	O	O
and	O	O
apply	O	B-API
it	O	O
to	O	O
some	O	O
data	O	B-API
i	O	O
have	O	O
simulated	O	O
in	O	O
python	O	O
.	O	O

I	O	O
need	O	O
to	O	O
be	O	O
able	O	O
to	O	O
call	O	O
the	O	O
add-in	O	O
and	O	O
apply	O	B-API
my	O	O
data	O	B-API
indexes	O	O
there	O	O
...	O	O
something	O	O
along	O	O
these	O	O
lines	O	B-API
:	O	O
=	O	O
add-in_name	O	O
(	O	O
data_range1	O	O
,	O	O
data_range2	O	O
,	O	O
"	O	O
GGCV	O	O
")	O	O

After	O	O
reading	O	O
one	O	O
line	O	O
I	O	O
append	O	B-API
the	O	O
dictionary	O	O
to	O	O
a	O	O
list	O	B-API
(	O	O
so	O	O
,	O	O
the	O	O
number	O	O
of	O	O
dictionaries	O	O
in	O	O
the	O	O
list	O	B-API
is	O	O
equal	O	B-API
to	O	O
the	O	O
number	O	O
of	O	O
lines	O	B-API
in	O	O
the	O	O
file	O	O
)	O	O
.	O	O

I	O	O
can	O	O
easily	O	O
do	O	O
this	O	O
iteratively	O	O
with	O	O
loops	O	O
,	O	O
but	O	O
I've	O	O
read	O	O
that	O	O
you're	O	O
supposed	O	O
to	O	O
slice	B-API	B-API
/	O	O
merge	B-API	B-API
/	O	O
join	B-API	B-API
data	O	B-API
frames	O	O
holistically	O	O
,	O	O
so	O	O
I'm	O	O
trying	O	O
to	O	O
see	O	O
if	O	O
I	O	O
can	O	O
find	O	B-API
a	O	O
better	O	O
way	O	O
of	O	O
doing	O	O
this	O	O
.	O	O

A	O	O
join	B-API	B-API
will	O	O
give	O	O
me	O	O
all	O	B-API
the	O	O
stuff	O	O
that	O	O
matches	O	O
,	O	O
but	O	O
that's	O	O
not	O	O
exactly	O	O
what	O	O
I'm	O	O
looking	O	O
for	O	O
,	O	O
since	O	O
I	O	O
need	O	O
a	O	O
resulting	O	O
dataframe	O	O
for	O	O
each	O	O
key	O	O
(	O	O
i.e.	O	B-API
for	O	O
every	O	O
row	O	O
)	O	O
in	O	O
A	O	O
.	O	O

You	O	O
then	O	O
want	O	O
to	O	O
apply	O	B-API
some	O	O
function	O	B-API
to	O	O
each	O	O
group	O	B-API
of	O	O
rows	O	O
in	O	O
`	O	O
b	O	O
`	O	O
where	O	B-API
the	O	O
`	O	O
b	O	O
[	O	O
"	O	O
key	O	O
"]`	O	O
is	O	O
one	O	O
of	O	O
the	O	O
values	O	B-API
in	O	O
`	O	O
keys	O	B-API
`	O	O
.	O	O

Under	O	O
the	O	O
covers	O	O
,	O	O
these	O	O
are	O	O
really	O	O
similar	O	O
uses	O	O
of	O	O
`	O	O
apply	B-API	B-API
`	O	O
.	O	O

`	O	O
loop_iter	O	O
=	O	O
len	B-API	B-API
(	O	O
A	O	O
)	O	O
/	O	O
max	B-API	B-API
(	O	O
A	O	O
[	O	O
'	O	O
SEQ_NUM	O	O
'])	O	O

Easy	O	O
way	O	O
to	O	O
apply	O	B-API
transformation	O	O
from	O	O
`	O	O
pandas.get_dummies	B-API	B-API
`	O	O
to	O	O
new	O	O
data	O	B-API
?	O	O

As	O	O
an	O	O
aside	O	O
that	O	O
may	O	O
help	O	O
you	O	O
in	O	O
the	O	O
meantime	O	O
,	O	O
with	O	O
datetime-indexed	O	O
data	O	B-API
,	O	O
[	O	O
resample	B-API	B-API
]	O	O
(	O	O
#URL	O	O
)	O	O
is	O	O
usually	O	O
a	O	O
better	O	O
choice	O	B-API
than	O	O
reindex	B-API	B-API
.	O	O

Call	O	O
`	O	O
transform	B-API	B-API
`	O	O
on	O	O
the	O	O
'	O	O
measurement	O	O
'	O	O
column	O	O
and	O	O
pass	O	O
the	O	O
method	O	O
`	O	O
diff	B-API	B-API
`	O	O
,	O	O
transform	B-API	B-API
returns	O	O
a	O	O
series	O	O
with	O	O
an	O	O
index	O	B-API
aligned	O	O
to	O	O
the	O	O
original	O	O
df	O	O
:	O	O
#CODE	O	O

If	O	O
you	O	O
are	O	O
intending	O	O
to	O	O
apply	O	B-API
some	O	O
sorting	O	O
on	O	O
the	O	O
result	O	O
of	O	O
`	O	O
transform	B-API	B-API
`	O	O
then	O	O
sort	O	B-API
the	O	O
df	O	O
first	O	B-API
:	O	O
#CODE	O	O

Or	O	O
you	O	O
can	O	O
slice	O	B-API
the	O	O
columns	O	O
and	O	O
pass	O	O
this	O	O
to	O	O
`	O	O
drop	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

These	O	O
values	O	B-API
are	O	O
median	O	B-API
values	O	B-API
I	O	O
calculated	O	O
from	O	O
elsewhere	O	O
,	O	O
and	O	O
I	O	O
have	O	O
also	O	O
their	O	O
variance	O	O
and	O	O
standard	O	O
deviation	O	O
(	O	O
and	O	O
standard	O	O
error	O	O
,	O	O
too	O	O
)	O	O
.	O	O

=	O	O
Hash	O	O
[	O	O
0	O	O
]	O	O
was	O	O
my	O	O
point	O	O
,	O	O
but	O	O
even	O	O
without	O	O
arithmetic	O	O
,	O	O
there	O	O
will	O	O
be	O	O
a	O	O
huge	O	O
range	O	O
values	O	B-API
for	O	O
the	O	O
keys	O	B-API
that	O	O
will	O	O
give	O	O
potentially	O	O
unfortunate	O	O
results	O	O
.	O	O

if	O	O
precision	O	O
is	O	O
to	O	O
decimal	O	O
place	O	B-API
,	O	O
I'd	O	O
multiply	O	B-API
it	O	O
by	O	O
10	O	O
and	O	O
truncate	O	B-API
maybe	O	O
.	O	O

the	O	O
documentation	O	O
to	O	O
concat	B-API	B-API
is	O	O
impenetrable	O	O
and	O	O
its	O	O
hard	O	O
to	O	O
find	O	B-API
examples	O	O
of	O	O
this	O	O
relatively	O	O
simple	O	O
task	O	O
in	O	O
the	O	O
docs	O	O

If	O	O
you	O	O
had	O	O
not	O	O
called	O	O
`	O	O
apply	B-API	B-API
`	O	O
on	O	O
the	O	O
`	O	O
groupby	B-API	O
`	O	O
object	O	O
then	O	O
you	O	O
could	O	O
access	O	O
the	O	O
`	O	O
groups	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

pandas	O	O
groupby	B-API	O
X	O	O
,	O	O
Y	O	O
and	O	O
select	O	B-API
last	O	B-API
week	O	B-API
of	O	O
X1	O	O
and	O	O
X2	O	O
(	O	O
which	O	O
have	O	O
diff	O	B-API
frequency	O	O
)	O	O

Then	O	O
you	O	O
can	O	O
select	O	B-API
the	O	O
rows	O	O
you	O	O
want	O	O
in	O	O
an	O	O
apply	B-API	B-API
call	O	O
on	O	O
the	O	O
grouped	O	O
object	O	O
:	O	O
#CODE	O	O

If	O	O
you	O	O
can't	O	O
upgrade	O	O
or	O	O
don't	O	O
solve	O	B-API
the	O	O
issue	O	O
you	O	O
have	O	O
with	O	O
0.14	O	O
,	O	O
you	O	O
can	O	O
try	O	O
to	O	O
use	O	B-API
`	O	O
ix	B-API	B-API
`	O	O
instead	O	O
of	O	O
`	O	O
iloc	B-API	O
`	O	O

How	O	O
do	O	O
I	O	O
export	O	B-API
multiple	O	O
pivot	O	B-API
tables	O	O
from	O	O
python	O	O
using	O	O
pandas	O	O
to	O	O
a	O	O
single	O	O
csv	O	O
document	O	O
?	O	O

Say	O	O
I	O	O
have	O	O
a	O	O
function	O	B-API
pivots()	O	O
which	O	O
aggregates	O	O
pivot	O	B-API
tables	O	O
#CODE	O	O

I	O	O
know	O	O
how	O	O
to	O	O
export	O	B-API
a	O	O
single	O	O
pivot	O	B-API
table	O	B-API
#CODE	O	O

You	O	O
can	O	O
use	O	B-API
`	O	O
to_csv	B-API	O
(	O	O
path	O	B-API
,	O	O
mode=	O	O
'	O	O
a	O	O
')`	O	O
to	O	O
append	O	B-API
files	O	O
.	O	O

Use	O	O
`	O	O
shift	B-API	B-API
`	O	O
and	O	O
`	O	O
np.log	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

I'd	O	O
look	O	O
at	O	B-API
seeing	O	O
if	O	O
you	O	O
can	O	O
export	O	B-API
it	O	O
in	O	O
it's	O	O
raw	O	O
form	O	O
,	O	O
otherwise	O	O
this	O	O
must	O	O
be	O	O
a	O	O
common	O	O
problem	O	O
and	O	O
someone	O	O
somewhere	O	O
has	O	O
probably	O	O
coded	O	O
a	O	O
method	O	O
to	O	O
strip	O	B-API
the	O	O
emojis	O	O
out	O	O
of	O	O
the	O	O
text	O	B-API

Python	O	O
pandas	O	O
map	O	B-API
dict	O	O
keys	O	B-API
to	O	O
values	O	B-API

I	O	O
have	O	O
a	O	O
csv	O	O
for	O	O
input	O	O
,	O	O
whose	O	O
row	O	O
values	O	B-API
I'd	O	O
like	O	O
to	O	O
join	O	B-API
into	O	O
a	O	O
new	O	O
field	O	B-API
.	O	O

This	O	O
new	O	O
field	O	B-API
is	O	O
a	O	O
constructed	O	O
url	O	O
,	O	O
which	O	O
will	O	O
then	O	O
be	O	O
processed	O	O
by	O	O
the	O	O
requests.post()	B-API	B-API
method	O	O
.	O	O

I	O	O
tried	O	O
to	O	O
map	O	B-API
values	O	B-API
to	O	O
keys	O	B-API
with	O	O
a	O	O
dict	O	O
comprehension	O	O
,	O	O
but	O	O
the	O	O
assignment	O	O
of	O	O
a	O	O
key	O	O
like	O	O
'	O	O
FIRST_NAME	O	O
'	O	O
could	O	O
end	O	O
up	O	O
mapping	O	O
to	O	O
values	O	B-API
from	O	O
an	O	O
arbitrary	O	O
field	O	B-API
like	O	O
test_df	O	O
[	O	O
'	O	O
CITY	O	O
']	O	O
.	O	O

which	O	O
will	O	O
give	O	O
you	O	O
output	O	O
as	O	O
follows	O	O
:	O	O
`	O	O
[	O	O
{	O	O
'	O	O
FIRST_NAME	O	O
'	O	O
:	O	O
...,	O	O
'	O	O
LAST_NAME	O	O
'	O	O
:	O	O
...	O	O
}	O	O
,	O	O
{	O	O
'	O	O
FIRST_NAME	O	O
'	O	O
:	O	O
...,	O	O
'	O	O
LAST_NAME	O	O
'	O	O
:	O	O
...	O	O
}	O	O
]`	O	O
(	O	O
which	O	O
will	O	O
give	O	O
you	O	O
a	O	O
list	O	B-API
that	O	O
has	O	O
equal	O	B-API
length	O	O
as	O	O
`	O	O
test_df	O	O
`)	O	O
.	O	O

This	O	O
might	O	O
be	O	O
one	O	O
possibility	O	O
to	O	O
easily	O	O
map	O	B-API
it	O	O
to	O	O
a	O	O
correct	O	O
row	O	O
.	O	O

Do	O	O
you	O	O
know	O	O
if	O	O
append	B-API	B-API
returns	O	O
a	O	O
copy	O	B-API
/	O	O
view	O	B-API
/	O	O
reference	O	O
of	O	O
the	O	O
original	O	O
dataframe	O	O
?	O	O

Right	O	O
now	O	O
,	O	O
I	O	O
am	O	O
trying	O	O
to	O	O
replace	O	B-API
a	O	O
stored	O	O
procedure	O	O
with	O	O
a	O	O
Python	O	O
service	O	O
,	O	O
and	O	O
the	O	O
temp	O	O
tables	O	O
with	O	O
Pandas	O	O
dataframes	O	O
.	O	O

You	O	O
could	O	O
pass	O	O
an	O	O
argument	O	O
to	O	O
`	O	O
apply	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

Originally	O	O
,	O	O
I	O	O
used	O	O
append	B-API	B-API
api	O	O
to	O	O
create	O	O
a	O	O
single	O	O
table	O	B-API
'	O	O
impression	O	O
'	O	O
,	O	O
however	O	O
that	O	O
was	O	O
taking	O	O
80sec	O	O
per	O	O
dataframe	O	O
and	O	O
given	O	O
that	O	O
I	O	O
have	O	O
almost	O	O
200	O	O
of	O	O
files	O	O
to	O	O
be	O	O
processed	O	O
,	O	O
the	O	O
'	O	O
append	B-API	B-API
'	O	O
appeared	O	O
to	O	O
be	O	O
too	O	O
slow	O	B-API
.	O	O

Also	O	O
,	O	O
why	O	O
is	O	O
append	B-API	B-API
so	O	O
much	O	O
slower	O	O
than	O	O
put	O	B-API
?	O	O

pandas	O	O
merge	B-API	B-API
with	O	O
MultiIndex	B-API	B-API
,	O	O
when	O	O
only	O	O
one	O	O
level	O	O
of	O	O
index	O	B-API
is	O	O
to	O	O
be	O	O
used	O	O
as	O	O
key	O	O

I	O	O
want	O	O
to	O	O
recover	O	O
the	O	O
values	O	B-API
in	O	O
the	O	O
column	O	O
'	O	O
_Cat	O	O
'	O	O
from	O	O
df2	O	O
and	O	O
merge	O	B-API
them	O	O
into	O	O
df1	O	O
for	O	O
the	O	O
appropriate	O	O
values	O	B-API
of	O	O
'	O	O
_ItemId	O	O
'	O	O
.	O	O

This	O	O
is	O	O
almost	O	O
(	O	O
I	O	O
think	O	O
?	O	O
)	O	O
a	O	O
standard	O	O
many-to-one	O	O
merge	O	B-API
,	O	O
except	O	O
that	O	O
the	O	O
appropriate	O	O
key	O	O
for	O	O
the	O	O
left	O	O
df	O	O
is	O	O
one	O	O
of	O	O
MultiIndex	B-API	B-API
levels	O	O
.	O	O

Or	O	O
is	O	O
there	O	O
a	O	O
better	O	O
approach	O	O
to	O	O
this	O	O
merge	B-API	B-API
?	O	O

loc	B-API	B-API
will	O	O
not	O	O
attempt	O	O
to	O	O
use	O	B-API
a	O	O
number	O	O
(	O	O
eg	O	O
1	O	O
)	O	O
as	O	O
a	O	O
positional	O	O
argument	O	O
at	O	B-API
all	O	B-API
(	O	O
and	O	O
will	O	O
raise	O	O
instead	O	O
);	O	O
see	O	O
main	O	B-API
pandas	O	O
docs	O	O
/	O	O
selecting	O	O
data	O	B-API

I	O	O
have	O	O
the	O	O
following	O	O
boxplot	O	B-API
:	O	O
#CODE	O	O

My	O	O
question	O	O
is	O	O
:	O	O
how	O	O
can	O	O
I	O	O
change	O	O
the	O	O
whiskers	O	O
/	O	O
quantiles	O	O
being	O	O
plotted	O	O
in	O	O
the	O	O
boxplot	O	B-API
?	O	O

it'll	O	O
be	O	O
difficult	O	O
to	O	O
translate	O	B-API
those	O	O
`	O	O
ddply	O	O
`	O	O
calls	O	O
to	O	O
pandas	O	O
.	O	O

I	O	O
guess	O	O
`	O	O
groupby	B-API	O
`	O	O
should	O	O
be	O	O
used	O	O
but	O	O
I	O	O
find	O	B-API
this	O	O
format	O	B-API
very	O	O
cryptic	O	O
so	O	O
it's	O	O
hard	O	O
to	O	O
translate	O	B-API
to	O	O
python	O	O

If	O	O
you	O	O
drop	O	B-API
the	O	O
"	O	O
%	O	O
"	O	O
sign	O	B-API
,	O	O
you	O	O
can	O	O
make	O	O
the	O	O
plot	O	B-API
without	O	O
ticks	O	O
.	O	O

Append	O	O
Two	O	O
Dataframes	O	O
Together	O	O
(	O	O
Pandas	O	O
,	O	O
Python3	O	O
)	O	O

I	O	O
am	O	O
trying	O	O
to	O	O
append	O	B-API
/	O	O
join	O	B-API
(	O	O
?	O	O
)	O	O
two	O	O
different	O	O
dataframes	O	O
together	O	O
that	O	O
don't	O	O
share	O	O
any	O	B-API
overlapping	O	O
data	O	B-API
.	O	O

I	O	O
am	O	O
trying	O	O
to	O	O
append	O	B-API
these	O	O
together	O	O
using	O	O
#CODE	O	O

EDIT	O	O
:	O	O
in	O	O
regards	O	O
to	O	O
Edchum's	O	O
answers	O	O
,	O	O
I	O	O
have	O	O
tried	O	O
merge	B-API	B-API
and	O	O
join	B-API	B-API
but	O	O
each	O	O
create	O	O
somewhat	O	O
strange	O	O
tables	O	O
.	O	O

OK	O	O
,	O	O
what	O	O
you	O	O
have	O	O
to	O	O
do	O	O
is	O	O
reindex	B-API	B-API
or	O	O
reset	B-API	B-API
the	O	O
index	O	B-API
so	O	O
they	O	O
align	O	B-API

Use	O	O
`	O	O
concat	B-API	B-API
`	O	O
and	O	O
pass	O	O
param	O	O
`	O	O
axis=1	O	O
`	O	O
:	O	O
#CODE	O	O

`	O	O
join	B-API	B-API
`	O	O
also	O	O
works	O	O
:	O	O
#CODE	O	O

As	O	O
does	O	O
`	O	O
merge	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

In	O	O
the	O	O
case	O	O
where	O	B-API
the	O	O
indices	O	B-API
do	O	O
not	O	O
align	O	B-API
where	O	B-API
for	O	O
example	O	O
your	O	O
first	O	B-API
df	O	O
has	O	O
index	O	B-API
`	O	O
[	O	O
0	O	O
,	O	O
1	O	O
,	O	O
2	O	O
,	O	O
3	O	O
]`	O	O
and	O	O
your	O	O
second	O	B-API
df	O	O
has	O	O
index	O	B-API
`	O	O
[	O	O
0	O	O
,	O	O
2	O	O
]`	O	O
this	O	O
will	O	O
mean	O	B-API
that	O	O
the	O	O
above	O	O
operations	O	O
will	O	O
naturally	O	O
align	O	B-API
against	O	O
the	O	O
first	O	B-API
df's	O	O
index	O	B-API
resulting	O	O
in	O	O
a	O	O
`	O	O
NaN	O	O
`	O	O
row	O	O
for	O	O
index	O	B-API
row	O	O
`	O	O
1	O	O
`	O	O
.	O	O

To	O	O
fix	O	B-API
this	O	O
you	O	O
can	O	O
reindex	O	B-API
the	O	O
second	O	B-API
df	O	O
either	O	O
by	O	O
calling	O	O
`	O	O
reset_index()	B-API	O
`	O	O
or	O	O
assign	O	B-API
directly	O	O
like	O	O
so	O	O
:	O	O
`	O	O
df2.index	O	O
=[	O	O
0	O	O
,	O	O
1	O	O
]`	O	O
.	O	O

And	O	O
you	O	O
could	O	O
always	O	O
drop	O	B-API
back	O	B-API
to	O	O
numpy	O	O
operations	O	O
on	O	O
the	O	O
numpy	O	O
array	O	B-API
`	O	O
pan.values	O	B-API
`	O	O
if	O	O
need	O	O
be	O	O
,	O	O
though	O	O
,	O	O
hopefully	O	O
,	O	O
that	O	O
would	O	O
be	O	O
unnecessary	O	O
.	O	O

This	O	O
argument	O	O
is	O	O
new	O	O
in	O	O
1.9	O	O
...	O	O
but	O	O
there	O	O
is	O	O
a	O	O
workaround	O	O
,	O	O
try	O	O
`	O	O
np.linspace	B-API	B-API
(	O	O
0	O	O
,	O	O
len	B-API	B-API
(	O	O
pep_list	O	O
)	O	O
,	O	O
n+1	O	O
,	O	O
endpoint=True	O	O
)	O	O
.astype	B-API	B-API
(	O	O
int	O	O
)`	O	O

Take	O	O
the	O	O
time	O	B-API
difference	O	B-API
(	O	O
using	O	O
`	O	O
shift	B-API	B-API
`	O	O
)	O	O
til	O	O
the	O	O
next	O	B-API
value	O	O
,	O	O
and	O	O
multiply	O	B-API
(	O	O
value	O	O
*	O	O
seconds	O	B-API
):	O	O
#CODE	O	O

Then	O	O
do	O	O
the	O	O
resample	O	B-API
to	O	O
seconds	O	B-API
(	O	O
sum	O	B-API
the	O	O
value*seconds	O	O
):	O	O
#CODE	O	O

you	O	O
can	O	O
isnull	B-API	B-API
(	O	O
df	O	O
[	O	O
'	O	O
difference	O	B-API
'])	O	O
will	O	O
give	O	O
True	O	O
on	O	O
NaT	O	O
,	O	O
so	O	O
you	O	O
could	O	O
subtract	O	B-API
then	O	O
use	O	B-API
mask	B-API	B-API
I	O	O
think	O	O

After	O	O
they	O	O
are	O	O
done	O	O
,	O	O
merge	O	B-API
the	O	O
two	O	O
frames	O	O
together	O	O
:	O	O
#CODE	O	O

Another	O	O
solution	O	O
(	O	O
slightly	O	O
harder	O	O
):	O	O
Merge	O	O
the	O	O
columns	O	O
`	O	O
transcript_id	O	O
`	O	O
,	O	O
`	O	O
gene_id	O	O
`	O	O
and	O	O
`	O	O
gene_name	O	O
`	O	O
in	O	O
another	O	O
column	O	O
,	O	O
say	O	O
`	O	O
merged_id	O	O
`	O	O
and	O	O
`	O	O
groupby	B-API	O
`	O	O
on	O	O
`	O	O
merged_id	O	O
`	O	O
.	O	O

Geo	O	O
Pandas	O	O
Data	O	O
Frame	O	O
/	O	O
Matrix	O	O
-	O	O
filter	O	B-API
/	O	O
drop	O	B-API
NaN	O	O
/	O	O
False	O	O
values	O	B-API

Then	O	O
I	O	O
stack	O	B-API
the	O	O
dataframe	O	O
,	O	O
give	O	O
the	O	O
index	O	B-API
levels	O	O
the	O	O
desired	O	O
names	O	B-API
,	O	O
and	O	O
select	O	B-API
only	O	O
the	O	O
rows	O	O
where	O	B-API
we	O	O
have	O	O
'	O	O
True	O	O
'	O	O
values	O	B-API
:	O	O
#CODE	O	O

Can	O	O
you	O	O
enable	O	O
the	O	O
debugger	O	O
to	O	O
get	O	B-API
a	O	O
stack	O	B-API
trace	O	B-API
?	O	O

reshape	O	B-API
data	O	B-API
frame	O	O
in	O	O
pandas	O	O
with	O	O
pivot	O	B-API
table	O	B-API

With	O	O
pivot	O	B-API
table	O	B-API
you	O	O
can	O	O
get	O	B-API
a	O	O
matrix	O	B-API
showing	O	O
which	O	O
`	O	O
baz	O	O
`	O	O
corresponds	O	O
to	O	O
which	O	O
`	O	O
qux	O	O
`	O	O
:	O	O
#CODE	O	O

Rolling	O	B-API
apply	O	B-API
question	O	O

For	O	O
each	O	O
group	O	B-API
in	O	O
the	O	O
groupby	B-API	O
object	O	O
,	O	O
we	O	O
will	O	O
want	O	O
to	O	O
apply	O	B-API
a	O	O
function	O	B-API
:	O	O
#CODE	O	O

We	O	O
want	O	O
to	O	O
take	O	B-API
the	O	O
Times	O	O
column	O	O
,	O	O
and	O	O
for	O	O
each	O	O
time	O	B-API
,	O	O
apply	O	B-API
a	O	O
function	O	B-API
.	O	O

That's	O	O
done	O	O
with	O	O
`	O	O
applymap	B-API	O
`	O	O
:	O	O
#CODE	O	O

Given	O	O
a	O	O
time	O	B-API
`	O	O
t	O	O
`	O	O
,	O	O
we	O	O
can	O	O
select	O	B-API
the	O	O
`	O	O
Value	O	O
`	O	O
s	O	O
from	O	O
`	O	O
subf	O	O
`	O	O
whose	O	O
times	O	O
are	O	O
in	O	O
the	O	O
half-open	O	O
interval	O	O
`	O	O
(	O	O
t-60	O	O
,	O	O
t	O	O
]`	O	O
using	O	O
the	O	O
`	O	O
ix	B-API	B-API
`	O	O
method	O	O
:	O	O
#CODE	O	O

pandas	O	O
join	O	B-API
data	O	B-API
frames	O	O
on	O	O
similar	O	O
but	O	O
not	O	O
identical	O	B-API
string	O	O
using	O	O
lower	O	B-API
case	O	O
only	O	O

I	O	O
need	O	O
to	O	O
join	O	B-API
data	O	B-API
frames	O	O
on	O	O
columns	O	O
that	O	O
are	O	O
similar	O	O
but	O	O
not	O	O
identical	O	B-API
.	O	O

So	O	O
I	O	O
am	O	O
trying	O	O
to	O	O
isolate	O	O
the	O	O
lowercase	O	O
letters	O	O
from	O	O
each	O	O
column	O	O
,	O	O
create	O	O
new	O	O
columns	O	O
to	O	O
join	O	B-API
on	O	O
.	O	O

Note	O	O
that	O	O
this	O	O
assumes	O	O
collecting	O	O
all	O	B-API
ASCII	O	O
characters	O	O
from	O	O
`	O	O
a	O	O
`	O	O
to	O	O
`	O	O
z	O	O
`	O	O
suffices	O	O
to	O	O
produce	O	O
values	O	B-API
on	O	O
which	O	O
to	O	O
join	O	B-API
.	O	O

You	O	O
can	O	O
of	O	O
course	O	O
extend	O	O
this	O	O
with	O	O
several	O	O
joins	O	O
,	O	O
the	O	O
join	O	B-API
solution	O	O
detects	O	O
common	O	O
indices	O	B-API
automatically	O	O
.	O	O

My	O	O
data	O	B-API
is	O	O
in	O	O
a	O	O
DataFrame	O	B-API
of	O	O
about	O	O
10378	O	O
rows	O	O
and	O	O
`	O	O
len	B-API	B-API
(	O	O
df	O	O
[	O	O
'	O	O
Full	O	O
name	O	B-API
'])`	O	O
is	O	O
10378	O	O
,	O	O
as	O	O
expected	O	O
.	O	O

But	O	O
`	O	O
len	B-API	B-API
(	O	O
choices	O	O
)`	O	O
is	O	O
only	O	O
1695	O	O
.	O	O

I'm	O	O
fairly	O	O
certain	O	O
that	O	O
the	O	O
issue	O	O
is	O	O
in	O	O
the	O	O
first	O	B-API
line	O	O
,	O	O
with	O	O
the	O	O
`	O	O
to_dict()	B-API	O
`	O	O
function	O	B-API
,	O	O
as	O	O
`	O	O
len	B-API	B-API
(	O	O
df	O	O
[	O	O
'	O	O
Full	O	O
name	O	B-API
']	O	O
.astype	B-API	B-API
(	O	O
str	O	B-API
)`	O	O
results	O	O
in	O	O
10378	O	O
and	O	O
`	O	O
len	B-API	B-API
(	O	O
df	O	O
[	O	O
'	O	O
Full	O	O
name	O	B-API
']	O	O
.to_dict()	B-API	B-API
)`	O	O
results	O	O
in	O	O
1695	O	O
.	O	O

what	O	O
is	O	O
`	O	O
len	B-API	B-API
(	O	O
df.index.unique()	O	B-API
)`	O	O
?	O	O

@USER	O	O
using	O	O
`	O	O
choices	O	O
=	O	O
dict	O	O
(	O	O
zip	O	O
(	O	O
df	O	O
[	O	O
'	O	O
n	O	O
']	O	O
,	O	O
df	O	O
[	O	O
'	O	O
Full	O	O
name	O	B-API
']	O	O
.astype	B-API	B-API
(	O	O
str	O	B-API
)))`	O	O
,	O	O
where	O	B-API
df	O	O
[	O	O
'	O	O
n	O	O
']	O	O
is	O	O
np.arange	B-API	B-API
(	O	O
len	B-API	B-API
(	O	O
df	O	O
))	O	O
,	O	O
worked	O	O
fine	O	O
and	O	O
got	O	O
what	O	O
I	O	O
needed	O	O
.	O	O

Had	O	O
some	O	O
indexing	O	O
issues	O	O
because	O	O
I	O	O
was	O	O
importing	O	O
the	O	O
data	O	B-API
from	O	O
different	O	O
Excel	O	O
spreadsheets	O	O
.	O	O

This	O	O
is	O	O
what	O	O
is	O	O
happening	O	O
in	O	O
your	O	O
case	O	O
,	O	O
and	O	O
noted	O	O
from	O	O
the	O	O
comments	O	O
,	O	O
since	O	O
the	O	O
amount	O	O
of	O	O
`	O	O
unique	O	B-API
`	O	O
values	O	B-API
for	O	O
the	O	O
index	O	B-API
are	O	O
only	O	O
`	O	O
1695	O	O
`	O	O
,	O	O
we	O	O
can	O	O
confirm	O	O
this	O	O
by	O	O
testing	O	O
the	O	O
value	O	O
of	O	O
`	O	O
len	B-API	B-API
(	O	O
df.index.unique()	O	B-API
)`	O	O
.	O	O

what	O	O
do	O	O
you	O	O
mean	O	B-API
by	O	O
normalize	O	B-API
?	O	O

The	O	O
other	O	O
way	O	O
is	O	O
much	O	O
easier	O	O
and	O	O
involves	O	O
using	O	O
`	O	O
resample	B-API	B-API
`	O	O
to	O	O
convert	O	B-API
to	O	O
daily	O	O
observations	O	O
and	O	O
backfill	O	B-API
daily	O	O
consumption	O	O
.	O	O

(	O	O
Note	O	O
that	O	O
the	O	O
first	O	B-API
and	O	O
last	O	B-API
months	O	O
are	O	O
based	O	O
on	O	O
partial	O	O
data	O	B-API
,	O	O
you	O	O
may	O	O
want	O	O
to	O	O
either	O	O
drop	O	B-API
them	O	O
or	O	O
pro-rate	O	O
the	O	O
daily	O	O
consumption	O	O
.	O	O
)	O	O
#CODE	O	O

Basically	O	O
,	O	O
after	O	O
calculating	O	O
the	O	O
daily	O	O
consumption	O	O
,	O	O
do	O	O
a	O	O
partial	O	O
resample	B-API	B-API
by	O	O
adding	O	O
the	O	O
first	O	B-API
and	O	O
last	O	B-API
day	O	B-API
of	O	O
each	O	O
month	O	B-API
.	O	O

I	O	O
will	O	O
implement	O	O
it	O	O
and	O	O
see	O	O
how	O	O
it	O	O
goes	O	O
,	O	O
but	O	O
can	O	O
you	O	O
also	O	O
explain	O	O
what	O	O
'	O	O
1d	O	O
'	O	O
means	O	O
in	O	O
the	O	O
resample	B-API	B-API
method	O	O
?	O	O

@USER	O	O
'	O	O
1d	O	O
'	O	O
just	O	O
means	O	O
1	O	O
day	O	B-API
for	O	O
the	O	O
frequency	O	O
of	O	O
the	O	O
resample	B-API	B-API
.	O	O

So	O	O
I	O	O
want	O	O
something	O	O
that	O	O
will	O	O
drop	O	B-API
the	O	O
`	O	O
lob	O	O
`	O	O
group	O	B-API
,	O	O
but	O	O
keep	O	O
every	O	O
record	O	B-API
of	O	O
both	O	O
the	O	O
`	O	O
mol	O	O
`	O	O
and	O	O
`	O	O
thg	O	O
`	O	O
group	O	B-API
.	O	O

Pandas	O	O
Merge	O	O
2	O	O
data	O	B-API
frames	O	O
by	O	O
2	O	O
columns	O	O
each	O	O

In	O	O
each	O	O
data	O	B-API
frame	O	O
i	O	O
have	O	O
column	O	O
with	O	O
the	O	O
same	O	O
name	O	B-API
and	O	O
values	O	B-API
(	O	O
Key_Merge1	O	O
)	O	O
and	O	O
in	O	O
each	O	O
data	O	B-API
frame	O	O
i	O	O
have	O	O
2	O	O
different	O	O
column	O	O
names	O	B-API
with	O	O
same	O	O
values	O	B-API
(	O	O
Key_Merge2	O	O
)	O	O
.	O	O

How	O	O
can	O	O
i	O	O
merge	O	B-API
2	O	O
data	O	B-API
frames	O	O
by	O	O
2	O	O
columns	O	O
:	O	O

Can	O	O
you	O	O
post	O	O
an	O	O
example	O	O
data	O	B-API
and	O	O
df	O	O
,	O	O
your	O	O
text	O	B-API
description	O	O
is	O	O
not	O	O
clear	O	B-API
enough	O	O
but	O	O
generally	O	O
you	O	O
want	O	O
to	O	O
merge	O	B-API
and	O	O
pass	O	O
the	O	O
list	O	B-API
of	O	O
cols	O	O
to	O	O
merge	O	B-API
the	O	O
;	O	O
hs	O	O
and	O	O
rhs	O	O
on	O	O
:	O	O
`	O	O
pd.merge	B-API	B-API
(	O	O
df1	O	O
,	O	O
df2	O	O
,	O	O
left_on	O	O
=[	O	O
'	O	O
Key_Merge1	O	O
'	O	O
,	O	O
'	O	O
Key_Merge21	O	O
']	O	O
,	O	O
right_on	O	O
=[	O	O
'	O	O
Key_Merge1	O	O
'	O	O
,	O	O
'	O	O
Key_merge22	O	O
'])`	O	O

OK	O	O
,	O	O
you	O	O
have	O	O
to	O	O
rename	O	B-API
'	O	O
PRODUCT_GROUP	O	O
'	O	O
in	O	O
DF2	O	O
in	O	O
order	O	B-API
for	O	O
the	O	O
`	O	O
merge	B-API	B-API
`	O	O
to	O	O
work	O	O
:	O	O
#CODE	O	O

the	O	O
merge	B-API	B-API
will	O	O
naturally	O	O
find	O	B-API
the	O	O
2	O	O
columns	O	O
that	O	O
match	O	B-API
and	O	O
perform	O	O
an	O	O
inner	O	B-API
merge	B-API	B-API
as	O	O
desired	O	O

I	O	O
can	O	O
strip	O	B-API
out	O	O
the	O	O
rightmost	O	O
'	O	O
.csv	O	B-API
'	O	O
part	O	O
like	O	O
this	O	O
:	O	O
#CODE	O	O

How	O	O
to	O	O
merge	O	B-API
two	O	O
DataFrame	O	B-API
columns	O	O
and	O	O
apply	O	B-API
pandas.to_datetime	B-API	B-API
to	O	O
it	O	O
?	O	O

What	O	O
would	O	O
be	O	O
a	O	O
more	O	O
pythonic	O	O
way	O	O
to	O	O
merge	O	B-API
two	O	O
columns	O	O
,	O	O
and	O	O
apply	O	B-API
a	O	O
function	O	B-API
into	O	O
the	O	O
result	O	O
?	O	O

once	O	O
sorted	O	O
I	O	O
replace	O	B-API
the	O	O
df.index	O	B-API
with	O	O
a	O	O
numerical	O	O
index	O	B-API
#CODE	O	O

This	O	O
can	O	O
be	O	O
accomplished	O	O
with	O	O
a	O	O
one	O	O
line	O	O
solution	O	O
using	O	O
Pandas	O	O
'	O	O
boolean	O	O
indexing	O	O
.	O	O

The	O	O
one-liner	O	O
also	O	O
employs	O	O
some	O	O
other	O	O
tricks	O	O
:	O	O
Pandas	O	O
'	O	O
`	O	O
map	B-API	B-API
`	O	O
and	O	O
`	O	O
diff	B-API	B-API
`	O	O
methods	O	O
and	O	O
a	O	O
`	O	O
lambda	O	O
`	O	O
function	O	B-API
.	O	O

`	O	O
map	B-API	B-API
`	O	O
is	O	O
used	O	O
to	O	O
apply	B-API	B-API
the	O	O
`	O	O
lambda	O	O
`	O	O
function	O	B-API
to	O	O
all	O	B-API
rows	O	O
.	O	O

The	O	O
`	O	O
lambda	O	O
`	O	O
function	O	B-API
is	O	O
needed	O	O
to	O	O
create	O	O
a	O	O
custom	O	O
less-then	O	O
comparison	O	O
that	O	O
will	O	O
evaluate	O	B-API
NaN	O	O
values	O	B-API
to	O	O
True	O	O
.	O	O

There	O	O
is	O	O
a	O	O
built	O	O
in	O	O
method	O	O
for	O	O
this	O	O
`	O	O
diff	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

as	O	O
pointed	O	O
out	O	O
calling	O	O
`	O	O
diff	B-API	B-API
`	O	O
here	O	O
will	O	O
lose	O	O
the	O	O
first	O	B-API
row	O	O
so	O	O
I'm	O	O
using	O	O
a	O	O
ugly	O	O
hack	O	O
where	O	B-API
I	O	O
concatenate	O	B-API
the	O	O
first	O	B-API
row	O	O
with	O	O
the	O	O
result	O	O
of	O	O
the	O	O
`	O	O
diff	B-API	B-API
`	O	O
so	O	O
I	O	O
don't	O	O
lose	O	O
the	O	O
first	O	B-API
row	O	O

Using	O	O
`	O	O
diff	B-API	B-API
`	O	O
like	O	O
this	O	O
drops	O	O
the	O	O
first	O	B-API
row	O	O
.	O	O

(	O	O
I	O	O
can	O	O
also	O	O
use	O	B-API
the	O	O
chunksize	O	O
option	O	O
and	O	O
concat	O	B-API
myself	O	O
,	O	O
but	O	O
that	O	O
seems	O	O
to	O	O
be	O	O
a	O	O
bit	O	O
of	O	O
a	O	O
hack	O	O
.	O	O
)	O	O

Jeff	O	O
,	O	O
I	O	O
updated	O	O
sec_id	O	O
and	O	O
dt	B-API	B-API
in	O	O
the	O	O
dataframe	O	O
.	O	O

Sorry	O	O
,	O	O
I	O	O
had	O	O
to	O	O
update	O	B-API
"	O	O
sec_id	O	O
"	O	O
and	O	O
"	O	O
dt	O	B-API
"	O	O
to	O	O
"	O	O
id	O	O
"	O	O
and	O	O
"	O	O
date	O	B-API
"	O	O
.	O	O

0.12	O	O
is	O	O
fine	O	O
;	O	O
FYI	O	O
the	O	O
format	O	B-API
keyword	O	O
doesn't	O	O
do	O	O
anything	O	O
with	O	O
append	B-API	B-API
(	O	O
and	O	O
it's	O	O
for	O	O
0.13	O	O
anyhow	O	O
);	O	O
append	B-API	B-API
always	O	O
is	O	O
a	O	O
table	O	B-API

I	O	O
would	O	O
like	O	O
to	O	O
get	O	B-API
every	O	O
,	O	O
let's	O	O
say	O	O
,	O	O
6	O	O
hours	O	B-API
of	O	O
data	O	B-API
and	O	O
independently	O	O
fit	O	O
a	O	O
curve	O	O
to	O	O
that	O	O
data	O	B-API
.	O	O

Since	O	O
pandas	O	O
'	O	O
`	O	O
resample	B-API	B-API
`	O	O
function	O	B-API
has	O	O
a	O	O
`	O	O
how	O	O
`	O	O
keyword	O	O
that	O	O
is	O	O
supposed	O	O
to	O	O
be	O	O
any	O	B-API
numpy	O	O
array	O	B-API
function	O	B-API
,	O	O
I	O	O
thought	O	O
that	O	O
I	O	O
could	O	O
maybe	O	O
try	O	O
to	O	O
use	O	B-API
resample	B-API	B-API
to	O	O
do	O	O
that	O	O
with	O	O
`	O	O
polyfit	B-API	O
`	O	O
,	O	O
but	O	O
apparently	O	O
there	O	O
is	O	O
no	O	O
way	O	O
(	O	O
right	O	O
?	O	O
)	O	O
.	O	O

Why	O	O
does	O	O
the	O	O
second	O	B-API
block	O	O
of	O	O
code	O	O
not	O	O
work	O	O
?	O	O

Doesn't	O	O
DataFrame.apply()	B-API	B-API
default	O	O
to	O	O
inplace	O	O
?	O	O

There	O	O
is	O	O
no	O	O
inplace	O	O
parameter	O	O
to	O	O
the	O	O
apply	B-API	B-API
function	O	B-API
.	O	O

Even	O	O
if	O	O
it	O	O
doesn't	O	O
default	O	O
to	O	O
inplace	O	O
,	O	O
shouldn't	O	O
it	O	O
provide	O	O
an	O	O
inplace	O	O
parameter	O	O
the	O	O
way	O	O
replace()	B-API	O
does	O	O
?	O	O

No	O	O
,	O	O
apply	B-API	B-API
does	O	O
not	O	O
work	O	O
inplace*	O	O
.	O	O

In	O	O
general	O	O
apply	B-API	B-API
is	O	O
slow	O	B-API
(	O	O
since	O	O
you	O	O
are	O	O
basically	O	O
iterating	O	O
through	O	O
each	O	O
row	O	O
in	O	O
python	O	O
)	O	O
,	O	O
and	O	O
the	O	O
"	O	O
game	O	O
"	O	O
is	O	O
to	O	O
rewrite	O	O
that	O	O
function	O	B-API
in	O	O
terms	O	O
of	O	O
pandas	O	O
/	O	O
numpy	O	O
native	O	O
functions	O	O
and	O	O
indexing	O	O
.	O	O

If	O	O
you	O	O
want	O	O
to	O	O
delve	O	O
into	O	O
more	O	O
details	O	O
about	O	O
the	O	O
internals	O	O
,	O	O
check	O	O
out	O	O
the	O	O
BlockManager	O	O
in	O	O
core	O	O
/	O	O
internals.py	O	B-API
,	O	O
this	O	O
is	O	O
the	O	O
object	O	O
which	O	O
holds	O	O
the	O	O
underlying	O	O
numpy	O	O
arrays	O	O
.	O	O

*	O	O
apply	B-API	B-API
is	O	O
not	O	O
usually	O	O
going	O	O
to	O	O
make	O	O
sense	O	O
inplace	O	O
(	O	O
and	O	O
IMO	O	O
this	O	O
behaviour	O	O
would	O	O
rarely	O	O
be	O	O
desired	O	O
)	O	O
.	O	O

I	O	O
use	O	B-API
this	O	O
function	O	B-API
with	O	O
pandas	O	O
to	O	O
apply	O	B-API
it	O	O
to	O	O
each	O	O
month	O	B-API
of	O	O
a	O	O
historical	O	O
record	O	B-API
:	O	O
#CODE	O	O

I	O	O
am	O	O
trying	O	O
to	O	O
merge	O	B-API
tsv	O	O
files	O	O
using	O	O
pandas	O	O
but	O	O
cannot	O	O
get	O	B-API
pandas	O	O
to	O	O
return	O	O
the	O	O
file	O	O
contents	O	O
correctly	O	O
.	O	O

You	O	O
can	O	O
use	O	B-API
the	O	O
vectorised	O	O
`	O	O
str	B-API	B-API
`	O	O
methods	O	O
to	O	O
replace	O	B-API
the	O	O
unwanted	O	O
characters	O	O
and	O	O
then	O	O
cast	O	O
the	O	O
type	O	O
to	O	O
int	O	O
:	O	O
#CODE	O	O

perhaps	O	O
`	O	O
reindex	B-API	B-API
`	O	O
creates	O	O
a	O	O
new	O	O
dataframe	O	O
,	O	O
`	O	O
ix	B-API	B-API
`	O	O
returns	O	O
a	O	O
view	O	B-API

@USER	O	O
you	O	O
are	O	O
,	O	O
of	O	O
course	O	O
,	O	O
absolutely	O	O
right	O	O
.	O	O
what	O	O
do	O	O
`	O	O
loc	B-API	B-API
`	O	O
and	O	O
`	O	O
iloc	B-API	O
`	O	O
do	O	O
?	O	O

The	O	O
reason	O	O
for	O	O
the	O	O
seeming	O	O
redundancy	O	O
is	O	O
that	O	O
,	O	O
while	O	O
using	O	O
`	O	O
ix	B-API	B-API
`	O	O
is	O	O
syntacticly	O	O
limiting	O	O
(	O	O
you	O	O
can	O	O
only	O	O
pass	O	O
a	O	O
single	O	O
argument	O	O
to	O	O
`	O	O
__getitem__	O	O
`)	O	O
,	O	O
`	O	O
reindex	B-API	B-API
`	O	O
is	O	O
a	O	O
method	O	O
,	O	O
which	O	O
supports	O	O
taking	O	O
various	O	O
optional	O	O
parameters	O	O
.	O	O

I	O	O
am	O	O
getting	O	O
different	O	O
results	O	O
when	O	O
using	O	O
`	O	O
reindex	B-API	B-API
`	O	O
with	O	O
`	O	O
inplace=True	O	O
`	O	O
vs	O	O
using	O	O
`	O	O
ix	B-API	B-API
`	O	O
(	O	O
I	O	O
updated	O	O
the	O	O
OP	O	O
)	O	O

What	O	O
if	O	O
you	O	O
have	O	O
many	O	O
conditions	O	O
,	O	O
e.g.	O	B-API
you	O	O
want	O	O
to	O	O
split	O	B-API
up	O	O
the	O	O
scatters	O	O
into	O	O
4	O	O
types	O	O
of	O	O
points	O	O
or	O	O
even	O	O
more	O	O
,	O	O
plotting	O	B-API
each	O	O
in	O	O
different	O	O
shape	O	B-API
/	O	O
color	O	O
.	O	O

How	O	O
can	O	O
you	O	O
elegantly	O	O
apply	O	B-API
condition	O	O
a	O	O
,	O	O
b	O	O
,	O	O
c	O	O
,	O	O
etc	O	O
.	O	O
and	O	O
make	O	O
sure	O	O
you	O	O
then	O	O
plot	O	B-API
"	O	O
the	O	O
rest	O	O
"	O	O
(	O	O
things	O	O
not	O	O
in	O	O
any	O	B-API
of	O	O
these	O	O
conditions	O	O
)	O	O
as	O	O
the	O	O
last	O	B-API
step	O	B-API
?	O	O

To	O	O
find	O	B-API
points	O	O
skipped	O	O
due	O	O
to	O	O
NA	O	O
,	O	O
try	O	O
the	O	O
`	O	O
isnull	B-API	B-API
`	O	O
method	O	O
:	O	O
`	O	O
df	O	O
[	O	O
df.col3.isnull()	O	B-API
]`	O	O

How	O	O
do	O	O
I	O	O
create	O	O
a	O	O
pivot	O	B-API
table	O	B-API
in	O	O
Pandas	O	O
where	O	B-API
one	O	O
column	O	O
is	O	O
the	O	O
mean	O	B-API
of	O	O
some	O	O
values	O	B-API
,	O	O
and	O	O
the	O	O
other	O	O
column	O	O
is	O	O
the	O	O
sum	O	B-API
of	O	O
others	O	O
?	O	O

Basically	O	O
,	O	O
how	O	O
would	O	O
I	O	O
create	O	O
a	O	O
pivot	O	B-API
table	O	B-API
that	O	O
consolidates	O	O
data	O	B-API
,	O	O
where	O	B-API
one	O	O
of	O	O
the	O	O
columns	O	O
of	O	O
data	O	B-API
it	O	O
represents	O	O
is	O	O
calculated	O	O
,	O	O
say	O	O
,	O	O
by	O	O
`	O	O
likelihood	O	O
percentage	O	O
`	O	O
(	O	O
0.0	O	O
-	O	O
1.0	O	O
)	O	O
by	O	O
taking	O	O
the	O	O
mean	O	B-API
,	O	O
and	O	O
another	O	O
is	O	O
calculated	O	O
by	O	O
`	O	O
number	O	O
ordered	O	B-API
`	O	O
which	O	O
sums	O	O
all	O	B-API
of	O	O
them	O	O
?	O	O

I	O	O
think	O	O
that	O	O
I	O	O
understand	O	O
what's	O	O
going	O	O
on	O	O
:	O	O
create	O	O
a	O	O
frequency	O	O
table	O	B-API
of	O	O
ALL	O	O
words	O	O
.	O	O

After	O	O
each	O	O
operation	O	O
,	O	O
drop	O	B-API
all	O	B-API
relevant	O	O
columns	O	O
,	O	O
then	O	O
finally	O	O
count	O	B-API
all	O	B-API
remaining	O	O
columns	O	O
.	O	O

Also	O	O
,	O	O
I	O	O
quickly	O	O
tried	O	O
this	O	O
in	O	O
Python	O	O
3.4.3	O	O
and	O	O
I	O	O
got	O	O
the	O	O
error	O	O
that	O	O
freqDf	O	O
isn't	O	O
defined	O	O
.	O	O

Should	O	O
I	O	O
first	O	B-API
create	O	O
a	O	O
new	O	O
table	O	B-API
named	O	O
freqDf	O	O
?	O	O

`	O	O
df.precedingWord.isin	O	B-API
(	O	O
neuter	O	O
)`	O	O
is	O	O
just	O	O
a	O	O
Series	O	B-API
of	O	O
True	O	O
or	O	O
False	O	O
(	O	O
results	O	O
of	O	O
the	O	O
previous	O	O
test	O	B-API
`	O	O
isin	B-API	O
`)	O	O
,	O	O
and	O	O
pandas	O	O
will	O	O
just	O	O
access	O	O
True	O	O
indexes	O	O
with	O	O
`	O	O
loc	B-API	B-API
`	O	O

I	O	O
have	O	O
tried	O	O
a	O	O
some	O	O
join	B-API	B-API
/	O	O
merge	B-API	B-API
ideas	O	O
but	O	O
can't	O	O
seem	O	O
to	O	O
get	O	B-API
it	O	O
to	O	O
work	O	O
.	O	O

Just	O	O
`	O	O
concat	B-API	B-API
`	O	O
them	O	O
and	O	O
pass	O	O
param	O	O
`	O	O
axis=1	O	O
`	O	O
:	O	O
#CODE	O	O

Or	O	O
`	O	O
merge	B-API	B-API
`	O	O
on	O	O
'	O	O
Symbol	O	O
'	O	O
column	O	O
:	O	O
#CODE	O	O

Pandas	O	O
:	O	O
join	O	B-API
with	O	O
outer	O	B-API
product	O	B-API

How	O	O
to	O	O
join	O	B-API
/	O	O
multiply	O	B-API
the	O	O
DataFrames	O	O
`	O	O
areas	O	O
`	O	O
and	O	O
`	O	O
demand	O	O
`	O	O
together	O	O
in	O	O
a	O	O
decent	O	O
way	O	O
?	O	O

Now	O	O
`	O	O
apply	B-API	B-API
`	O	O
needs	O	O
to	O	O
return	O	O
a	O	O
`	O	O
Series	B-API	B-API
`	O	O
,	O	O
not	O	O
a	O	O
`	O	O
DataFrame	O	B-API
`	O	O
.	O	O

One	O	O
way	O	O
to	O	O
turn	O	O
a	O	O
`	O	O
DataFrame	O	B-API
`	O	O
into	O	O
a	O	O
`	O	O
Series	B-API	B-API
`	O	O
is	O	O
to	O	O
use	O	B-API
`	O	O
stack	B-API	B-API
`	O	O
.	O	O

`	O	O
stack	B-API	B-API
`	O	O
this	O	O
DataFrame	O	B-API
.	O	O

This	O	O
can	O	O
be	O	O
done	O	O
with	O	O
`	O	O
unstack	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

`	O	O
del	O	O
`	O	O
+	O	O
`	O	O
pivot	B-API	B-API
`	O	O
turns	O	O
out	O	O
to	O	O
be	O	O
faster	O	O
than	O	O
`	O	O
pivot_table	B-API	O
`	O	O
in	O	O
this	O	O
case	O	O
.	O	O

Maybe	O	O
the	O	O
reason	O	O
`	O	O
pivot	B-API	B-API
`	O	O
exists	O	B-API
is	O	O
because	O	O
it	O	O
is	O	O
faster	O	O
than	O	O
`	O	O
pivot_table	B-API	O
`	O	O
for	O	O
those	O	O
cases	O	O
where	O	B-API
it	O	O
is	O	O
applicable	O	O
(	O	O
such	O	O
as	O	O
when	O	O
you	O	O
don't	O	O
need	O	O
aggregation	O	O
)	O	O
.	O	O

`	O	O
apply	B-API	B-API
`	O	O
is	O	O
now	O	O
among	O	O
my	O	O
top	O	O
5	O	O
functions	O	O
to	O	O
always	O	O
remember	O	O
.	O	O

Concerning	O	O
the	O	O
`	O	O
pivot_table	B-API	O
`	O	O
solution	O	O
:	O	O
At	O	O
which	O	O
point	O	O
am	O	O
I	O	O
supposed	O	O
to	O	O
enter	O	O
the	O	O
line	O	O
?	O	O

No	O	O
matter	O	O
when	O	O
in	O	O
my	O	O
attempt	O	O
above	O	O
,	O	O
I	O	O
always	O	O
get	O	B-API
`	O	O
no	O	O
item	O	B-API
named	O	O
Edge	O	O
`	O	O
.	O	O

Or	O	O
pass	O	O
`	O	O
axis=0	O	O
`	O	O
to	O	O
`	O	O
loc	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

I've	O	O
got	O	O
2	O	O
pandas	O	O
dataframes	O	O
,	O	O
each	O	O
of	O	O
them	O	O
has	O	O
an	O	O
index	O	B-API
with	O	O
dtype	B-API	O
`	O	O
object	O	O
`	O	O
,	O	O
and	O	O
in	O	O
both	O	O
of	O	O
them	O	O
I	O	O
can	O	O
see	O	O
the	O	O
value	O	O
`	O	O
533	O	O
`	O	O
.	O	O

However	O	O
,	O	O
when	O	O
I	O	O
join	B-API	B-API
them	O	O
the	O	O
result	O	O
is	O	O
empty	O	B-API
,	O	O
as	O	O
one	O	O
of	O	O
them	O	O
is	O	O
the	O	O
number	O	O
`	O	O
533	O	O
`	O	O
and	O	O
the	O	O
other	O	O
is	O	O
a	O	O
string	O	O
`"	O	O
533	O	O
"`	O	O
.	O	O

Ideally	O	O
I	O	O
would	O	O
like	O	O
something	O	O
like	O	O
`	O	O
apply_chunk()	O	O
`	O	O
which	O	O
is	O	O
the	O	O
same	O	O
as	O	O
apply	B-API	B-API
but	O	O
only	O	O
works	O	O
on	O	O
a	O	O
piece	O	O
of	O	O
the	O	O
dataframe	O	O
.	O	O

This	O	O
has	O	O
to	O	O
be	O	O
a	O	O
common	O	O
problem	O	O
though	O	O
,	O	O
is	O	O
there	O	O
a	O	O
design	O	O
pattern	O	O
I	O	O
should	O	O
be	O	O
using	O	O
for	O	O
adding	O	O
columns	O	O
to	O	O
large	O	O
pandas	O	O
dataframes	O	O
?	O	O

whats	O	O
about	O	O
using	O	O
the	O	O
apply	B-API	B-API
method	O	O
?	O	O

Anytime	O	O
you	O	O
find	O	B-API
yourself	O	O
using	O	O
`	O	O
apply	B-API	B-API
`	O	O
or	O	O
`	O	O
iloc	B-API	O
`	O	O
in	O	O
a	O	O
loop	O	O
it's	O	O
likely	O	O
that	O	O
Pandas	O	O
is	O	O
operating	O	O
much	O	O
slower	O	O
than	O	O
is	O	O
optimal	O	O
.	O	O

Convert	O	O
freq	O	B-API
string	O	O
to	O	O
DateOffset	B-API	O
in	O	O
pandas	O	O

In	O	O
pandas	O	O
documentation	O	O
one	O	O
can	O	O
read	O	O
"	O	O
Under	O	O
the	O	O
hood	O	O
,	O	O
these	O	O
frequency	O	O
strings	O	O
are	O	O
being	O	O
translated	O	O
into	O	O
an	O	O
instance	O	O
of	O	O
pandas	O	O
DateOffset	B-API	O
"	O	O
when	O	O
speaking	O	O
of	O	O
freq	O	B-API
string	O	O
such	O	O
as	O	O
"	O	O
W	O	O
"	O	O
or	O	O
"	O	O
W-SUN	O	O
"	O	O
.	O	O

stack	O	B-API
/	O	O
unstack	O	B-API
/	O	O
pivot	O	B-API
dataframe	O	O
on	O	O
python	O	O
/	O	O
pandas	O	O

yes	O	O
,	O	O
`	O	O
isnull	B-API	B-API
`	O	O
will	O	O
create	O	O
a	O	O
boolean	O	O
series	O	O
,	O	O
`	O	O
all	B-API	B-API
`	O	O
returns	O	O
`	O	O
True	O	O
`	O	O
if	O	O
all	O	B-API
are	O	O
`	O	O
True	O	O
`	O	O

Then	O	O
merge	O	B-API
the	O	O
sub-tables	O	O
back	O	B-API
together	O	O
in	O	O
a	O	O
way	O	O
that	O	O
replaces	O	O
NaN	O	O
values	O	B-API
when	O	O
there	O	O
is	O	O
data	O	B-API
in	O	O
one	O	O
of	O	O
the	O	O
tables	O	O
.	O	O

I	O	O
regularly	O	O
work	O	O
with	O	O
very	O	O
large	O	O
data	O	B-API
sets	O	O
that	O	O
are	O	O
too	O	O
big	O	O
to	O	O
manipulate	O	O
in	O	O
memory	O	O
.	O	O

I	O	O
would	O	O
like	O	O
to	O	O
read	O	O
in	O	O
a	O	O
csv	O	O
file	O	O
iteratively	O	O
,	O	O
append	O	B-API
each	O	O
chunk	O	O
into	O	O
HDFStore	B-API	O
object	O	O
,	O	O
and	O	O
then	O	O
work	O	O
with	O	O
subsets	O	O
of	O	O
the	O	O
data	O	B-API
.	O	O

If	O	O
you	O	O
replace	O	B-API
that	O	O
line	O	O
with	O	O
:	O	O

I	O	O
wanted	O	O
to	O	O
merge	O	B-API
these	O	O
files	O	O
so	O	O
that	O	O
i	O	O
have	O	O
something	O	O
like	O	O
this	O	O
#CODE	O	O

If	O	O
it's	O	O
six	O	O
,	O	O
then	O	O
you	O	O
can	O	O
use	O	B-API
join	B-API	B-API
method	O	O
by	O	O
@USER	O	O
Hayden	O	O
.	O	O

Then	O	O
you	O	O
can	O	O
simply	O	O
`	O	O
join	B-API	B-API
`	O	O
them	O	O
:	O	O
#CODE	O	O

@USER	O	O
when	O	O
you	O	O
do	O	O
a	O	O
join	B-API	B-API
with	O	O
2x2	O	O
duplicates	O	O
you	O	O
get	O	B-API
4	O	O
in	O	O
the	O	O
joined	O	B-API
DataFrame	O	B-API
.	O	O

It's	O	O
unclear	O	O
how	O	O
pandas	O	O
should	O	O
join	O	B-API
in	O	O
this	O	O
case	O	O
,	O	O
so	O	O
you	O	O
need	O	O
to	O	O
be	O	O
more	O	O
explicit	O	O
to	O	O
it	O	O
(	O	O
and	O	O
tell	O	O
it	O	O
what	O	O
do	O	O
you	O	O
want	O	O
)	O	O
.	O	O

On	O	O
the	O	O
similar	O	O
note	O	O
,	O	O
is	O	O
there	O	O
a	O	O
way	O	O
to	O	O
merge	O	B-API
values	O	B-API
based	O	O
on	O	O
index	O	B-API
.	O	O

For	O	O
example	O	O
,	O	O
instead	O	O
of	O	O
listing	O	O
Bact5	O	O
in	O	O
two	O	O
rows	O	O
,	O	O
can	O	O
we	O	O
merge	O	B-API
its	O	O
value	O	O
corresponding	O	O
to	O	O
file2	O	O
in	O	O
one	O	O
row	O	O
separated	O	O
by	O	O
a	O	O
delimeter	O	O
?	O	O

Pandas	O	O
dataframe	O	O
insert	O	B-API
rows	O	O

I	O	O
want	O	O
to	O	O
insert	O	B-API
rows	O	O
in	O	O
DF	O	O
and	O	O
modify	O	O
its	O	O
related	O	O
values	O	B-API
:	O	O

The	O	O
code	O	O
can	O	O
only	O	O
append	O	B-API
rows	O	O
but	O	O
how	O	O
to	O	O
modify	O	O
its	O	O
values	O	B-API
in	O	O
a	O	O
faster	O	O
way	O	O
?	O	O

I	O	O
want	O	O
to	O	O
use	O	B-API
a	O	O
function	O	B-API
from	O	O
an	O	O
add-in	O	O
in	O	O
excel	O	O
and	O	O
apply	O	B-API
it	O	O
to	O	O
some	O	O
data	O	B-API
i	O	O
have	O	O
simulated	O	O
in	O	O
python	O	O
.	O	O

I	O	O
need	O	O
to	O	O
be	O	O
able	O	O
to	O	O
call	O	O
the	O	O
add-in	O	O
and	O	O
apply	O	B-API
my	O	O
data	O	B-API
indexes	O	O
there	O	O
...	O	O
something	O	O
along	O	O
these	O	O
lines	O	B-API
:	O	O
=	O	O
add-in_name	O	O
(	O	O
data_range1	O	O
,	O	O
data_range2	O	O
,	O	O
"	O	O
GGCV	O	O
")	O	O

After	O	O
reading	O	O
one	O	O
line	O	O
I	O	O
append	O	B-API
the	O	O
dictionary	O	O
to	O	O
a	O	O
list	O	B-API
(	O	O
so	O	O
,	O	O
the	O	O
number	O	O
of	O	O
dictionaries	O	O
in	O	O
the	O	O
list	O	B-API
is	O	O
equal	O	B-API
to	O	O
the	O	O
number	O	O
of	O	O
lines	O	B-API
in	O	O
the	O	O
file	O	O
)	O	O
.	O	O

I	O	O
can	O	O
easily	O	O
do	O	O
this	O	O
iteratively	O	O
with	O	O
loops	O	O
,	O	O
but	O	O
I've	O	O
read	O	O
that	O	O
you're	O	O
supposed	O	O
to	O	O
slice	B-API	B-API
/	O	O
merge	B-API	B-API
/	O	O
join	B-API	B-API
data	O	B-API
frames	O	O
holistically	O	O
,	O	O
so	O	O
I'm	O	O
trying	O	O
to	O	O
see	O	O
if	O	O
I	O	O
can	O	O
find	O	B-API
a	O	O
better	O	O
way	O	O
of	O	O
doing	O	O
this	O	O
.	O	O

A	O	O
join	B-API	B-API
will	O	O
give	O	O
me	O	O
all	O	B-API
the	O	O
stuff	O	O
that	O	O
matches	O	O
,	O	O
but	O	O
that's	O	O
not	O	O
exactly	O	O
what	O	O
I'm	O	O
looking	O	O
for	O	O
,	O	O
since	O	O
I	O	O
need	O	O
a	O	O
resulting	O	O
dataframe	O	O
for	O	O
each	O	O
key	O	O
(	O	O
i.e.	O	B-API
for	O	O
every	O	O
row	O	O
)	O	O
in	O	O
A	O	O
.	O	O

You	O	O
then	O	O
want	O	O
to	O	O
apply	O	B-API
some	O	O
function	O	B-API
to	O	O
each	O	O
group	O	B-API
of	O	O
rows	O	O
in	O	O
`	O	O
b	O	O
`	O	O
where	O	B-API
the	O	O
`	O	O
b	O	O
[	O	O
"	O	O
key	O	O
"]`	O	O
is	O	O
one	O	O
of	O	O
the	O	O
values	O	B-API
in	O	O
`	O	O
keys	O	B-API
`	O	O
.	O	O

Under	O	O
the	O	O
covers	O	O
,	O	O
these	O	O
are	O	O
really	O	O
similar	O	O
uses	O	O
of	O	O
`	O	O
apply	B-API	B-API
`	O	O
.	O	O

`	O	O
loop_iter	O	O
=	O	O
len	B-API	B-API
(	O	O
A	O	O
)	O	O
/	O	O
max	B-API	B-API
(	O	O
A	O	O
[	O	O
'	O	O
SEQ_NUM	O	O
'])	O	O

Easy	O	O
way	O	O
to	O	O
apply	O	B-API
transformation	O	O
from	O	O
`	O	O
pandas.get_dummies	B-API	B-API
`	O	O
to	O	O
new	O	O
data	O	B-API
?	O	O

As	O	O
an	O	O
aside	O	O
that	O	O
may	O	O
help	O	O
you	O	O
in	O	O
the	O	O
meantime	O	O
,	O	O
with	O	O
datetime-indexed	O	O
data	O	B-API
,	O	O
[	O	O
resample	B-API	B-API
]	O	O
(	O	O
#URL	O	O
)	O	O
is	O	O
usually	O	O
a	O	O
better	O	O
choice	O	B-API
than	O	O
reindex	B-API	B-API
.	O	O

Call	O	O
`	O	O
transform	B-API	B-API
`	O	O
on	O	O
the	O	O
'	O	O
measurement	O	O
'	O	O
column	O	O
and	O	O
pass	O	O
the	O	O
method	O	O
`	O	O
diff	B-API	B-API
`	O	O
,	O	O
transform	B-API	B-API
returns	O	O
a	O	O
series	O	O
with	O	O
an	O	O
index	O	B-API
aligned	O	O
to	O	O
the	O	O
original	O	O
df	O	O
:	O	O
#CODE	O	O

If	O	O
you	O	O
are	O	O
intending	O	O
to	O	O
apply	O	B-API
some	O	O
sorting	O	O
on	O	O
the	O	O
result	O	O
of	O	O
`	O	O
transform	B-API	B-API
`	O	O
then	O	O
sort	O	B-API
the	O	O
df	O	O
first	O	B-API
:	O	O
#CODE	O	O

Or	O	O
you	O	O
can	O	O
slice	O	B-API
the	O	O
columns	O	O
and	O	O
pass	O	O
this	O	O
to	O	O
`	O	O
drop	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

These	O	O
values	O	B-API
are	O	O
median	O	B-API
values	O	B-API
I	O	O
calculated	O	O
from	O	O
elsewhere	O	O
,	O	O
and	O	O
I	O	O
have	O	O
also	O	O
their	O	O
variance	O	O
and	O	O
standard	O	O
deviation	O	O
(	O	O
and	O	O
standard	O	O
error	O	O
,	O	O
too	O	O
)	O	O
.	O	O

=	O	O
Hash	O	O
[	O	O
0	O	O
]	O	O
was	O	O
my	O	O
point	O	O
,	O	O
but	O	O
even	O	O
without	O	O
arithmetic	O	O
,	O	O
there	O	O
will	O	O
be	O	O
a	O	O
huge	O	O
range	O	O
values	O	B-API
for	O	O
the	O	O
keys	O	B-API
that	O	O
will	O	O
give	O	O
potentially	O	O
unfortunate	O	O
results	O	O
.	O	O

if	O	O
precision	O	O
is	O	O
to	O	O
decimal	O	O
place	O	B-API
,	O	O
I'd	O	O
multiply	O	B-API
it	O	O
by	O	O
10	O	O
and	O	O
truncate	O	B-API
maybe	O	O
.	O	O

the	O	O
documentation	O	O
to	O	O
concat	B-API	B-API
is	O	O
impenetrable	O	O
and	O	O
its	O	O
hard	O	O
to	O	O
find	O	B-API
examples	O	O
of	O	O
this	O	O
relatively	O	O
simple	O	O
task	O	O
in	O	O
the	O	O
docs	O	O

If	O	O
you	O	O
had	O	O
not	O	O
called	O	O
`	O	O
apply	B-API	B-API
`	O	O
on	O	O
the	O	O
`	O	O
groupby	B-API	O
`	O	O
object	O	O
then	O	O
you	O	O
could	O	O
access	O	O
the	O	O
`	O	O
groups	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

pandas	O	O
groupby	B-API	O
X	O	O
,	O	O
Y	O	O
and	O	O
select	O	B-API
last	O	B-API
week	O	B-API
of	O	O
X1	O	O
and	O	O
X2	O	O
(	O	O
which	O	O
have	O	O
diff	O	B-API
frequency	O	O
)	O	O

Then	O	O
you	O	O
can	O	O
select	O	B-API
the	O	O
rows	O	O
you	O	O
want	O	O
in	O	O
an	O	O
apply	B-API	B-API
call	O	O
on	O	O
the	O	O
grouped	O	O
object	O	O
:	O	O
#CODE	O	O

If	O	O
you	O	O
can't	O	O
upgrade	O	O
or	O	O
don't	O	O
solve	O	B-API
the	O	O
issue	O	O
you	O	O
have	O	O
with	O	O
0.14	O	O
,	O	O
you	O	O
can	O	O
try	O	O
to	O	O
use	O	B-API
`	O	O
ix	B-API	B-API
`	O	O
instead	O	O
of	O	O
`	O	O
iloc	B-API	O
`	O	O

How	O	O
do	O	O
I	O	O
export	O	B-API
multiple	O	O
pivot	O	B-API
tables	O	O
from	O	O
python	O	O
using	O	O
pandas	O	O
to	O	O
a	O	O
single	O	O
csv	O	O
document	O	O
?	O	O

Say	O	O
I	O	O
have	O	O
a	O	O
function	O	B-API
pivots()	O	O
which	O	O
aggregates	O	O
pivot	O	B-API
tables	O	O
#CODE	O	O

I	O	O
know	O	O
how	O	O
to	O	O
export	O	B-API
a	O	O
single	O	O
pivot	O	B-API
table	O	B-API
#CODE	O	O

You	O	O
can	O	O
use	O	B-API
`	O	O
to_csv	B-API	O
(	O	O
path	O	B-API
,	O	O
mode=	O	O
'	O	O
a	O	O
')`	O	O
to	O	O
append	O	B-API
files	O	O
.	O	O

Use	O	O
`	O	O
shift	B-API	B-API
`	O	O
and	O	O
`	O	O
np.log	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

I'd	O	O
look	O	O
at	O	B-API
seeing	O	O
if	O	O
you	O	O
can	O	O
export	O	B-API
it	O	O
in	O	O
it's	O	O
raw	O	O
form	O	O
,	O	O
otherwise	O	O
this	O	O
must	O	O
be	O	O
a	O	O
common	O	O
problem	O	O
and	O	O
someone	O	O
somewhere	O	O
has	O	O
probably	O	O
coded	O	O
a	O	O
method	O	O
to	O	O
strip	O	B-API
the	O	O
emojis	O	O
out	O	O
of	O	O
the	O	O
text	O	B-API

Python	O	O
pandas	O	O
map	O	B-API
dict	O	O
keys	O	B-API
to	O	O
values	O	B-API

I	O	O
have	O	O
a	O	O
csv	O	O
for	O	O
input	O	O
,	O	O
whose	O	O
row	O	O
values	O	B-API
I'd	O	O
like	O	O
to	O	O
join	O	B-API
into	O	O
a	O	O
new	O	O
field	O	B-API
.	O	O

This	O	O
new	O	O
field	O	B-API
is	O	O
a	O	O
constructed	O	O
url	O	O
,	O	O
which	O	O
will	O	O
then	O	O
be	O	O
processed	O	O
by	O	O
the	O	O
requests.post()	B-API	B-API
method	O	O
.	O	O

I	O	O
tried	O	O
to	O	O
map	O	B-API
values	O	B-API
to	O	O
keys	O	B-API
with	O	O
a	O	O
dict	O	O
comprehension	O	O
,	O	O
but	O	O
the	O	O
assignment	O	O
of	O	O
a	O	O
key	O	O
like	O	O
'	O	O
FIRST_NAME	O	O
'	O	O
could	O	O
end	O	O
up	O	O
mapping	O	O
to	O	O
values	O	B-API
from	O	O
an	O	O
arbitrary	O	O
field	O	B-API
like	O	O
test_df	O	O
[	O	O
'	O	O
CITY	O	O
']	O	O
.	O	O

which	O	O
will	O	O
give	O	O
you	O	O
output	O	O
as	O	O
follows	O	O
:	O	O
`	O	O
[	O	O
{	O	O
'	O	O
FIRST_NAME	O	O
'	O	O
:	O	O
...,	O	O
'	O	O
LAST_NAME	O	O
'	O	O
:	O	O
...	O	O
}	O	O
,	O	O
{	O	O
'	O	O
FIRST_NAME	O	O
'	O	O
:	O	O
...,	O	O
'	O	O
LAST_NAME	O	O
'	O	O
:	O	O
...	O	O
}	O	O
]`	O	O
(	O	O
which	O	O
will	O	O
give	O	O
you	O	O
a	O	O
list	O	B-API
that	O	O
has	O	O
equal	O	B-API
length	O	O
as	O	O
`	O	O
test_df	O	O
`)	O	O
.	O	O

This	O	O
might	O	O
be	O	O
one	O	O
possibility	O	O
to	O	O
easily	O	O
map	O	B-API
it	O	O
to	O	O
a	O	O
correct	O	O
row	O	O
.	O	O

Do	O	O
you	O	O
know	O	O
if	O	O
append	B-API	B-API
returns	O	O
a	O	O
copy	O	B-API
/	O	O
view	O	B-API
/	O	O
reference	O	O
of	O	O
the	O	O
original	O	O
dataframe	O	O
?	O	O

Right	O	O
now	O	O
,	O	O
I	O	O
am	O	O
trying	O	O
to	O	O
replace	O	B-API
a	O	O
stored	O	O
procedure	O	O
with	O	O
a	O	O
Python	O	O
service	O	O
,	O	O
and	O	O
the	O	O
temp	O	O
tables	O	O
with	O	O
Pandas	O	O
dataframes	O	O
.	O	O

You	O	O
could	O	O
pass	O	O
an	O	O
argument	O	O
to	O	O
`	O	O
apply	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

Originally	O	O
,	O	O
I	O	O
used	O	O
append	B-API	B-API
api	O	O
to	O	O
create	O	O
a	O	O
single	O	O
table	O	B-API
'	O	O
impression	O	O
'	O	O
,	O	O
however	O	O
that	O	O
was	O	O
taking	O	O
80sec	O	O
per	O	O
dataframe	O	O
and	O	O
given	O	O
that	O	O
I	O	O
have	O	O
almost	O	O
200	O	O
of	O	O
files	O	O
to	O	O
be	O	O
processed	O	O
,	O	O
the	O	O
'	O	O
append	B-API	B-API
'	O	O
appeared	O	O
to	O	O
be	O	O
too	O	O
slow	O	B-API
.	O	O

Also	O	O
,	O	O
why	O	O
is	O	O
append	B-API	B-API
so	O	O
much	O	O
slower	O	O
than	O	O
put	O	B-API
?	O	O

pandas	O	O
merge	B-API	B-API
with	O	O
MultiIndex	B-API	B-API
,	O	O
when	O	O
only	O	O
one	O	O
level	O	O
of	O	O
index	O	B-API
is	O	O
to	O	O
be	O	O
used	O	O
as	O	O
key	O	O

I	O	O
want	O	O
to	O	O
recover	O	O
the	O	O
values	O	B-API
in	O	O
the	O	O
column	O	O
'	O	O
_Cat	O	O
'	O	O
from	O	O
df2	O	O
and	O	O
merge	O	B-API
them	O	O
into	O	O
df1	O	O
for	O	O
the	O	O
appropriate	O	O
values	O	B-API
of	O	O
'	O	O
_ItemId	O	O
'	O	O
.	O	O

This	O	O
is	O	O
almost	O	O
(	O	O
I	O	O
think	O	O
?	O	O
)	O	O
a	O	O
standard	O	O
many-to-one	O	O
merge	O	B-API
,	O	O
except	O	O
that	O	O
the	O	O
appropriate	O	O
key	O	O
for	O	O
the	O	O
left	O	O
df	O	O
is	O	O
one	O	O
of	O	O
MultiIndex	B-API	B-API
levels	O	O
.	O	O

Or	O	O
is	O	O
there	O	O
a	O	O
better	O	O
approach	O	O
to	O	O
this	O	O
merge	B-API	B-API
?	O	O

loc	B-API	B-API
will	O	O
not	O	O
attempt	O	O
to	O	O
use	O	B-API
a	O	O
number	O	O
(	O	O
eg	O	O
1	O	O
)	O	O
as	O	O
a	O	O
positional	O	O
argument	O	O
at	O	B-API
all	O	B-API
(	O	O
and	O	O
will	O	O
raise	O	O
instead	O	O
);	O	O
see	O	O
main	O	B-API
pandas	O	O
docs	O	O
/	O	O
selecting	O	O
data	O	B-API

I	O	O
have	O	O
the	O	O
following	O	O
boxplot	O	B-API
:	O	O
#CODE	O	O

My	O	O
question	O	O
is	O	O
:	O	O
how	O	O
can	O	O
I	O	O
change	O	O
the	O	O
whiskers	O	O
/	O	O
quantiles	O	O
being	O	O
plotted	O	O
in	O	O
the	O	O
boxplot	O	B-API
?	O	O

it'll	O	O
be	O	O
difficult	O	O
to	O	O
translate	O	B-API
those	O	O
`	O	O
ddply	O	O
`	O	O
calls	O	O
to	O	O
pandas	O	O
.	O	O

I	O	O
guess	O	O
`	O	O
groupby	B-API	O
`	O	O
should	O	O
be	O	O
used	O	O
but	O	O
I	O	O
find	O	B-API
this	O	O
format	O	B-API
very	O	O
cryptic	O	O
so	O	O
it's	O	O
hard	O	O
to	O	O
translate	O	B-API
to	O	O
python	O	O

If	O	O
you	O	O
drop	O	B-API
the	O	O
"	O	O
%	O	O
"	O	O
sign	O	B-API
,	O	O
you	O	O
can	O	O
make	O	O
the	O	O
plot	O	B-API
without	O	O
ticks	O	O
.	O	O

Append	O	O
Two	O	O
Dataframes	O	O
Together	O	O
(	O	O
Pandas	O	O
,	O	O
Python3	O	O
)	O	O

I	O	O
am	O	O
trying	O	O
to	O	O
append	O	B-API
/	O	O
join	O	B-API
(	O	O
?	O	O
)	O	O
two	O	O
different	O	O
dataframes	O	O
together	O	O
that	O	O
don't	O	O
share	O	O
any	O	B-API
overlapping	O	O
data	O	B-API
.	O	O

I	O	O
am	O	O
trying	O	O
to	O	O
append	O	B-API
these	O	O
together	O	O
using	O	O
#CODE	O	O

EDIT	O	O
:	O	O
in	O	O
regards	O	O
to	O	O
Edchum's	O	O
answers	O	O
,	O	O
I	O	O
have	O	O
tried	O	O
merge	B-API	B-API
and	O	O
join	B-API	B-API
but	O	O
each	O	O
create	O	O
somewhat	O	O
strange	O	O
tables	O	O
.	O	O

OK	O	O
,	O	O
what	O	O
you	O	O
have	O	O
to	O	O
do	O	O
is	O	O
reindex	B-API	B-API
or	O	O
reset	B-API	B-API
the	O	O
index	O	B-API
so	O	O
they	O	O
align	O	B-API

Use	O	O
`	O	O
concat	B-API	B-API
`	O	O
and	O	O
pass	O	O
param	O	O
`	O	O
axis=1	O	O
`	O	O
:	O	O
#CODE	O	O

`	O	O
join	B-API	B-API
`	O	O
also	O	O
works	O	O
:	O	O
#CODE	O	O

As	O	O
does	O	O
`	O	O
merge	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

In	O	O
the	O	O
case	O	O
where	O	B-API
the	O	O
indices	O	B-API
do	O	O
not	O	O
align	O	B-API
where	O	B-API
for	O	O
example	O	O
your	O	O
first	O	B-API
df	O	O
has	O	O
index	O	B-API
`	O	O
[	O	O
0	O	O
,	O	O
1	O	O
,	O	O
2	O	O
,	O	O
3	O	O
]`	O	O
and	O	O
your	O	O
second	O	B-API
df	O	O
has	O	O
index	O	B-API
`	O	O
[	O	O
0	O	O
,	O	O
2	O	O
]`	O	O
this	O	O
will	O	O
mean	O	B-API
that	O	O
the	O	O
above	O	O
operations	O	O
will	O	O
naturally	O	O
align	O	B-API
against	O	O
the	O	O
first	O	B-API
df's	O	O
index	O	B-API
resulting	O	O
in	O	O
a	O	O
`	O	O
NaN	O	O
`	O	O
row	O	O
for	O	O
index	O	B-API
row	O	O
`	O	O
1	O	O
`	O	O
.	O	O

To	O	O
fix	O	B-API
this	O	O
you	O	O
can	O	O
reindex	O	B-API
the	O	O
second	O	B-API
df	O	O
either	O	O
by	O	O
calling	O	O
`	O	O
reset_index()	B-API	O
`	O	O
or	O	O
assign	O	B-API
directly	O	O
like	O	O
so	O	O
:	O	O
`	O	O
df2.index	O	O
=[	O	O
0	O	O
,	O	O
1	O	O
]`	O	O
.	O	O

And	O	O
you	O	O
could	O	O
always	O	O
drop	O	B-API
back	O	B-API
to	O	O
numpy	O	O
operations	O	O
on	O	O
the	O	O
numpy	O	O
array	O	B-API
`	O	O
pan.values	O	B-API
`	O	O
if	O	O
need	O	O
be	O	O
,	O	O
though	O	O
,	O	O
hopefully	O	O
,	O	O
that	O	O
would	O	O
be	O	O
unnecessary	O	O
.	O	O

This	O	O
argument	O	O
is	O	O
new	O	O
in	O	O
1.9	O	O
...	O	O
but	O	O
there	O	O
is	O	O
a	O	O
workaround	O	O
,	O	O
try	O	O
`	O	O
np.linspace	B-API	B-API
(	O	O
0	O	O
,	O	O
len	B-API	B-API
(	O	O
pep_list	O	O
)	O	O
,	O	O
n+1	O	O
,	O	O
endpoint=True	O	O
)	O	O
.astype	B-API	B-API
(	O	O
int	O	O
)`	O	O

Take	O	O
the	O	O
time	O	B-API
difference	O	B-API
(	O	O
using	O	O
`	O	O
shift	B-API	B-API
`	O	O
)	O	O
til	O	O
the	O	O
next	O	B-API
value	O	O
,	O	O
and	O	O
multiply	O	B-API
(	O	O
value	O	O
*	O	O
seconds	O	B-API
):	O	O
#CODE	O	O

Then	O	O
do	O	O
the	O	O
resample	O	B-API
to	O	O
seconds	O	B-API
(	O	O
sum	O	B-API
the	O	O
value*seconds	O	O
):	O	O
#CODE	O	O

you	O	O
can	O	O
isnull	B-API	B-API
(	O	O
df	O	O
[	O	O
'	O	O
difference	O	B-API
'])	O	O
will	O	O
give	O	O
True	O	O
on	O	O
NaT	O	O
,	O	O
so	O	O
you	O	O
could	O	O
subtract	O	B-API
then	O	O
use	O	B-API
mask	B-API	B-API
I	O	O
think	O	O

After	O	O
they	O	O
are	O	O
done	O	O
,	O	O
merge	O	B-API
the	O	O
two	O	O
frames	O	O
together	O	O
:	O	O
#CODE	O	O

Another	O	O
solution	O	O
(	O	O
slightly	O	O
harder	O	O
):	O	O
Merge	O	O
the	O	O
columns	O	O
`	O	O
transcript_id	O	O
`	O	O
,	O	O
`	O	O
gene_id	O	O
`	O	O
and	O	O
`	O	O
gene_name	O	O
`	O	O
in	O	O
another	O	O
column	O	O
,	O	O
say	O	O
`	O	O
merged_id	O	O
`	O	O
and	O	O
`	O	O
groupby	B-API	O
`	O	O
on	O	O
`	O	O
merged_id	O	O
`	O	O
.	O	O

Geo	O	O
Pandas	O	O
Data	O	O
Frame	O	O
/	O	O
Matrix	O	O
-	O	O
filter	O	B-API
/	O	O
drop	O	B-API
NaN	O	O
/	O	O
False	O	O
values	O	B-API

Then	O	O
I	O	O
stack	O	B-API
the	O	O
dataframe	O	O
,	O	O
give	O	O
the	O	O
index	O	B-API
levels	O	O
the	O	O
desired	O	O
names	O	B-API
,	O	O
and	O	O
select	O	B-API
only	O	O
the	O	O
rows	O	O
where	O	B-API
we	O	O
have	O	O
'	O	O
True	O	O
'	O	O
values	O	B-API
:	O	O
#CODE	O	O

Can	O	O
you	O	O
enable	O	O
the	O	O
debugger	O	O
to	O	O
get	O	B-API
a	O	O
stack	O	B-API
trace	O	B-API
?	O	O

reshape	O	B-API
data	O	B-API
frame	O	O
in	O	O
pandas	O	O
with	O	O
pivot	O	B-API
table	O	B-API

With	O	O
pivot	O	B-API
table	O	B-API
you	O	O
can	O	O
get	O	B-API
a	O	O
matrix	O	B-API
showing	O	O
which	O	O
`	O	O
baz	O	O
`	O	O
corresponds	O	O
to	O	O
which	O	O
`	O	O
qux	O	O
`	O	O
:	O	O
#CODE	O	O

Rolling	O	B-API
apply	O	B-API
question	O	O

For	O	O
each	O	O
group	O	B-API
in	O	O
the	O	O
groupby	B-API	O
object	O	O
,	O	O
we	O	O
will	O	O
want	O	O
to	O	O
apply	O	B-API
a	O	O
function	O	B-API
:	O	O
#CODE	O	O

We	O	O
want	O	O
to	O	O
take	O	B-API
the	O	O
Times	O	O
column	O	O
,	O	O
and	O	O
for	O	O
each	O	O
time	O	B-API
,	O	O
apply	O	B-API
a	O	O
function	O	B-API
.	O	O

That's	O	O
done	O	O
with	O	O
`	O	O
applymap	B-API	O
`	O	O
:	O	O
#CODE	O	O

Given	O	O
a	O	O
time	O	B-API
`	O	O
t	O	O
`	O	O
,	O	O
we	O	O
can	O	O
select	O	B-API
the	O	O
`	O	O
Value	O	O
`	O	O
s	O	O
from	O	O
`	O	O
subf	O	O
`	O	O
whose	O	O
times	O	O
are	O	O
in	O	O
the	O	O
half-open	O	O
interval	O	O
`	O	O
(	O	O
t-60	O	O
,	O	O
t	O	O
]`	O	O
using	O	O
the	O	O
`	O	O
ix	B-API	B-API
`	O	O
method	O	O
:	O	O
#CODE	O	O

pandas	O	O
join	O	B-API
data	O	B-API
frames	O	O
on	O	O
similar	O	O
but	O	O
not	O	O
identical	O	B-API
string	O	O
using	O	O
lower	O	B-API
case	O	O
only	O	O

I	O	O
need	O	O
to	O	O
join	O	B-API
data	O	B-API
frames	O	O
on	O	O
columns	O	O
that	O	O
are	O	O
similar	O	O
but	O	O
not	O	O
identical	O	B-API
.	O	O

So	O	O
I	O	O
am	O	O
trying	O	O
to	O	O
isolate	O	O
the	O	O
lowercase	O	O
letters	O	O
from	O	O
each	O	O
column	O	O
,	O	O
create	O	O
new	O	O
columns	O	O
to	O	O
join	O	B-API
on	O	O
.	O	O

Note	O	O
that	O	O
this	O	O
assumes	O	O
collecting	O	O
all	O	B-API
ASCII	O	O
characters	O	O
from	O	O
`	O	O
a	O	O
`	O	O
to	O	O
`	O	O
z	O	O
`	O	O
suffices	O	O
to	O	O
produce	O	O
values	O	B-API
on	O	O
which	O	O
to	O	O
join	O	B-API
.	O	O

You	O	O
can	O	O
of	O	O
course	O	O
extend	O	O
this	O	O
with	O	O
several	O	O
joins	O	O
,	O	O
the	O	O
join	O	B-API
solution	O	O
detects	O	O
common	O	O
indices	O	B-API
automatically	O	O
.	O	O

My	O	O
data	O	B-API
is	O	O
in	O	O
a	O	O
DataFrame	O	B-API
of	O	O
about	O	O
10378	O	O
rows	O	O
and	O	O
`	O	O
len	B-API	B-API
(	O	O
df	O	O
[	O	O
'	O	O
Full	O	O
name	O	B-API
'])`	O	O
is	O	O
10378	O	O
,	O	O
as	O	O
expected	O	O
.	O	O

But	O	O
`	O	O
len	B-API	B-API
(	O	O
choices	O	O
)`	O	O
is	O	O
only	O	O
1695	O	O
.	O	O

I'm	O	O
fairly	O	O
certain	O	O
that	O	O
the	O	O
issue	O	O
is	O	O
in	O	O
the	O	O
first	O	B-API
line	O	O
,	O	O
with	O	O
the	O	O
`	O	O
to_dict()	B-API	O
`	O	O
function	O	B-API
,	O	O
as	O	O
`	O	O
len	B-API	B-API
(	O	O
df	O	O
[	O	O
'	O	O
Full	O	O
name	O	B-API
']	O	O
.astype	B-API	B-API
(	O	O
str	O	B-API
)`	O	O
results	O	O
in	O	O
10378	O	O
and	O	O
`	O	O
len	B-API	B-API
(	O	O
df	O	O
[	O	O
'	O	O
Full	O	O
name	O	B-API
']	O	O
.to_dict()	B-API	B-API
)`	O	O
results	O	O
in	O	O
1695	O	O
.	O	O

what	O	O
is	O	O
`	O	O
len	B-API	B-API
(	O	O
df.index.unique()	O	B-API
)`	O	O
?	O	O

@USER	O	O
using	O	O
`	O	O
choices	O	O
=	O	O
dict	O	O
(	O	O
zip	O	O
(	O	O
df	O	O
[	O	O
'	O	O
n	O	O
']	O	O
,	O	O
df	O	O
[	O	O
'	O	O
Full	O	O
name	O	B-API
']	O	O
.astype	B-API	B-API
(	O	O
str	O	B-API
)))`	O	O
,	O	O
where	O	B-API
df	O	O
[	O	O
'	O	O
n	O	O
']	O	O
is	O	O
np.arange	B-API	B-API
(	O	O
len	B-API	B-API
(	O	O
df	O	O
))	O	O
,	O	O
worked	O	O
fine	O	O
and	O	O
got	O	O
what	O	O
I	O	O
needed	O	O
.	O	O

Had	O	O
some	O	O
indexing	O	O
issues	O	O
because	O	O
I	O	O
was	O	O
importing	O	O
the	O	O
data	O	B-API
from	O	O
different	O	O
Excel	O	O
spreadsheets	O	O
.	O	O

This	O	O
is	O	O
what	O	O
is	O	O
happening	O	O
in	O	O
your	O	O
case	O	O
,	O	O
and	O	O
noted	O	O
from	O	O
the	O	O
comments	O	O
,	O	O
since	O	O
the	O	O
amount	O	O
of	O	O
`	O	O
unique	O	B-API
`	O	O
values	O	B-API
for	O	O
the	O	O
index	O	B-API
are	O	O
only	O	O
`	O	O
1695	O	O
`	O	O
,	O	O
we	O	O
can	O	O
confirm	O	O
this	O	O
by	O	O
testing	O	O
the	O	O
value	O	O
of	O	O
`	O	O
len	B-API	B-API
(	O	O
df.index.unique()	O	B-API
)`	O	O
.	O	O

what	O	O
do	O	O
you	O	O
mean	O	B-API
by	O	O
normalize	O	B-API
?	O	O

The	O	O
other	O	O
way	O	O
is	O	O
much	O	O
easier	O	O
and	O	O
involves	O	O
using	O	O
`	O	O
resample	B-API	B-API
`	O	O
to	O	O
convert	O	B-API
to	O	O
daily	O	O
observations	O	O
and	O	O
backfill	O	B-API
daily	O	O
consumption	O	O
.	O	O

(	O	O
Note	O	O
that	O	O
the	O	O
first	O	B-API
and	O	O
last	O	B-API
months	O	O
are	O	O
based	O	O
on	O	O
partial	O	O
data	O	B-API
,	O	O
you	O	O
may	O	O
want	O	O
to	O	O
either	O	O
drop	O	B-API
them	O	O
or	O	O
pro-rate	O	O
the	O	O
daily	O	O
consumption	O	O
.	O	O
)	O	O
#CODE	O	O

Basically	O	O
,	O	O
after	O	O
calculating	O	O
the	O	O
daily	O	O
consumption	O	O
,	O	O
do	O	O
a	O	O
partial	O	O
resample	B-API	B-API
by	O	O
adding	O	O
the	O	O
first	O	B-API
and	O	O
last	O	B-API
day	O	B-API
of	O	O
each	O	O
month	O	B-API
.	O	O

I	O	O
will	O	O
implement	O	O
it	O	O
and	O	O
see	O	O
how	O	O
it	O	O
goes	O	O
,	O	O
but	O	O
can	O	O
you	O	O
also	O	O
explain	O	O
what	O	O
'	O	O
1d	O	O
'	O	O
means	O	O
in	O	O
the	O	O
resample	B-API	B-API
method	O	O
?	O	O

@USER	O	O
'	O	O
1d	O	O
'	O	O
just	O	O
means	O	O
1	O	O
day	O	B-API
for	O	O
the	O	O
frequency	O	O
of	O	O
the	O	O
resample	B-API	B-API
.	O	O

So	O	O
I	O	O
want	O	O
something	O	O
that	O	O
will	O	O
drop	O	B-API
the	O	O
`	O	O
lob	O	O
`	O	O
group	O	B-API
,	O	O
but	O	O
keep	O	O
every	O	O
record	O	B-API
of	O	O
both	O	O
the	O	O
`	O	O
mol	O	O
`	O	O
and	O	O
`	O	O
thg	O	O
`	O	O
group	O	B-API
.	O	O

Pandas	O	O
Merge	O	O
2	O	O
data	O	B-API
frames	O	O
by	O	O
2	O	O
columns	O	O
each	O	O

In	O	O
each	O	O
data	O	B-API
frame	O	O
i	O	O
have	O	O
column	O	O
with	O	O
the	O	O
same	O	O
name	O	B-API
and	O	O
values	O	B-API
(	O	O
Key_Merge1	O	O
)	O	O
and	O	O
in	O	O
each	O	O
data	O	B-API
frame	O	O
i	O	O
have	O	O
2	O	O
different	O	O
column	O	O
names	O	B-API
with	O	O
same	O	O
values	O	B-API
(	O	O
Key_Merge2	O	O
)	O	O
.	O	O

How	O	O
can	O	O
i	O	O
merge	O	B-API
2	O	O
data	O	B-API
frames	O	O
by	O	O
2	O	O
columns	O	O
:	O	O

Can	O	O
you	O	O
post	O	O
an	O	O
example	O	O
data	O	B-API
and	O	O
df	O	O
,	O	O
your	O	O
text	O	B-API
description	O	O
is	O	O
not	O	O
clear	O	B-API
enough	O	O
but	O	O
generally	O	O
you	O	O
want	O	O
to	O	O
merge	O	B-API
and	O	O
pass	O	O
the	O	O
list	O	B-API
of	O	O
cols	O	O
to	O	O
merge	O	B-API
the	O	O
;	O	O
hs	O	O
and	O	O
rhs	O	O
on	O	O
:	O	O
`	O	O
pd.merge	B-API	B-API
(	O	O
df1	O	O
,	O	O
df2	O	O
,	O	O
left_on	O	O
=[	O	O
'	O	O
Key_Merge1	O	O
'	O	O
,	O	O
'	O	O
Key_Merge21	O	O
']	O	O
,	O	O
right_on	O	O
=[	O	O
'	O	O
Key_Merge1	O	O
'	O	O
,	O	O
'	O	O
Key_merge22	O	O
'])`	O	O

OK	O	O
,	O	O
you	O	O
have	O	O
to	O	O
rename	O	B-API
'	O	O
PRODUCT_GROUP	O	O
'	O	O
in	O	O
DF2	O	O
in	O	O
order	O	B-API
for	O	O
the	O	O
`	O	O
merge	B-API	B-API
`	O	O
to	O	O
work	O	O
:	O	O
#CODE	O	O

the	O	O
merge	B-API	B-API
will	O	O
naturally	O	O
find	O	B-API
the	O	O
2	O	O
columns	O	O
that	O	O
match	O	B-API
and	O	O
perform	O	O
an	O	O
inner	O	B-API
merge	B-API	B-API
as	O	O
desired	O	O

I	O	O
can	O	O
strip	O	B-API
out	O	O
the	O	O
rightmost	O	O
'	O	O
.csv	O	B-API
'	O	O
part	O	O
like	O	O
this	O	O
:	O	O
#CODE	O	O

How	O	O
to	O	O
merge	O	B-API
two	O	O
DataFrame	O	B-API
columns	O	O
and	O	O
apply	O	B-API
pandas.to_datetime	B-API	B-API
to	O	O
it	O	O
?	O	O

What	O	O
would	O	O
be	O	O
a	O	O
more	O	O
pythonic	O	O
way	O	O
to	O	O
merge	O	B-API
two	O	O
columns	O	O
,	O	O
and	O	O
apply	O	B-API
a	O	O
function	O	B-API
into	O	O
the	O	O
result	O	O
?	O	O

once	O	O
sorted	O	O
I	O	O
replace	O	B-API
the	O	O
df.index	O	B-API
with	O	O
a	O	O
numerical	O	O
index	O	B-API
#CODE	O	O

This	O	O
can	O	O
be	O	O
accomplished	O	O
with	O	O
a	O	O
one	O	O
line	O	O
solution	O	O
using	O	O
Pandas	O	O
'	O	O
boolean	O	O
indexing	O	O
.	O	O

The	O	O
one-liner	O	O
also	O	O
employs	O	O
some	O	O
other	O	O
tricks	O	O
:	O	O
Pandas	O	O
'	O	O
`	O	O
map	B-API	B-API
`	O	O
and	O	O
`	O	O
diff	B-API	B-API
`	O	O
methods	O	O
and	O	O
a	O	O
`	O	O
lambda	O	O
`	O	O
function	O	B-API
.	O	O

`	O	O
map	B-API	B-API
`	O	O
is	O	O
used	O	O
to	O	O
apply	B-API	B-API
the	O	O
`	O	O
lambda	O	O
`	O	O
function	O	B-API
to	O	O
all	O	B-API
rows	O	O
.	O	O

The	O	O
`	O	O
lambda	O	O
`	O	O
function	O	B-API
is	O	O
needed	O	O
to	O	O
create	O	O
a	O	O
custom	O	O
less-then	O	O
comparison	O	O
that	O	O
will	O	O
evaluate	O	B-API
NaN	O	O
values	O	B-API
to	O	O
True	O	O
.	O	O

There	O	O
is	O	O
a	O	O
built	O	O
in	O	O
method	O	O
for	O	O
this	O	O
`	O	O
diff	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

as	O	O
pointed	O	O
out	O	O
calling	O	O
`	O	O
diff	B-API	B-API
`	O	O
here	O	O
will	O	O
lose	O	O
the	O	O
first	O	B-API
row	O	O
so	O	O
I'm	O	O
using	O	O
a	O	O
ugly	O	O
hack	O	O
where	O	B-API
I	O	O
concatenate	O	B-API
the	O	O
first	O	B-API
row	O	O
with	O	O
the	O	O
result	O	O
of	O	O
the	O	O
`	O	O
diff	B-API	B-API
`	O	O
so	O	O
I	O	O
don't	O	O
lose	O	O
the	O	O
first	O	B-API
row	O	O

Using	O	O
`	O	O
diff	B-API	B-API
`	O	O
like	O	O
this	O	O
drops	O	O
the	O	O
first	O	B-API
row	O	O
.	O	O

(	O	O
I	O	O
can	O	O
also	O	O
use	O	B-API
the	O	O
chunksize	O	O
option	O	O
and	O	O
concat	O	B-API
myself	O	O
,	O	O
but	O	O
that	O	O
seems	O	O
to	O	O
be	O	O
a	O	O
bit	O	O
of	O	O
a	O	O
hack	O	O
.	O	O
)	O	O

Jeff	O	O
,	O	O
I	O	O
updated	O	O
sec_id	O	O
and	O	O
dt	B-API	B-API
in	O	O
the	O	O
dataframe	O	O
.	O	O

Sorry	O	O
,	O	O
I	O	O
had	O	O
to	O	O
update	O	B-API
"	O	O
sec_id	O	O
"	O	O
and	O	O
"	O	O
dt	O	B-API
"	O	O
to	O	O
"	O	O
id	O	O
"	O	O
and	O	O
"	O	O
date	O	B-API
"	O	O
.	O	O

0.12	O	O
is	O	O
fine	O	O
;	O	O
FYI	O	O
the	O	O
format	O	B-API
keyword	O	O
doesn't	O	O
do	O	O
anything	O	O
with	O	O
append	B-API	B-API
(	O	O
and	O	O
it's	O	O
for	O	O
0.13	O	O
anyhow	O	O
);	O	O
append	B-API	B-API
always	O	O
is	O	O
a	O	O
table	O	B-API

I	O	O
would	O	O
like	O	O
to	O	O
get	O	B-API
every	O	O
,	O	O
let's	O	O
say	O	O
,	O	O
6	O	O
hours	O	B-API
of	O	O
data	O	B-API
and	O	O
independently	O	O
fit	O	O
a	O	O
curve	O	O
to	O	O
that	O	O
data	O	B-API
.	O	O

Since	O	O
pandas	O	O
'	O	O
`	O	O
resample	B-API	B-API
`	O	O
function	O	B-API
has	O	O
a	O	O
`	O	O
how	O	O
`	O	O
keyword	O	O
that	O	O
is	O	O
supposed	O	O
to	O	O
be	O	O
any	O	B-API
numpy	O	O
array	O	B-API
function	O	B-API
,	O	O
I	O	O
thought	O	O
that	O	O
I	O	O
could	O	O
maybe	O	O
try	O	O
to	O	O
use	O	B-API
resample	B-API	B-API
to	O	O
do	O	O
that	O	O
with	O	O
`	O	O
polyfit	B-API	O
`	O	O
,	O	O
but	O	O
apparently	O	O
there	O	O
is	O	O
no	O	O
way	O	O
(	O	O
right	O	O
?	O	O
)	O	O
.	O	O

Why	O	O
does	O	O
the	O	O
second	O	B-API
block	O	O
of	O	O
code	O	O
not	O	O
work	O	O
?	O	O

Doesn't	O	O
DataFrame.apply()	B-API	B-API
default	O	O
to	O	O
inplace	O	O
?	O	O

There	O	O
is	O	O
no	O	O
inplace	O	O
parameter	O	O
to	O	O
the	O	O
apply	B-API	B-API
function	O	B-API
.	O	O

Even	O	O
if	O	O
it	O	O
doesn't	O	O
default	O	O
to	O	O
inplace	O	O
,	O	O
shouldn't	O	O
it	O	O
provide	O	O
an	O	O
inplace	O	O
parameter	O	O
the	O	O
way	O	O
replace()	B-API	O
does	O	O
?	O	O

No	O	O
,	O	O
apply	B-API	B-API
does	O	O
not	O	O
work	O	O
inplace*	O	O
.	O	O

In	O	O
general	O	O
apply	B-API	B-API
is	O	O
slow	O	B-API
(	O	O
since	O	O
you	O	O
are	O	O
basically	O	O
iterating	O	O
through	O	O
each	O	O
row	O	O
in	O	O
python	O	O
)	O	O
,	O	O
and	O	O
the	O	O
"	O	O
game	O	O
"	O	O
is	O	O
to	O	O
rewrite	O	O
that	O	O
function	O	B-API
in	O	O
terms	O	O
of	O	O
pandas	O	O
/	O	O
numpy	O	O
native	O	O
functions	O	O
and	O	O
indexing	O	O
.	O	O

If	O	O
you	O	O
want	O	O
to	O	O
delve	O	O
into	O	O
more	O	O
details	O	O
about	O	O
the	O	O
internals	O	O
,	O	O
check	O	O
out	O	O
the	O	O
BlockManager	O	O
in	O	O
core	O	O
/	O	O
internals.py	O	B-API
,	O	O
this	O	O
is	O	O
the	O	O
object	O	O
which	O	O
holds	O	O
the	O	O
underlying	O	O
numpy	O	O
arrays	O	O
.	O	O

*	O	O
apply	B-API	B-API
is	O	O
not	O	O
usually	O	O
going	O	O
to	O	O
make	O	O
sense	O	O
inplace	O	O
(	O	O
and	O	O
IMO	O	O
this	O	O
behaviour	O	O
would	O	O
rarely	O	O
be	O	O
desired	O	O
)	O	O
.	O	O

I	O	O
use	O	B-API
this	O	O
function	O	B-API
with	O	O
pandas	O	O
to	O	O
apply	O	B-API
it	O	O
to	O	O
each	O	O
month	O	B-API
of	O	O
a	O	O
historical	O	O
record	O	B-API
:	O	O
#CODE	O	O

I	O	O
am	O	O
trying	O	O
to	O	O
merge	O	B-API
tsv	O	O
files	O	O
using	O	O
pandas	O	O
but	O	O
cannot	O	O
get	O	B-API
pandas	O	O
to	O	O
return	O	O
the	O	O
file	O	O
contents	O	O
correctly	O	O
.	O	O

You	O	O
can	O	O
use	O	B-API
the	O	O
vectorised	O	O
`	O	O
str	B-API	B-API
`	O	O
methods	O	O
to	O	O
replace	O	B-API
the	O	O
unwanted	O	O
characters	O	O
and	O	O
then	O	O
cast	O	O
the	O	O
type	O	O
to	O	O
int	O	O
:	O	O
#CODE	O	O

perhaps	O	O
`	O	O
reindex	B-API	B-API
`	O	O
creates	O	O
a	O	O
new	O	O
dataframe	O	O
,	O	O
`	O	O
ix	B-API	B-API
`	O	O
returns	O	O
a	O	O
view	O	B-API

@USER	O	O
you	O	O
are	O	O
,	O	O
of	O	O
course	O	O
,	O	O
absolutely	O	O
right	O	O
.	O	O
what	O	O
do	O	O
`	O	O
loc	B-API	B-API
`	O	O
and	O	O
`	O	O
iloc	B-API	O
`	O	O
do	O	O
?	O	O

The	O	O
reason	O	O
for	O	O
the	O	O
seeming	O	O
redundancy	O	O
is	O	O
that	O	O
,	O	O
while	O	O
using	O	O
`	O	O
ix	B-API	B-API
`	O	O
is	O	O
syntacticly	O	O
limiting	O	O
(	O	O
you	O	O
can	O	O
only	O	O
pass	O	O
a	O	O
single	O	O
argument	O	O
to	O	O
`	O	O
__getitem__	O	O
`)	O	O
,	O	O
`	O	O
reindex	B-API	B-API
`	O	O
is	O	O
a	O	O
method	O	O
,	O	O
which	O	O
supports	O	O
taking	O	O
various	O	O
optional	O	O
parameters	O	O
.	O	O

I	O	O
am	O	O
getting	O	O
different	O	O
results	O	O
when	O	O
using	O	O
`	O	O
reindex	B-API	B-API
`	O	O
with	O	O
`	O	O
inplace=True	O	O
`	O	O
vs	O	O
using	O	O
`	O	O
ix	B-API	B-API
`	O	O
(	O	O
I	O	O
updated	O	O
the	O	O
OP	O	O
)	O	O

What	O	O
if	O	O
you	O	O
have	O	O
many	O	O
conditions	O	O
,	O	O
e.g.	O	B-API
you	O	O
want	O	O
to	O	O
split	O	B-API
up	O	O
the	O	O
scatters	O	O
into	O	O
4	O	O
types	O	O
of	O	O
points	O	O
or	O	O
even	O	O
more	O	O
,	O	O
plotting	O	B-API
each	O	O
in	O	O
different	O	O
shape	O	B-API
/	O	O
color	O	O
.	O	O

How	O	O
can	O	O
you	O	O
elegantly	O	O
apply	O	B-API
condition	O	O
a	O	O
,	O	O
b	O	O
,	O	O
c	O	O
,	O	O
etc	O	O
.	O	O
and	O	O
make	O	O
sure	O	O
you	O	O
then	O	O
plot	O	B-API
"	O	O
the	O	O
rest	O	O
"	O	O
(	O	O
things	O	O
not	O	O
in	O	O
any	O	B-API
of	O	O
these	O	O
conditions	O	O
)	O	O
as	O	O
the	O	O
last	O	B-API
step	O	B-API
?	O	O

To	O	O
find	O	B-API
points	O	O
skipped	O	O
due	O	O
to	O	O
NA	O	O
,	O	O
try	O	O
the	O	O
`	O	O
isnull	B-API	B-API
`	O	O
method	O	O
:	O	O
`	O	O
df	O	O
[	O	O
df.col3.isnull()	O	B-API
]`	O	O

How	O	O
do	O	O
I	O	O
create	O	O
a	O	O
pivot	O	B-API
table	O	B-API
in	O	O
Pandas	O	O
where	O	B-API
one	O	O
column	O	O
is	O	O
the	O	O
mean	O	B-API
of	O	O
some	O	O
values	O	B-API
,	O	O
and	O	O
the	O	O
other	O	O
column	O	O
is	O	O
the	O	O
sum	O	B-API
of	O	O
others	O	O
?	O	O

Basically	O	O
,	O	O
how	O	O
would	O	O
I	O	O
create	O	O
a	O	O
pivot	O	B-API
table	O	B-API
that	O	O
consolidates	O	O
data	O	B-API
,	O	O
where	O	B-API
one	O	O
of	O	O
the	O	O
columns	O	O
of	O	O
data	O	B-API
it	O	O
represents	O	O
is	O	O
calculated	O	O
,	O	O
say	O	O
,	O	O
by	O	O
`	O	O
likelihood	O	O
percentage	O	O
`	O	O
(	O	O
0.0	O	O
-	O	O
1.0	O	O
)	O	O
by	O	O
taking	O	O
the	O	O
mean	O	B-API
,	O	O
and	O	O
another	O	O
is	O	O
calculated	O	O
by	O	O
`	O	O
number	O	O
ordered	O	B-API
`	O	O
which	O	O
sums	O	O
all	O	B-API
of	O	O
them	O	O
?	O	O

i	O	O
am	O	O
facing	O	O
this	O	O
strange	O	O
behaviour	O	O
,	O	O
i	O	O
got	O	O
a	O	O
HDFStore	B-API	O
containing	O	O
DataFrames	O	O
.	O	O

What	O	O
happens	O	O
if	O	O
you	O	O
do	O	O
`	O	O
ax.legend()	B-API	B-API
`	O	O
and	O	O
`	O	O
plt.draw()	B-API	B-API
`	O	O
?	O	O

E.g.	O	B-API
,	O	O
you	O	O
can	O	O
call	O	O
`	O	O
pandas.isnull	B-API	B-API
(	O	O
the_frame	O	O
)`	O	O
.	O	O

do	O	O
this	O	O
:	O	O
``	O	O
df.ix	B-API	B-API
[	O	O
0	O	O
,	O	O
'	O	O
a	O	O
']	O	O
+=	O	O
1	O	O
``	O	O
.	O	O

Using	O	O
unstack()	B-API	O
is	O	O
one	O	O
way	O	O
.	O	O

Clearly	O	O
I'm	O	O
missing	O	O
something	O	O
as	O	O
to	O	O
why	O	O
df.loc	B-API	B-API
[:	O	O
,	O	O
tuple	O	O
]	O	O
is	O	O
different	O	O
than	O	O
df	O	O
[	O	O
tuple	O	O
]	O	O
.	O	O

datetime	O	O
dtypes	B-API	O
in	O	O
pandas	O	O
read_csv	B-API	O

If	O	O
you're	O	O
using	O	O
version	O	O
`	O	O
0.17.0	O	O
`	O	O
or	O	O
higher	O	O
then	O	O
you	O	O
can	O	O
call	O	O
this	O	O
using	O	O
`	O	O
.dt	B-API	B-API
.strftime	B-API	B-API
`	O	O
which	O	O
is	O	O
vectorised	O	O
:	O	O
#CODE	O	O

Looks	O	O
like	O	O
you	O	O
need	O	O
histogram()	B-API	O
of	O	O
months	O	O
.	O	O

You	O	O
want	O	O
`	O	O
.dt	B-API	B-API
.time	B-API	B-API
`	O	O
see	O	O
the	O	O
docs	O	O
for	O	O
some	O	O
more	O	O
examples	O	O
of	O	O
things	O	O
under	O	O
the	O	O
`	O	O
.dt	B-API	B-API
`	O	O
accessor	O	O
.	O	O

pd.rolling_apply	B-API	B-API
(	O	O
df.exma	O	B-API
,	O	O
2	O	O
,	O	O
(	O	O
df.alpha	O	B-API
*	O	O
df.exma.shift	O	B-API
(	O	O
1	O	O
))	O	O
+	O	O
((	O	O
1	O	O
-	O	O
df.alpha	O	B-API
)	O	O
*	O	O
df.outperf	O	B-API
))	O	O

I	O	O
suggest	O	O
not	O	O
using	O	O
`	O	O
file	O	O
`	O	O
for	O	O
your	O	O
`	O	O
open()	B-API	O
`	O	O
object	O	O
.	O	O

If	O	O
you	O	O
want	O	O
every	O	O
value	O	O
from	O	O
row	O	O
2	O	O
you	O	O
can	O	O
just	O	O
do	O	O
`	O	O
df.iloc	B-API	B-API
[	O	O
2	O	O
]`	O	O
or	O	O
`	O	O
df.iloc	B-API	B-API
[	O	O
2	O	O
]	O	O
.values	B-API	B-API
`	O	O
respectively	O	O
.	O	O

dtype	B-API	O
:	O	O
object	O	O

Check	O	O
out	O	O
the	O	O
glob	O	O
module	O	O
and	O	O
pandas	O	O
read_csv()	B-API	O
and	O	O
concat()	B-API	O

`	O	O
np.dtype	B-API	B-API
(	O	O
'	O	O
datetime64	O	O
[	O	O
ns	O	O
]')`	O	O
and	O	O
`	O	O
np.dtype	B-API	B-API
(	O	O
'	O	O
M	O	O
8[	O	O
ns	O	O
]')`	O	O
:	O	O
#CODE	O	O

Doing	O	O
`	O	O
pd.crosstab	B-API	B-API
(	O	O
rows	O	O
=[	O	O
df	O	O
[	O	O
'	O	O
A	O	O
']	O	O
,	O	O
df	O	O
[	O	O
'	O	O
B	O	O
']]	O	O
,	O	O
cols	O	O
=[	O	O
df	O	O
[	O	O
'	O	O
C	O	O
']]	O	O
,	O	O
margins=True	O	O
,	O	O
aggfu	O	O

DataFrame.drop_duplicates	B-API	B-API
and	O	O
DataFrame.drop	B-API	B-API
not	O	O
removing	O	O
rows	O	O

`	O	O
pd.rolling_mean	B-API	B-API
(	O	O
df	O	O
,	O	O
num	O	O
)	O	O
.dropna()	B-API	B-API
.plot()	B-API	B-API
`	O	O

This	O	O
is	O	O
a	O	O
replacement	O	O
for	O	O
`	O	O
np.array_equal	B-API	B-API
`	O	O
which	O	O
is	O	O
broken	O	O
for	O	O
nan	O	O
positional	O	O
detections	O	O
(	O	O
and	O	O
object	O	O
dtypes	B-API	O
)	O	O
.	O	O

It	O	O
looks	O	O
like	O	O
`	O	O
pd.unique	O	B-API
`	O	O
does	O	O
not	O	O
respect	O	O
the	O	O
`	O	O
datetime64	O	O
`	O	O
dtype	B-API	O
:	O	O
#CODE	O	O

df	O	O
[	O	O
'	O	O
NumActivity	O	O
']	O	O
=	O	O
pd.factorize	B-API	B-API
(	O	O
df	O	O
[	O	O
'	O	O
Activity	O	O
'])	O	O
[	O	O
0	O	O
]	O	O
+1	O	O
works	O	O
.	O	O

calling	O	O
`	O	O
as_matrix()	B-API	O
`	O	O
on	O	O
`	O	O
df	O	O
`	O	O
returns	O	O
a	O	O
`	O	O
numpy.ndarray	B-API	B-API
`	O	O
object	O	O
#CODE	O	O

And	O	O
using	O	O
pandas.Series.map	B-API	O
:	O	O
#CODE	O	O

works	O	O
,	O	O
but	O	O
I	O	O
think	O	O
`	O	O
df.select_dtypes	B-API	B-API
`	O	O
should	O	O
be	O	O
preferred	O	O
since	O	O
it	O	O
uses	O	O
the	O	O

Then	O	O
you	O	O
can	O	O
access	O	O
the	O	O
relevant	O	O
rows	O	O
using	O	O
groupby's	O	O
`	O	O
get_group	B-API	O
`	O	O
:	O	O
#CODE	O	O

It's	O	O
not	O	O
in	O	O
the	O	O
online	O	O
docs	O	O
,	O	O
you	O	O
have	O	O
to	O	O
check	O	O
the	O	O
`	O	O
help	O	O
(	O	O
pd.bdate_range	B-API	B-API
)`	O	O
:)	O	O

dtype	B-API	O
:	O	O
int64	O	O
`	O	O

dtype	B-API	O
:	O	O
object	O	O

df.drop	B-API	B-API
([	O	O
'	O	O
one	O	O
'	O	O
,	O	O
'	O	O
two	O	O
'	O	O
,	O	O
'	O	O
three	O	O
']	O	O
,	O	O
axis=1	O	O
,	O	O
inplace=True	O	O
)	O	O

I	O	O
tried	O	O
make	O	O
these	O	O
'	O	O
filenames	O	O
'	O	O
dataFrames	O	O
using	O	O
`	O	O
pd.DataFrame	B-API	O
`	O	O
but	O	O
wasn't	O	O
able	O	O
to	O	O
do	O	O
so	O	O
.	O	O

Try	O	O
using	O	O
.loc	B-API	B-API
[	O	O
row_index	O	O
,	O	O
col_indexer	O	O
]	O	O
=	O	O
value	O	O
instead	O	O
`	O	O
.	O	O

Good	O	O
question	O	O
,	O	O
`	O	O
plt.hist	B-API	B-API
(	O	O
hour_list	O	O
,	O	O
bins=	O	O
np.arange	B-API	B-API
(	O	O
24	O	O
)	O	O
-	O	O
0.5	O	O
)`	O	O
will	O	O
work	O	O
.	O	O

what	O	O
is	O	O
the	O	O
-	O	O
0.00343	O	O
(	O	O
ah	O	O
I	O	O
see	O	O
,	O	O
a	O	O
consequence	O	O
of	O	O
not	O	O
using	O	O
right=False	O	O
)	O	O
,	O	O
pd.cut	B-API	B-API
very	O	O
neat	O	O

2	O	O
)	O	O
Alternatively	O	O
,	O	O
don't	O	O
create	O	O
levels	O	O
for	O	O
`	O	O
aa	O	O
`	O	O
and	O	O
`	O	O
bb	O	O
`	O	O
using	O	O
`	O	O
as_index=False	O	O
`	O	O
and	O	O
`	O	O
pd.merge	B-API	B-API
`	O	O
#CODE	O	O

`	O	O
df.groupby	B-API	B-API
(	O	O
level	O	O
=[	O	O
'	O	O
major	O	O
'	O	O
,	O	O
'	O	O
minor	O	O
'])	O	O
.mean()	B-API	B-API
.dropna()	B-API	B-API
`	O	O

Argh	O	O
,	O	O
that	O	O
still	O	O
gives	O	O
me	O	O
`	O	O
dtype	B-API	O
(	O	O
'	O	O
datetime64	O	O
[	O	O
us	O	O
]')`	O	O
.	O	O

or	O	O
better	O	O
yet	O	O
,	O	O
just	O	O
don't	O	O
specify	O	O
a	O	O
dtype	B-API	O
:	O	O
#CODE	O	O

I	O	O
was	O	O
trying	O	O
to	O	O
do	O	O
this	O	O
with	O	O
`	O	O
df	O	O
[	O	O
df.shift()	B-API	B-API
!	O	O
=	O	O
df	O	O
]	O	O
.dropna()	B-API	B-API
.reset_index	B-API	B-API
(	O	O
drop=True	O	O
)`	O	O
but	O	O
`	O	O
shift()	B-API	O
`	O	O
is	O	O
not	O	O
behaving	O	O
in	O	O
the	O	O
way	O	O
I	O	O
meant	O	O
.	O	O

`	O	O
median_search_query	O	O
=	O	O
np.median	B-API	B-API
(	O	O
df.srch_query_affinity_score	O	B-API
)`	O	O

Example	O	O
using	O	O
df.asfreq	B-API	B-API
(	O	O
'	O	O
Q	O	O
')	O	O
:	O	O
#CODE	O	O

```	O	O
In	O	O
[	O	O
15	O	O
]:	O	O
pd.to_timedelta	B-API	B-API
(	O	O
s.str.replace	O	B-API
(	O	O
'	O	O
hrs	O	O
'	O	O
,	O	O
'	O	O
h	O	O
'))	O	O

Python	O	O
Dict	O	O
,	O	O
Lambda	O	O
x	O	O
,	O	O
map()	B-API	O
doesn't	O	O
work	O	O

I	O	O
have	O	O
tried	O	O
to	O	O
modify	O	O
your	O	O
answer	O	O
to	O	O
make	O	O
it	O	O
an	O	O
example	O	O
about	O	O
modifying	O	O
two	O	O
columns	O	O
like	O	O
I	O	O
asked	O	O
(	O	O
for	O	O
one	O	O
the	O	O
`	O	O
df.loc	B-API	B-API
[:	O	O
,	O	O
(	O	O
'	O	O
A	O	O
'	O	O
,	O	O
'	O	O
a	O	O
')]`	O	O
works	O	O
like	O	O
a	O	O
charm	O	O
)	O	O
.	O	O

I	O	O
thought	O	O
np.ma.average	B-API	B-API
is	O	O
just	O	O
what	O	O
I	O	O
need	O	O
,	O	O
but	O	O
that	O	O
also	O	O
gives	O	O
me	O	O
NaN	O	O
as	O	O
a	O	O
result	O	O
.	O	O

Although	O	O
```	O	O
pandas.cut()	B-API	B-API
```	O	O
is	O	O
the	O	O
better	O	O
and	O	O
more	O	O
general	O	O
answer	O	O
,	O	O
it	O	O
looks	O	O
like	O	O
in	O	O
this	O	O
case	O	O
you	O	O
could	O	O
do	O	O
```	O	O
df	O	O
[	O	O
'	O	O
B	O	O
']	O	O
=	O	O
(	O	O
df.A	O	O
/	O	O
500	O	O
)	O	O
.astype	B-API	B-API
(	O	O
int	O	O
)	O	O
+	O	O
1	O	O
```	O	O
.	O	O

outcome	O	O
:	O	O
displays	O	O
good	O	O
in	O	O
`	O	O
df.head()	B-API	B-API
`	O	O
,	O	O
but	O	O
reverts	O	O
to	O	O
scientific	O	O
notation	O	O
upon	O	O
coercion	O	O
to	O	O
string	O	O
concatenation	O	O
using	O	O
+	O	O
operator	O	O

The	O	O
`	O	O
ewma	B-API	O
`	O	O
case	O	O
can	O	O
be	O	O
solved	O	O
similarly	O	O
:	O	O
`	O	O
df.groupby	B-API	B-API
(	O	O
level=0	O	O
)	O	O
.apply	B-API	B-API
(	O	O
lambda	O	O
x	O	O
:	O	O
pd.ewma	B-API	B-API
(	O	O
x	O	O
,	O	O
com=2	O	O
))`	O	O

I	O	O
didn't	O	O
realise	O	O
that	O	O
`	O	O
.resample()	B-API	B-API
`	O	O
wasn't	O	O
inplace	O	O
!	O	O

I	O	O
can't	O	O
think	O	O
of	O	O
a	O	O
way	O	O
to	O	O
overload	O	O
the	O	O
`	O	O
.loc	B-API	B-API
`	O	O
method	O	O
properly	O	O
!	O	O

Do	O	O
I	O	O
have	O	O
to	O	O
specific	O	O
the	O	O
dtypes	B-API	O
to	O	O
make	O	O
this	O	O
work	O	O
?	O	O

It	O	O
appears	O	O
that	O	O
the	O	O
`	O	O
applymap	B-API	O
`	O	O
is	O	O
the	O	O
culprit	O	O
here	O	O
:-)	O	O

"	O	O
"	O	O
.join	B-API	B-API
(	O	O
header.split()	O	B-API
)	O	O
.split	B-API	B-API
(	O	O
'	O	O
')	O	O

I	O	O
want	O	O
df.append	B-API	B-API
(	O	O
df2	O	O
)	O	O
in	O	O
this	O	O
case	O	O
to	O	O
be	O	O
:	O	O
#CODE	O	O

I	O	O
completely	O	O
forgot	O	O
about	O	O
.loc	B-API	B-API

It	O	O
sounds	O	O
like	O	O
maybe	O	O
you	O	O
want	O	O
`	O	O
pandas.concat	B-API	B-API
`	O	O
?	O	O

Is	O	O
there	O	O
anything	O	O
in	O	O
pandas	O	O
that	O	O
is	O	O
the	O	O
opposite	O	O
to	O	O
`	O	O
.dropna()	B-API	B-API
`	O	O
?	O	O

Datetimes	O	O
are	O	O
handled	O	O
if	O	O
they	O	O
can	O	O
properly	O	O
be	O	O
converted	O	O
(	O	O
e.g.	O	B-API
they	O	O
have	O	O
a	O	O
dtype	B-API	O
of	O	O
'	O	O
datetime64	O	O
[	O	O
ns	O	O
]'	O	O
,	O	O
notably	O	O
datetimes.date	O	B-API
are	O	O
NOT	O	O
handled	O	O
(	O	O
NaN	O	O
are	O	O
a	O	O
different	O	O
story	O	O
and	O	O
depending	O	O
on	O	O
usage	O	O
can	O	O
cause	O	O
the	O	O
entire	O	O
column	O	O
type	O	O
to	O	O
be	O	O
mishandled	O	O
)	O	O

The	O	O
`	O	O
args	O	O
`	O	O
and	O	O
`	O	O
kwargs	O	O
`	O	O
parameters	O	O
were	O	O
added	O	O
to	O	O
`	O	O
rolling_apply	B-API	O
`	O	O
in	O	O
Pandas	O	O
version	O	O
0.14.0	O	O
.	O	O

try	O	O
``	O	O
df	O	O
[	O	O
'	O	O
LastName	O	O
']	O	O
=	O	O
df.apply	B-API	B-API
(	O	O
updateDataframe	O	O
)``	O	O
,	O	O
but	O	O
even	O	O
better	O	O
is	O	O
:	O	O
``	O	O
df.ix	B-API	B-API
[	O	O
df	O	O
[	O	O
'	O	O
LastName	O	O
']	O	O
==	O	O
'	O	O
Joe	O	O
'	O	O
,	O	O
'	O	O
LastName	O	O
']	O	O
=	O	O
'	O	O
Black	O	O
'``	O	O

There	O	O
should	O	O
be	O	O
no	O	O
problem	O	O
;	O	O
`	O	O
plt.plot	B-API	B-API
`	O	O
and	O	O
`	O	O
plt.fill_between	B-API	B-API
`	O	O
accept	O	O
arrays	O	O
of	O	O
dtype	B-API	O
`	O	O
datetime64	O	O
[	O	O
ns	O	O
]`	O	O
just	O	O
fine	O	O
.	O	O

You	O	O
could	O	O
try	O	O
pandas	O	O
pivot()	B-API	O
.	O	O

What	O	O
happens	O	O
if	O	O
you	O	O
do	O	O
`	O	O
ax.legend()	B-API	B-API
`	O	O
and	O	O
`	O	O
plt.draw()	B-API	B-API
`	O	O
?	O	O

Pandas	O	O
Python	O	O
read_csv	B-API	O
error_bad_lines	O	O
producing	O	O
shell	O	O
feedback	O	O

Though	O	O
in	O	O
some	O	O
respects	O	O
,	O	O
the	O	O
np.clip	B-API	B-API
or	O	O
np.max	O	B-API
solutions	O	O
are	O	O
more	O	O
easily	O	O
read	O	O
,	O	O
I	O	O
think	O	O
this	O	O
is	O	O
the	O	O
most	O	O
precise	O	O
answer	O	O
to	O	O
my	O	O
original	O	O
question	O	O
.	O	O

Did	O	O
you	O	O
try	O	O
setting	O	O
the	O	O
delimiter	O	O
to	O	O
semicolon	O	O
in	O	O
your	O	O
`	O	O
read_csv	B-API	O
`	O	O
call	O	O
?	O	O

In	O	O
[	O	O
8]	O	O
:	O	O
%timeit	O	O
df	O	O
[	O	O
'	O	O
r	O	O
']	O	O
=	O	O
df	O	O
[[	O	O
'	O	O
minor	O	O
'	O	O
,	O	O
'	O	O
major	O	O
']]	O	O
.abs()	B-API	B-API
.max	B-API	B-API
(	O	O
axis=1	O	O
)	O	O

I	O	O
guess	O	O
my	O	O
confusion	O	O
stems	O	O
from	O	O
the	O	O
fact	O	O
that	O	O
the	O	O
Series.value_counts	B-API	B-API
doesn't	O	O
seem	O	O
to	O	O
fit	O	O
into	O	O
the	O	O
arguments	O	O
required	O	O
by	O	O
the	O	O
df.apply	B-API	B-API
method	O	O
.	O	O

The	O	O
problem	O	O
is	O	O
that	O	O
`	O	O
a	O	O
`	O	O
is	O	O
dtype	B-API	O
`	O	O
object	O	O
`	O	O
.	O	O

try	O	O
`	O	O
video_base	O	O
=	O	O
pd.merge	B-API	B-API
(	O	O
df_one	O	O
,	O	O
df_two	O	O
[[	O	O
'	O	O
count_watched_yeterday	O	O
']]	O	O
,	O	O
how=	O	O
'	O	O
left	O	O
'	O	O
,	O	O
left_index=True	O	O
,	O	O
right_index=True	O	O
)`	O	O

ax.xaxis.set_major_locator	O	B-API
(	O	O
MultipleLocator	B-API	O
(	O	O
10	O	O
))	O	O

Actually	O	O
I	O	O
think	O	O
you	O	O
want	O	O
:	O	O
`	O	O
pd.concat	B-API	B-API
([	O	O
df_may	O	O
,	O	O
df_jun	O	O
]	O	O
,	O	O
axis=0	O	O
,	O	O
ignore_index=True	O	O
)`	O	O

Maybe	O	O
there	O	O
is	O	O
a	O	O
better	O	O
approach	O	O
thats	O	O
takes	O	O
advantage	O	O
of	O	O
features	O	O
of	O	O
the	O	O
Pandas.DataFrame	B-API	O
class	O	O
?	O	O

Try	O	O
`	O	O
df.loc	B-API	B-API
[	O	O
'	O	O
a	O	O
']`	O	O
instead	O	O
.	O	O

Then	O	O
this	O	O
should	O	O
work	O	O
:	O	O
`	O	O
df	O	O
[	O	O
'	O	O
Gene.Symbol	O	O
']	O	O
=	O	O
df	O	O
[	O	O
'	O	O
Gene.Symbol	O	O
']	O	O
.str	B-API	B-API
.strip()	B-API	B-API
.str	B-API	B-API
.upper()	B-API	B-API
`	O	O

then	O	O
[	O	O
`	O	O
df.groupy	O	B-API
(	O	O
'	O	O
key	O	O
')	O	O
.agg	B-API	B-API
(	O	O
...	O	O
)`]	O	O
(	O	O
#URL	O	O
)	O	O
might	O	O
be	O	O
what	O	O
you	O	O
are	O	O
looking	O	O
for	O	O
.	O	O

DataFrame.apply	B-API	B-API
in	O	O
python	O	O
pandas	O	O
alters	O	O
both	O	O
original	O	O
and	O	O
duplicate	O	O
DataFrames	O	O

you	O	O
might	O	O
want	O	O
to	O	O
try	O	O
`	O	O
df.iloc	B-API	B-API
[	O	O
0	O	O
]`	O	O
rather	O	O
than	O	O
`	O	O
df.iloc	B-API	B-API
(	O	O
0	O	O
)`	O	O
.	O	O

and	O	O
,	O	O
`	O	O
ts.asfreq	O	B-API
(	O	O
'	O	O
H	O	O
'	O	O
,	O	O
method=	O	O
'	O	O
ffill	B-API	O
')`	O	O
to	O	O
have	O	O
hourly	O	O
frequency	O	O
.	O	O

I	O	O
tried	O	O
something	O	O
like	O	O
`	O	O
set_index	B-API	O
`	O	O
,	O	O
`	O	O
pd.factorize()	B-API	B-API
`	O	O
and	O	O
`	O	O
index_col	O	O
`	O	O
but	O	O
they	O	O
do	O	O
not	O	O
work	O	O
.	O	O

So	O	O
df	O	O
=	O	O
df.reindex()	B-API	B-API
results	O	O
in	O	O
the	O	O
same	O	O
indexing	O	O
...	O	O

I	O	O
think	O	O
this	O	O
solution	O	O
will	O	O
execute	O	O
faster	O	O
than	O	O
using	O	O
iterrows()	B-API	O
,	O	O
but	O	O
I'm	O	O
not	O	O
sure	O	O
.	O	O

One	O	O
option	O	O
using	O	O
`	O	O
df.reindex	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

I	O	O
am	O	O
using	O	O
dtype	B-API	O
as	O	O
suggested	O	O
in	O	O
the	O	O
answer	O	O
there	O	O
.	O	O

You	O	O
might	O	O
be	O	O
interested	O	O
in	O	O
`	O	O
pd.cut	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

df.groupby	B-API	B-API
(	O	O
'	O	O
A	O	O
')	O	O
.size()	B-API	B-API
.apply	B-API	B-API
(	O	O
lambda	O	O
x	O	O
:	O	O
float	O	O
(	O	O
x	O	O
)	O	O
/	O	O
df.groupby	B-API	B-API
(	O	O
'	O	O
A	O	O
')	O	O
.size()	B-API	B-API
.sum()	B-API	B-API
*100	O	O
)	O	O

`	O	O
df.apply()	B-API	B-API
`	O	O
works	O	O
off	O	O
a	O	O
single	O	O
row	O	O
,	O	O
`	O	O
shift()	B-API	O
`	O	O
doesnt	O	O
seem	O	O
to	O	O
work	O	O
.	O	O

Could	O	O
you	O	O
try	O	O
this	O	O
:	O	O
`	O	O
df	O	O
[	O	O
'	O	O
GC	O	O
content	O	O
']	O	O
=	O	O
df	O	O
[[	O	O
'	O	O
oligo_sequence	O	O
']]	O	O
.apply	B-API	B-API
(	O	O
lambda	O	O
row	O	O
:	O	O
GC	O	O
(	O	O
row	O	O
)	O	O
,	O	O
axis=1	O	O
)`	O	O

And	O	O
,	O	O
`	O	O
pd.eval()	B-API	B-API
`	O	O
works	O	O
well	O	O
with	O	O
expressions	O	O
containing	O	O
large	O	O
arrays	O	O
#CODE	O	O

The	O	O
eventual	O	O
goal	O	O
being	O	O
to	O	O
arrange	O	O
hierarchically	O	O
to	O	O
weekday	B-API	O
hour-range	O	O
,	O	O
something	O	O
like	O	O
:	O	O
#CODE	O	O

Reading	O	O
about	O	O
`	O	O
applymap	B-API	O
`	O	O
I	O	O
wondered	O	O
if	O	O
there	O	O
is	O	O
a	O	O
similar	O	O
way	O	O
of	O	O
defining	O	O
and	O	O
applying	O	O
operators	O	O
that	O	O
work	O	O
on	O	O
pairs	O	O
of	O	O
dataframes	O	O
.	O	O

Executing	O	O
your	O	O
code	O	O
with	O	O
pandas	O	O
0.16.2	O	O
yielded	O	O
the	O	O
two	O	O
columns	O	O
with	O	O
dtype	B-API	O
datetime64	O	O
[	O	O
ns	O	O
]	O	O
.	O	O

`	O	O
df	O	O
[	O	O
'	O	O
price_trend	O	O
']	O	O
.apply	B-API	B-API
(	O	O
lambda	O	O
x	O	O
:[	O	O
i.split	O	B-API
(	O	O
'	O	O
:	O	O
')	O	O
for	O	O
i	O	O
in	O	O
x	O	O
])`	O	O
#CODE	O	O

Here	O	O
the	O	O
new	O	O
value	O	O
AND	O	O
the	O	O
existing	O	O
dtype	B-API	O
of	O	O
the	O	O
column	O	O
matters	O	O
.	O	O

how	O	O
about	O	O
using	O	O
the	O	O
`	O	O
pd.DataFrame.drop_duplicates()	B-API	O
`	O	O
method	O	O
?	O	O

dtype	B-API	O
:	O	O
timedelta64	O	O
[	O	O
ns	O	O
]```	O	O

`	O	O
gg	O	O
[	O	O
'	O	O
cumt	O	O
']	O	O
=	O	O
gg.apply	O	B-API
(	O	O
lambda	O	O
x	O	O
:	O	O
x	O	O
[	O	O
'	O	O
tavg	O	O
']	O	O
+	O	O
x	O	O
[	O	O
'	O	O
tavg	O	O
']	O	O
.shift	B-API	B-API
(	O	O
1	O	O
)	O	O
[	O	O
1	O	O
:]	O	O
)`	O	O

"	O	O
"	O	O
.join	B-API	B-API
(	O	O
header.split()	O	B-API
)	O	O
.split	B-API	B-API
(	O	O
'	O	O
')	O	O

print	O	O
'	O	O
\nAfter	O	O
replace\n	O	O
'	O	O
,	O	O
df.replace	B-API	B-API
(	O	O
{	O	O
'	O	O
c1	O	O
'	O	O
:	O	O
c1_fromto	O	O
,	O	O
'	O	O
c2	O	O
'	O	O
:	O	O
c2_fromto	O	O
}	O	O
)	O	O

Profiling	O	O
shows	O	O
the	O	O
culprit	O	O
is	O	O
obviously	O	O
`	O	O
B.ix	O	B-API
[	O	O
row	O	O
[	O	O
0	O	O
]]	O	O
.irow	B-API	B-API
(	O	O
np.searchsorted	B-API	B-API
(	O	O
B.ts	O	B-API
[	O	O
row	O	O
[	O	O
0	O	O
]]	O	O
,	O	O
row	O	O
[	O	O
2	O	O
])))`	O	O
.	O	O

My	O	O
question	O	O
concerns	O	O
iterating	O	O
through	O	O
the	O	O
rows	O	O
of	O	O
a	O	O
data	O	B-API
frame	O	O
and	O	O
on	O	O
each	O	O
row	O	O
setting	O	O
a	O	O
field	O	B-API
based	O	O
on	O	O
information	O	O
in	O	O
a	O	O
different	O	O
data	O	B-API
frame	O	O
.	O	O

EDIT	O	O
:	O	O
Adding	O	O
logic	O	O
to	O	O
default	O	O
empty	O	B-API
strings	O	O
to	O	O
`	O	O
0	O	O
`	O	O
,	O	O
use	O	B-API
a	O	O
different	O	O
value	O	O
if	O	O
you	O	O
want	O	O
to	O	O
handle	O	O
empty	O	B-API
strings	O	O
in	O	O
`	O	O
years	O	O
`	O	O
colomn	O	O
differently	O	O
#CODE	O	O

I	O	O
would	O	O
suggest	O	O
that	O	O
you	O	O
use	O	B-API
2-dimensional	O	O
numpy	O	O
array	O	B-API
.	O	O

I	O	O
renamed	O	O
them	O	O
to	O	O
aa	O	O
,	O	O
ab	O	O
and	O	O
ac	O	O
but	O	O
still	O	O
get	O	B-API
the	O	O
same	O	O
error	O	O
.	O	O

In	O	O
this	O	O
last	O	B-API
case	O	O
,	O	O
RAM	O	O
usage	O	O
fits	O	O
the	O	O
equivalent	O	O
`	O	O
chunk	O	O
`	O	O
size	O	B-API
#CODE	O	O

`	O	O
pandas	O	O
`	O	O
,	O	O
like	O	O
`	O	O
numpy	O	O
`	O	O
and	O	O
many	O	O
other	O	O
modules	O	O
,	O	O
is	O	O
not	O	O
written	O	O
in	O	O
pure	O	O
Python	O	O
-	O	O
it	O	O
has	O	O
components	O	B-API
written	O	O
in	O	O
C	O	O
and	O	O
Cython	O	O
that	O	O
get	O	B-API
compiled	O	O
into	O	O
version-	O	O
and	O	O
platform-specific	O	O
libraries	O	O
during	O	O
the	O	O
build	O	O
process	O	B-API
.	O	O

It	O	O
gave	O	O
me	O	O
the	O	O
error	O	O
:	O	O
cqid	O	O
=	O	O
row	O	O
[	O	O
'	O	O
ClearQuest	O	O
ID	O	O
']	O	O
TypeError	O	O
:	O	O
string	O	O
indices	O	B-API
must	O	O
be	O	O
integers	O	O
,	O	O
not	O	O
str	O	B-API
...........	O	O

The	O	O
use	O	B-API
case	O	O
is	O	O
that	O	O
I	O	O
have	O	O
different	O	O
time	O	B-API
series	O	O
coming	O	O
from	O	O
different	O	O
data	O	B-API
sources	O	O
.	O	O

How	O	O
can	O	O
I	O	O
get	O	B-API
pandas	O	O
Timestamp	O	O
offset	O	B-API
by	O	O
certain	O	O
amount	O	O
of	O	O
months	O	O
?	O	O

I	O	O
managed	O	O
to	O	O
get	O	B-API
the	O	O
stats	O	O
by	O	O
placing	O	O
everything	O	O
in	O	O
nested	O	O
dictionary	O	O
,	O	O
but	O	O
I	O	O
feel	O	O
that	O	O
there	O	O
may	O	O
be	O	O
a	O	O
much	O	O
easier	O	O
way	O	O
to	O	O
the	O	O
approach	O	O
by	O	O
using	O	O
pandas	O	O
dataframes	O	O
and	O	O
groubpy	O	O
.	O	O

Just	O	O
to	O	O
get	O	B-API
a	O	O
sense	O	O
of	O	O
what	O	O
I'm	O	O
trying	O	O
to	O	O
achieve	O	O
.	O	O

Which	O	O
is	O	O
suspect	O	O
is	O	O
due	O	O
to	O	O
my	O	O
data	O	B-API
range	O	O
,,	O	O
but	O	O
it	O	O
may	O	O
well	O	O
be	O	O
that	O	O
I	O	O
don't	O	O
understand	O	O
the	O	O
other	O	O
parameters	O	O
.	O	O

Your	O	O
second	O	B-API
one	O	O
doesn't	O	O
really	O	O
make	O	O
sense	O	O
as	O	O
an	O	O
aggregation	O	O
.	O	O

How	O	O
can	O	O
I	O	O
get	O	B-API
the	O	O
index	O	B-API
of	O	O
certain	O	O
element	O	O
of	O	O
a	O	O
Series	O	B-API
in	O	O
python	O	O
pandas	O	O
?	O	O

(	O	O
Very	O	O
,	O	O
very	O	O
late	O	O
reply	O	O
-	O	O
apologies	O	O
.	O	O
)	O	O
That's	O	O
true	O	O
,	O	O
you'd	O	O
use	O	B-API
the	O	O
method	O	O
EdChum	O	O
suggested	O	O
for	O	O
longer	O	O
lists	O	O
of	O	O
columns	O	O
.	O	O

If	O	O
actual_sum	O	O
and	O	O
expected_to_date	O	O
are	O	O
equal	O	B-API
,	O	O
put	O	B-API
a	O	O
0	O	O

`	O	O
ts	O	O
[	O	O
ts	O	O
[	O	O
'	O	O
values	O	B-API
']	O	O
0	O	O
]`	O	O
should	O	O
produce	O	O
the	O	O
output	O	O
you	O	O
are	O	O
looking	O	O
for	O	O
.	O	O

And	O	O
I	O	O
get	O	B-API
the	O	O
counts	O	O
:	O	O
#CODE	O	O

The	O	O
standard	O	O
deviation	O	O
differs	O	O
between	O	B-API
pandas	O	O
and	O	O
numpy	O	O
.	O	O

I	O	O
would	O	O
like	O	O
to	O	O
get	O	B-API
rid	O	O
of	O	O
the	O	O
loops	O	O
,	O	O
if	O	O
that	O	O
is	O	O
possible	O	O
.	O	O

If	O	O
I	O	O
change	O	O
the	O	O
names	O	B-API
then	O	O
there	O	O
is	O	O
nothing	O	O
to	O	O
reference	O	O
.	O	O

I	O	O
even	O	O
tried	O	O
building	O	O
from	O	O
the	O	O
git	O	O
,	O	O
but	O	O
whatever	O	O
I	O	O
seem	O	O
to	O	O
do	O	O
,	O	O
I	O	O
get	O	B-API
the	O	O
same	O	O
error	O	O
:	O	O
#CODE	O	O

I	O	O
want	O	O
to	O	O
do	O	O
the	O	O
following	O	O
operations	O	O
on	O	O
the	O	O
data	O	B-API
storage	O	O
:	O	O

How	O	O
do	O	O
I	O	O
get	O	B-API
it	O	O
to	O	O
actually	O	O
show	O	B-API
the	O	O
graph	O	O
?	O	O

#URL	O	O
shows	O	O
a	O	O
way	O	O
to	O	O
get	O	B-API
the	O	O
number	O	O
of	O	O
days	O	B-API
in	O	O
a	O	O
month	O	B-API
,	O	O
making	O	O
the	O	O
rest	O	O
more	O	O
or	O	O
less	O	B-API
trivial	O	O
as	O	O
they	O	O
don't	O	O
vary	O	O
.	O	O

to	O	O
create	O	O
average	O	B-API
values	O	B-API
with	O	O
an	O	O
equidistant	O	O
time-vector	O	O
.	O	O

I	O	O
get	O	B-API
something	O	O
where	O	B-API
all	O	B-API
"	O	O
newlines	O	O
"	O	O
are	O	O
escaped	O	O
.	O	O

Reproducing	O	O
without	O	O
a	O	O
data	O	B-API
file	O	O
,	O	O
using	O	O
Jeff's	O	O
suggestion	O	O
:	O	O
#CODE	O	O

However	O	O
,	O	O
I	O	O
also	O	O
want	O	O
to	O	O
get	O	B-API
it	O	O
on	O	O
the	O	O
basis	O	O
of	O	O
the	O	O
`	O	O
Group	O	O
`	O	O
variable	O	O
,	O	O
which	O	O
means	O	O
I	O	O
don't	O	O
want	O	O
to	O	O
get	O	B-API
`	O	O
Bob	O	O
`'	O	O
s	O	O
`	O	O
Value	O	O
`	O	O
based	O	O
on	O	O
the	O	O
`	O	O
Jared	O	O
`'	O	O
s	O	O
`	O	O
Value	O	O
`	O	O
,	O	O
since	O	O
those	O	O
two	O	O
records's	O	O
`	O	O
Group	O	O
`	O	O
value	O	O
is	O	O
different	O	O
-	O	O
I	O	O
only	O	O
compute	O	O
it	O	O
within	O	O
each	O	O
specific	O	O
`	O	O
Group	O	O
`	O	O
variable	O	O
.	O	O

I	O	O
try	O	O
to	O	O
use	O	B-API
jsonlint	O	O
to	O	O
validate	O	O
these	O	O
json	O	O
files	O	O
but	O	O
encounter	O	O
some	O	O
error	O	O
messages	O	O
.	O	O

The	O	O
logic	O	O
to	O	O
arrive	O	O
at	O	B-API
that	O	O
database	O	O
is	O	O
an	O	O
intricate	O	O
mix	O	O
of	O	O
Python	O	O
processing	O	O
and	O	O
SQL	O	O
joins	O	O
done	O	O
in	O	O
sqlite3	O	O
.	O	O

I	O	O
want	O	O
to	O	O
take	O	B-API
advantage	O	O
of	O	O
the	O	O
`	O	O
str	O	B-API
`	O	O
accessor	O	O
to	O	O
split	O	B-API
the	O	O
data	O	B-API
into	O	O
two	O	O
columns	O	O
,	O	O
such	O	O
that	O	O
the	O	O
first	O	B-API
column	O	O
is	O	O
,	O	O
Name	O	O
,	O	O
contains	O	B-API
the	O	O
actual	O	O
name	O	B-API
(	O	O
first	O	B-API
name	O	B-API
last	O	B-API
name	O	B-API
)	O	O
,	O	O
and	O	O
the	O	O
second	O	B-API
column	O	O
,	O	O
Email	O	O
,	O	O
contains	O	B-API
the	O	O
email	O	O
address	O	O
)	O	O
.	O	O

In	O	O
fact	O	O
the	O	O
only	O	O
really	O	O
relevant	O	O
data	O	B-API
needed	O	O
for	O	O
the	O	O
plot	O	B-API
is	O	O
the	O	O
first	O	B-API
and	O	O
second	O	B-API
column	O	O
,	O	O
namely	O	O
:	O	O
`	O	O
Compression	O	O
Force	O	O
`	O	O
and	O	O
`	O	O
Compression	O	O
Velocity	O	O
`	O	O
.	O	O

How	O	O
to	O	O
get	O	B-API
special	O	O
characters	O	O
from	O	O
Excel	O	O
to	O	O
screen	O	O
using	O	O
pandas	O	O
?	O	O

And	O	O
replace	O	B-API
`'	O	O
Month	O	O
'`	O	O
with	O	O
`'	O	O
Day	O	O
'`	O	O
below	O	O
.	O	O

But	O	O
if	O	O
you	O	O
have	O	O
a	O	O
huge	O	O
amount	O	O
to	O	O
data	O	B-API
,	O	O
it	O	O
*	O	O
might	O	O
*	O	O
be	O	O
interesting	O	O
to	O	O
think	O	O
of	O	O
a	O	O
more	O	O
complex	O	O
data	O	B-API
model	O	O
.	O	O

What	O	O
are	O	O
you	O	O
trying	O	O
to	O	O
do	O	O
where	O	B-API
this	O	O
is	O	O
the	O	O
bottleneck	O	O
?	O	O

How	O	O
can	O	O
I	O	O
change	O	O
that	O	O
and	O	O
use	O	B-API
insted	O	O
the	O	O
first	O	B-API
line	O	O
of	O	O
output	O	O
code	O	O
as	O	O
a	O	O
column	O	O
(	O	O
In	O	O
this	O	O
case	O	O
line	O	O
10	O	O
:	O	O
Sub-Data	O	O
Item	O	O
...	O	O
)	O	O

My	O	O
objective	O	O
was	O	O
to	O	O
have	O	O
a	O	O
DTM	O	O
like	O	O
the	O	O
one	O	O
you	O	O
get	O	B-API
in	O	O
R	O	O
tm	O	O
.	O	O

So	O	O
right	O	O
now	O	O
all	O	B-API
the	O	O
data	O	B-API
comes	O	O
from	O	O
each	O	O
iteration	O	O
group	O	B-API
,	O	O
and	O	O
all	O	B-API
of	O	O
its	O	O
is	O	O
transformed	O	B-API
into	O	O
one	O	O
column	O	O
vector	O	O
.	O	O

I	O	O
am	O	O
trying	O	O
to	O	O
get	O	B-API
to	O	O
the	O	O
point	O	O
where	O	B-API
I	O	O
can	O	O
run	O	O
#CODE	O	O

While	O	O
I	O	O
don't	O	O
get	O	B-API
that	O	O
warning	O	O
with	O	O
#CODE	O	O

Thanks	O	O
@USER	O	O
-	O	O
I	O	O
mean	O	B-API
that	O	O
,	O	O
if	O	O
we	O	O
do	O	O
`	O	O
A-B	O	O
`	O	O
we	O	O
should	O	O
only	O	O
get	O	B-API
the	O	O
NaNs	O	O
in	O	O
`	O	O
A	O	O
`	O	O
,	O	O
and	O	O
not	O	O
the	O	O
NaNs	O	O
in	O	O
`	O	O
B	O	O
`	O	O
.	O	O

I	O	O
have	O	O
three	O	O
columns	O	O
in	O	O
my	O	O
data	O	B-API
set	O	B-API
,	O	O
namely	O	O
"	O	O
age	O	O
"	O	O
,	O	O
"	O	O
race	O	O
"	O	O
,	O	O
"	O	O
sex	O	O
"	O	O
,	O	O
that	O	O
I	O	O
care	O	O
about	O	O
.	O	O

Cannot	O	O
get	O	B-API
the	O	O
average	O	B-API
date	O	B-API
using	O	O
pandas	O	O

Any	O	O
suggestions	O	O
?	O	O

All	O	O
values	O	B-API
ought	O	O
to	O	O
be	O	O
integers	O	O
,	O	O
no	O	O
floats	O	O
.	O	O

Note	O	O
:	O	O
this	O	O
will	O	O
get	O	B-API
tripped	O	O
up	O	O
by	O	O
some	O	O
strings	O	O
,	O	O
so	O	O
use	O	B-API
with	O	O
caution	O	O
.	O	O

The	O	O
purpose	O	O
of	O	O
all	O	B-API
these	O	O
stuff	O	O
is	O	O
a	O	O
geographical	O	O
representation	O	O
of	O	O
data	O	B-API
on	O	O
a	O	O
spatial	O	O
grid	O	B-API
.	O	O

Since	O	O
Name	O	O
`	O	O
C	O	O
`	O	O
does	O	O
not	O	O
have	O	O
`	O	O
3	O	O
`	O	O
or	O	O
`	O	O
5	O	O
`	O	O
in	O	O
the	O	O
column	O	O
`	O	O
Activity	O	O
`	O	O
,	O	O
I	O	O
do	O	O
not	O	O
want	O	O
to	O	O
get	O	B-API
this	O	O
data	O	B-API
frame	O	O
.	O	O

Data	O	O
has	O	O
to	O	O
be	O	O
collected	O	O
before	O	O
local	O	O
data	O	B-API
frame	O	O
is	O	O
created	O	O
.	O	O

PANDAS	O	O
:	O	O
Extracting	O	O
values	O	B-API
from	O	O
a	O	O
column	O	O
by	O	O
applying	O	O
a	O	O
condition	O	O
on	O	O
other	O	O
columnns	O	O

If	O	O
you	O	O
try	O	O
to	O	O
produce	O	O
the	O	O
groups	O	B-API
from	O	O
my	O	O
example	O	O
you'll	O	O
see	O	O
what	O	O
I	O	O
mean	O	B-API
.	O	O

`	O	O
pandas	O	O
`	O	O
,	O	O
like	O	O
`	O	O
numpy	O	O
`	O	O
and	O	O
many	O	O
other	O	O
modules	O	O
,	O	O
is	O	O
not	O	O
written	O	O
in	O	O
pure	O	O
Python	O	O
-	O	O
it	O	O
has	O	O
components	O	B-API
written	O	O
in	O	O
C	O	O
and	O	O
Cython	O	O
that	O	O
get	O	B-API
compiled	O	O
into	O	O
version-	O	O
and	O	O
platform-specific	O	O
libraries	O	O
during	O	O
the	O	O
build	O	O
process	O	B-API
.	O	O

Not	O	O
sure	O	O
how	O	O
to	O	O
get	O	B-API
around	O	B-API
this	O	O
...	O	O
pretty	O	O
new	O	O
to	O	O
pandas	O	O
.	O	O

Here's	O	O
the	O	O
product	O	B-API
:	O	O
#CODE	O	O

However	O	O
,	O	O
as	O	O
the	O	O
data	O	B-API
became	O	O
large	O	O
,	O	O
we	O	O
played	O	O
with	O	O
SQLAlchemy	O	O
/	O	O
SQLite3	O	O
.	O	O

But	O	O
this	O	O
time	O	B-API
I	O	O
get	O	B-API
another	O	O
error	O	O
:	O	O
#CODE	O	O

Makes	O	O
the	O	O
change	O	O
the	O	O
idea	O	O
of	O	O
trying	O	O
to	O	O
use	O	B-API
this	O	O
approach	O	O
all	O	B-API
together	O	O
.	O	O

For	O	O
a	O	O
generalized	O	O
scenario	O	O
where	O	B-API
there	O	O
are	O	O
many	O	O
different	O	O
combinations	O	O
of	O	O
values	O	B-API
under	O	O
'	O	O
COL1	O	O
'	O	O
and	O	O
'	O	O
COL3	O	O
'	O	O
,	O	O
this	O	O
works	O	O
but	O	O
is	O	O
probably	O	O
not	O	O
nearly	O	O
as	O	O
efficient	O	O
as	O	O
it	O	O
can	O	O
be	O	O
:	O	O
#CODE	O	O

Similarly	O	O
in	O	O
your	O	O
example	O	O
where	O	B-API
you	O	O
plot	O	B-API
`	O	O
col1	O	O
,	O	O
col2	O	O
`	O	O
differently	O	O
based	O	O
on	O	O
`	O	O
col3	O	O
`	O	O
,	O	O
what	O	O
if	O	O
there	O	O
are	O	O
NA	O	O
values	O	B-API
that	O	O
break	O	O
the	O	O
association	O	O
between	O	B-API
`	O	O
col1	O	O
,	O	O
col2	O	O
,	O	O
col3	O	O
`	O	O
?	O	O

For	O	O
example	O	O
,	O	O
I	O	O
want	O	O
to	O	O
take	O	B-API
values	O	B-API
from	O	O
`	O	O
col_3	O	O
`	O	O
and	O	O
`	O	O
col_4	O	O
`	O	O
and	O	O
use	O	B-API
them	O	O
to	O	O
generate	O	O
a	O	O
single	O	O
values	O	B-API
.	O	O

The	O	O
speed	O	O
difference	O	B-API
is	O	O
astonishing	O	O
.	O	O

The	O	O
summation	O	O
in	O	O
one	O	O
group	O	B-API
won't	O	O
reduce	O	B-API
the	O	O
size	O	B-API
of	O	O
the	O	O
result	O	O
,	O	O
the	O	O
summation	O	O
I	O	O
want	O	O
to	O	O
do	O	O
is	O	O
across	O	O
different	O	O
groups	O	B-API
.	O	O

If	O	O
you	O	O
really	O	O
prefer	O	O
`	O	O
1	O	O
`'	O	O
s	O	O
and	O	O
`	O	O
0	O	O
`'	O	O
s	O	O
replace	O	B-API
the	O	O
last	O	B-API
line	O	O
with	O	O
:	O	O
#CODE	O	O

So	O	O
traverse	O	O
the	O	O
data	O	B-API
once	O	O
and	O	O
generate	O	O
both	O	O
arrays	O	O
would	O	O
be	O	O
preferred	O	O
.	O	O

Im	O	O
not	O	O
fully	O	O
adjusted	O	O
to	O	O
how	O	O
Pandas	O	O
is	O	O
using	O	O
matplotlib	O	O
so	O	O
i	O	O
often	O	O
switch	O	O
to	O	O
matplotlib	O	O
myself	O	O
if	O	O
plots	O	O
get	O	B-API
more	O	O
complicated	O	O
,	O	O
eg	O	O
:	O	O
#CODE	O	O

The	O	O
table	O	B-API
that	O	O
gives	O	O
this	O	O
message	O	O
contains	O	B-API
a	O	O
few	O	O
columns	O	O
,	O	O
none	O	O
of	O	O
them	O	O
have	O	O
data	O	B-API
in	O	O
them	O	O
.	O	O

so	O	O
yes	O	O
later	O	O
i	O	O
have	O	O
open	O	B-API
the	O	O
file	O	O
but	O	O
thanks	O	O
to	O	O
pandas	O	O
i	O	O
can	O	O
use	O	B-API
the	O	O
`	O	O
chunksize	O	O
`	O	O
command	O	O
to	O	O
get	O	B-API
the	O	O
information	O	O
i	O	O
need	O	O
.	O	O

create	O	O
column	O	O
names	O	B-API
by	O	O
joining	O	O
two	O	O
labels	O	O
of	O	O
different	O	O
levels	O	O
with	O	O
pandas	O	O

@USER	O	O
so	O	O
how	O	O
should	O	O
i	O	O
write	O	O
it	O	O
so	O	O
that	O	O
the	O	O
program	O	O
gives	O	O
seq	O	O
to	O	O
'	O	O
Hsequence	O	O
'	O	O
column	O	O
when	O	O
'	O	O
Hcolumn	O	O
'	O	O
contains	O	B-API
the	O	O
title	O	B-API
from	O	O
fasta	O	O
file	O	O
?	O	O

Also	O	O
,	O	O
in	O	O
my	O	O
larger	O	O
directory	O	O
,	O	O
this	O	O
is	O	O
taking	O	O
forever	O	O
-	O	O
as	O	O
in	O	O
,	O	O
about	O	O
a	O	O
gig	O	O
of	O	O
CSVs	O	O
is	O	O
timing	O	O
out	O	O
for	O	O
me	O	O
(	O	O
by	O	O
my	O	O
hand	O	O
)	O	O
at	O	B-API
around	O	B-API
20	O	O
minutes	O	B-API
.	O	O

The	O	O
key	O	O
was	O	O
unstacking	O	O
the	O	O
data	O	B-API
first	O	B-API
:	O	O
#CODE	O	O

I	O	O
want	O	O
to	O	O
get	O	B-API
the	O	O
latitude	O	O
and	O	O
longitude	O	O
coordinates	O	O
for	O	O
any	O	B-API
one	O	O
of	O	O
the	O	O
columns	O	O
in	O	O
the	O	O
data	O	B-API
frame	O	O
below	O	O
.	O	O

Option	O	O
values	O	B-API
are	O	O
restored	O	O
automatically	O	O
when	O	O
you	O	O
exit	O	O
the	O	O
`	O	O
with	O	O
`	O	O
block	O	O
.	O	O

I	O	O
am	O	O
finding	O	O
difficulty	O	O
to	O	O
plot	O	B-API
reason	O	O
every	O	O
csv	O	O
file	O	O
starts	O	O
with	O	O
different	O	O
date	O	B-API
,	O	O
that's	O	O
the	O	O
reason	O	O
I	O	O
was	O	O
trying	O	O
to	O	O
convert	O	B-API
into	O	O
no	O	O
.	O	O
of	O	O
days	O	B-API
,	O	O
so	O	O
that	O	O
I	O	O
can	O	O
plot	O	B-API
all	O	B-API
in	O	O
one	O	O
go	O	O
with	O	O
starting	O	O
day	O	B-API
-	O	O
1	O	O
,	O	O
for	O	O
example	O	O
:	O	O
-	O	O
csv	O	O
file	O	O
2	O	O
fall	O	O
short	O	O
as	O	O
compared	O	O
to	O	O
csv	O	O
file	O	O
1	O	O
.	O	O

Most	O	O
of	O	O
the	O	O
time	O	B-API
you	O	O
can	O	O
get	O	B-API
away	O	O
with	O	O
using	O	O
something	O	O
else	O	O
...	O	O

In	O	O
that	O	O
case	O	O
the	O	O
index	O	B-API
is	O	O
composed	O	O
of	O	O
integers	O	O
from	O	O
0	O	O
to	O	O
n	O	O
:	O	O
#CODE	O	O

You	O	O
have	O	O
a	O	O
difference	O	B-API
between	O	B-API
a	O	O
mac	O	O
and	O	O
a	O	O
pc	O	O
,	O	O
and	O	O
*	O	O
presumably	O	O
*	O	O
the	O	O
same	O	O
code	O	O
.	O	O

Suppose	O	O
you	O	O
want	O	O
to	O	O
find	O	B-API
the	O	O
row	O	O
or	O	O
rows	O	O
where	O	B-API
`	O	O
beef	O	O
`	O	O
production	O	O
was	O	O
the	O	O
highest	O	O
.	O	O

The	O	O
number	O	O
of	O	O
columns	O	O
may	O	O
differ	O	O
and	O	O
so	O	O
does	O	O
the	O	O
column	O	O
names	O	B-API
.	O	O

How	O	O
do	O	O
I	O	O
avoid	O	O
that	O	O
and	O	O
rather	O	O
generate	O	O
it	O	O
in	O	O
a	O	O
sparse	O	O
matrix	O	B-API
CSR	O	O
format	O	B-API
?	O	O

I	O	O
download	O	O
and	O	O
scrape	O	O
a	O	O
webpage	O	O
for	O	O
some	O	O
data	O	B-API
in	O	O
TSV	O	O
format	O	B-API
.	O	O

You	O	O
can	O	O
set	O	B-API
parameter	O	O
`	O	O
labels=False	O	O
`	O	O
to	O	O
get	O	B-API
the	O	O
integer	O	O
representation	O	O
#CODE	O	O

it's	O	O
not	O	O
too	O	O
much	O	O
of	O	O
a	O	O
stretch	O	O
to	O	O
insert	O	B-API
NaN's	O	O
into	O	O
the	O	O
data	O	B-API
using	O	O
reindexing	O	O
so	O	O
that	O	O
i	O	O
get	O	B-API
this	O	O
:	O	O
#CODE	O	O

Any	O	O
suggestions	O	O
?	O	O

Data-driven	O	O
DOM	O	O
manipulation	O	O
(	O	O
maybe	O	O
the	O	O
hardest	O	O
thing	O	O
to	O	O
wrap	O	B-API
one's	O	O
head	O	B-API
around	O	B-API
):	O	O
your	O	O
data	O	B-API
gets	O	O
transformed	O	B-API
into	O	O
DOM	O	O
elements	O	O
.	O	O

Your	O	O
regex	O	O
is	O	O
matching	O	O
on	O	O
all	O	B-API
`	O	O
-	O	O
`	O	O
characters	O	O
:	O	O
#CODE	O	O

1	O	O
)	O	O
create	O	O
additional	O	O
columns	O	O
with	O	O
clock	O	O
time	O	B-API
headings	O	O
for	O	O
5	O	O
minute	O	B-API
intervals	O	O
between	O	B-API
9:30	O	O
and	O	O
4:00	O	O
pm	O	O
,	O	O
so	O	O
the	O	O
headings	O	O
of	O	O
the	O	O
data	O	B-API
frame	O	O
look	O	O
like	O	O
:	O	O

`	O	O
Index	O	B-API
([	O	O
u'id	O	O
opinion	O	O
']	O	O
,	O	O
dtype=	O	O
'	O	O
object	O	O
')`	O	O
Thanks	O	O
for	O	O
the	O	O
response	O	O

The	O	O
end	O	O
product	O	B-API
would	O	O
be	O	O
ten	O	O
timeseries	O	O
plots	O	O
with	O	O
charted	O	O
lines	O	B-API
over	O	B-API
time	O	B-API
for	O	O
each	O	O
TID	O	O
.	O	O

And	O	O
get	O	B-API
the	O	O
result	O	O
:	O	O
#CODE	O	O

However	O	O
,	O	O
I	O	O
still	O	O
don't	O	O
get	O	B-API
why	O	O
`	O	O
iconv	O	O
`	O	O
messes	O	O
it	O	O
up	O	O
.	O	O

If	O	O
you	O	O
have	O	O
huge	O	O
CSV	O	O
data	O	B-API
,	O	O
NYSOL's	O	O
mcmd	O	O
is	O	O
the	O	O
best	O	O
.	O	O

I	O	O
get	O	B-API
#CODE	O	O

If	O	O
I	O	O
use	O	B-API
a	O	O
tweaked	O	O
version	O	O
of	O	O
@USER	O	O
'	O	O
s	O	O
suggestion	O	O
below	O	O
,	O	O
I	O	O
get	O	B-API
this	O	O
error	O	O
:	O	O
#CODE	O	O

ValueError	O	O
:	O	O
Unknown	O	O
format	O	B-API
code	O	O
'	O	O
f	O	B-API
'	O	O
for	O	O
object	O	O
of	O	O
type	O	O
'	O	O
str	O	B-API
'	O	O
-	O	O
why	O	O
do	O	O
I	O	O
get	O	B-API
this	O	O
the	O	O
second	O	B-API
time	O	B-API
but	O	O
not	O	O
the	O	O
first	O	B-API
time	O	B-API
?	O	O

Any	O	O
suggestion	O	O
about	O	O
the	O	O
reason	O	O
?	O	O

I	O	O
have	O	O
a	O	O
data	O	B-API
set	O	B-API
which	O	O
has	O	O
multiple	O	O
columns	O	O
,	O	O
strings	O	O
and	O	O
integers	O	O

is	O	O
the	O	O
condition	O	O
,	O	O
returning	O	O
a	O	O
booleans	O	O
array	O	B-API
of	O	O
True	O	O
/	O	O
False	O	O
for	O	O
all	O	B-API
values	O	B-API
meeting	O	O
the	O	O
condition	O	O
or	O	O
not	O	O
,	O	O
and	O	O
then	O	O
the	O	O
corresponding	O	O
A	O	O
values	O	B-API
are	O	O
selected	O	O

I	O	O
fixed	O	O
this	O	O
bug	O	O
in	O	O
0.11-dev	O	O
in	O	O
any	O	B-API
event	O	O
,	O	O
see	O	O
here	O	O
:	O	O
#URL	O	O
thanks	O	O
!	O	O

To	O	O
split	O	B-API
`	O	O
my_data2	O	O
`	O	O
into	O	O
two	O	O
arrays	O	O
of	O	O
roughly	O	O
equal	O	B-API
size	O	B-API
:	O	O
#CODE	O	O

to	O	O
get	O	B-API
a	O	O
`	O	O
Series	O	B-API
`	O	O
of	O	O
`	O	O
list	O	B-API
`	O	O
s	O	O
of	O	O
strings	O	O
.	O	O

For	O	O
example	O	O
,	O	O
you	O	O
can't	O	O
sum	O	B-API
a	O	O
mix	O	O
of	O	O
strings	O	O
and	O	O
floats	O	O
in	O	O
pandas	O	O
but	O	O
Excel	O	O
would	O	O
silently	O	O
drop	O	B-API
the	O	O
string	O	O
value	O	O
and	O	O
sum	O	B-API
the	O	O
floats	O	O
.	O	O

Notice	O	O
how	O	O
the	O	O
values	O	B-API
in	O	O
the	O	O
second	O	B-API
column	O	O
are	O	O
no	O	O
longer	O	O
integers	O	O
,	O	O
as	O	O
they	O	O
were	O	O
originally	O	O
.	O	O

I	O	O
have	O	O
a	O	O
large	O	O
but	O	O
very	O	O
sparse	O	O
matrix	O	B-API
(	O	O
50,000	O	O
rows*	O	O
100,000	O	O
columns	O	O
,	O	O
only	O	O
10%	O	O
of	O	O
the	O	O
values	O	B-API
are	O	O
known	O	O
)	O	O
.	O	O

In	O	O
python	O	O
normally	O	O
you	O	O
don't	O	O
need	O	O
and	O	O
you	O	O
shouldn't	O	O
use	O	B-API
a	O	O
semicolon	O	O
at	O	B-API
the	O	O
end	O	O
of	O	O
the	O	O
line	O	O
.	O	O

That's	O	O
all	O	B-API
data	O	B-API
python	O	O
is	O	O
reading	O	O
in	O	O
,	O	O
apparently	O	O
:	O	O
the	O	O
16	O	O
first	O	B-API
lines	O	B-API
,	O	O
or	O	O
at	O	B-API
least	O	O
I	O	O
am	O	O
not	O	O
able	O	O
to	O	O
get	O	B-API
the	O	O
rest	O	O
of	O	O
data	O	B-API
in	O	O
.	O	O

The	O	O
problem	O	O
is	O	O
to	O	O
find	O	B-API
average	O	B-API
values	O	B-API
of	O	O
temp1	O	O
,	O	O
temp2	O	O
and	O	O
temp3	O	O
for	O	O
a	O	O
period	O	O
of	O	O
time	O	B-API
(	O	O
say	O	O
,	O	O
2	O	O
days	O	B-API
)	O	O
over	O	B-API
the	O	O
same	O	O
intervals	O	O
(	O	O
for	O	O
that	O	O
example	O	O
-	O	O
15	O	O
minutes	O	B-API
)	O	O
.	O	O

In	O	O
generally	O	O
I	O	O
wonder	O	O
if	O	O
pandas	O	O
should	O	O
not	O	O
at	O	B-API
least	O	O
throw	O	O
a	O	O
warning	O	O
,	O	O
afterall	O	O
broadcasting	O	O
the	O	O
result	O	O
to	O	O
both	O	O
columns	O	O
should	O	O
be	O	O
almost	O	O
never	O	O
what	O	O
is	O	O
wanted	O	O
.	O	O

I	O	O
get	O	B-API
pandas	O	O
error	O	O
when	O	O
I	O	O
try	O	O
to	O	O
read	O	O
HDF5	O	O
format	O	B-API
files	O	O
that	O	O
I	O	O
have	O	O
created	O	O
with	O	O
h5py	O	O
.	O	O

Additionally	O	O
you	O	O
can	O	O
use	O	B-API
numpys	O	O
matrix	O	B-API
#CODE	O	O

I	O	O
updated	O	O
pandas	O	O
'	O	O
sudo	O	O
pip	O	O
install	O	O
--	O	O
upgrade	O	O
pandas	O	O
'	O	O
,	O	O
between	O	B-API
both	O	O
of	O	O
these	O	O
fixes	O	O
,	O	O
everything	O	O
worked	O	O
.	O	O

Sorry	O	O
can't	O	O
reproduce	O	O
nor	O	O
understand	O	O
your	O	O
real	O	B-API
problem	O	O
,	O	O
please	O	O
post	O	O
what	O	O
you	O	O
see	O	O
in	O	O
your	O	O
question	O	O

When	O	O
I	O	O
used	O	O
'	O	O
ethnicity	O	O
'	O	O
or	O	O
'	O	O
veteran	O	O
'	O	O
as	O	O
a	O	O
value	O	O
my	O	O
results	O	O
came	O	O
out	O	O
really	O	O
strange	O	O
and	O	O
didn't	O	O
match	O	B-API
my	O	O
value	O	O
counts	O	O
numbers	O	O
.	O	O

`	O	O
post_start	O	O
`	O	O
is	O	O
the	O	O
date	O	B-API
that	O	O
the	O	O
employee	O	O
started	O	O
in	O	O
the	O	O
post	O	O
,	O	O
and	O	O
`	O	O
change_date	O	O
`	O	O
is	O	O
the	O	O
date	O	B-API
that	O	O
the	O	O
post	O	O
title	O	B-API
was	O	O
changed	O	B-API
.	O	O

How	O	O
do	O	O
I	O	O
replace	O	B-API
the	O	O
ints	O	O
with	O	O
the	O	O
float	O	O
values	O	B-API
from	O	O
another	O	O
column	O	O
(	O	O
by	O	O
same	O	O
row	O	O
)	O	O
,	O	O
but	O	O
leave	O	O
all	O	B-API
the	O	O
nulls	O	O
?	O	O

There	O	O
may	O	O
be	O	O
a	O	O
more	O	O
foolproof	O	O
,	O	O
cleaner	O	O
way	O	O
of	O	O
computing	O	O
date	O	B-API
time	O	B-API
differences	O	O
in	O	O
pandas	O	O
.	O	O

However	O	O
,	O	O
to	O	O
get	O	B-API
the	O	O
row	O	O
sum	O	B-API
,	O	O
one	O	O
needs	O	O
to	O	O
specify	O	O
axis=1	O	O
.	O	O

Using	O	O
the	O	O
second	O	B-API
method	O	O
I	O	O
get	O	B-API
the	O	O
following	O	O
error	O	O
:	O	O
#CODE	O	O

Filter	O	O
data	O	B-API
to	O	O
get	O	B-API
only	O	O
first	O	B-API
day	O	B-API
of	O	O
the	O	O
month	O	B-API
rows	O	O

(	O	O
FYI	O	O
if	O	O
i	O	O
insert	O	B-API
a	O	O
print	O	O
print	O	O
(	O	O
vals	O	O
)	O	O
in	O	O
the	O	O
middle	O	O
of	O	O
that	O	O
loop	O	O
,	O	O
it	O	O
prints	O	O
#CODE	O	O

For	O	O
days	O	B-API
in	O	O
a	O	O
month	O	B-API
(	O	O
'	O	O
2015-07	O	O
'	O	O
say	O	O
)	O	O
You	O	O
could	O	O
change	O	O
#CODE	O	O

Doesnt	O	O
the	O	O
frame	O	O
variable	O	O
get	O	B-API
overwritten	O	O
during	O	O
each	O	O
iteration	O	O
in	O	O
the	O	O
loop	O	O
?	O	O

Any	O	O
other	O	O
advice	O	O
I	O	O
can	O	O
leverage	O	O
in	O	O
the	O	O
meantime	O	O
?	O	O

If	O	O
`	O	O
Change	O	O
Closing	O	O
Date	O	O
`	O	O
is	O	O
True	O	O
,	O	O
I	O	O
would	O	O
like	O	O
to	O	O
add	O	B-API
`	O	O
Closing	O	O
Date2	O	O
`	O	O
column	O	O
into	O	O
my	O	O
new	O	O
column	O	O
with	O	O
adding	O	O
1	O	O
year	O	B-API
.	O	O

If	O	O
you	O	O
REALLY	O	O
want	O	O
to	O	O
get	O	B-API
by	O	O
a	O	O
group	O	B-API
individually	O	O
#CODE	O	O

but	O	O
I	O	O
get	O	B-API
the	O	O
error	O	O
:	O	O
#CODE	O	O

I	O	O
am	O	O
new	O	O
to	O	O
pandas	O	O
for	O	O
data	O	B-API
analysis	O	O
and	O	O
I	O	O
just	O	O
installed	O	O
pandas	O	O
with	O	O
required	O	O
dependencies	O	O
(	O	O
NumPy	O	O
,	O	O
python-dateutil	O	O
,	O	O
pytz	O	O
,	O	O
numexpr	O	O
,	O	O
bottleneck	O	O
and	O	O
matplotlib	O	O
)	O	O
.	O	O

What	O	O
do	O	O
you	O	O
get	O	B-API
if	O	O
you	O	O
print	O	O
that	O	O
?	O	O

Can't	O	O
you	O	O
use	O	B-API
sets	O	O
and	O	O
intersections	O	O
?	O	O

is	O	O
there	O	O
a	O	O
way	O	O
to	O	O
insert	O	B-API
`	O	O
s	O	O
`	O	O
into	O	O
`	O	O
df	O	O
`	O	O
without	O	O
creating	O	O
a	O	O
reindexed	O	O
copy	O	B-API
of	O	O
`	O	O
df	O	O
`	O	O
first	O	B-API
?	O	O

I'm	O	O
using	O	O
python	O	O
2.7.5	O	O
(	O	O
with	O	O
all	O	B-API
the	O	O
packages	O	O
in	O	O
the	O	O
python	O	O
(	O	O
x	O	O
,	O	O
y	O	O
)	O	O
bundle	O	O
)	O	O
,	O	O
and	O	O
running	O	O
files	O	O
from	O	O
the	O	O
command	O	O
prompt	O	O
.	O	O

Any	O	O
suggestions	O	O
??	O	O

This	O	O
will	O	O
never	O	O
get	O	B-API
the	O	O
similar	O	O
graph	O	O
as	O	O
the	O	O
kernel	O	O
estimate	O	O
base	O	B-API
of	O	O
the	O	O
original	O	O
data	O	B-API
,	O	O
result	O	O
:	O	O

The	O	O
working	O	O
version	O	O
I	O	O
have	O	O
is	O	O
this	O	O
one	O	O
,	O	O
but	O	O
I	O	O
feel	O	O
there	O	O
is	O	O
potential	O	O
for	O	O
improvement	O	O
,	O	O
as	O	O
I	O	O
find	O	B-API
my	O	O
solution	O	O
unreadable	O	O
and	O	O
I	O	O
am	O	O
unsure	O	O
about	O	O
how	O	O
it	O	O
would	O	O
generalize	O	O
to	O	O
multiindexes	O	O
#CODE	O	O

Also	O	O
,	O	O
once	O	O
you	O	O
get	O	B-API
to	O	O
15	O	O
points	O	O
,	O	O
you'll	O	O
be	O	O
able	O	O
to	O	O
upvote	O	O
as	O	O
well	O	O
.	O	O

You	O	O
can	O	O
then	O	O
get	O	B-API
the	O	O
last	O	B-API
first	O	B-API
value	O	O
by	O	O
forward	O	B-API
filling	O	O
`	O	O
first_values	O	O
`	O	O
,	O	O
reindexing	O	O
like	O	O
`	O	O
second_values	O	O
`	O	O
,	O	O
stacking	O	O
again	O	O
and	O	O
indexing	O	O
into	O	O
the	O	O
result	O	O
using	O	O
the	O	O
original	O	O
`'	O	O
time	O	B-API
'	O	O
,	O	O
'	O	O
second	O	B-API
'`	O	O
pairs	O	O
:	O	O
#CODE	O	O

how	O	O
do	O	O
i	O	O
avoid	O	O
creating	O	O
so	O	O
many	O	O
variables	O	O
as	O	O
I	O	O
add	O	B-API
columns	O	O
together	O	O
?	O	O

Any	O	O
suggestion	O	O
on	O	O
how	O	O
to	O	O
efficiently	O	O
achieve	O	O
this	O	O
?	O	O

I	O	O
get	O	B-API
:	O	O
#CODE	O	O

For	O	O
instance	O	O
,	O	O
I	O	O
can	O	O
compute	O	O
the	O	O
value	O	O
for	O	O
data	O	B-API
record	O	B-API
3	O	O
by	O	O
taking	O	O
`	O	O
len	O	B-API
(	O	O
set	O	B-API
([	O	O
4	O	O
,	O	O
4	O	O
,	O	O
6	O	O
,	O	O
12	O	O
]))`	O	O
which	O	O
gives	O	O
3	O	O
.	O	O

@USER	O	O
That's	O	O
a	O	O
great	O	O
suggestion	O	O
(	O	O
for	O	O
some	O	O
use-cases	O	O
)	O	O
it	O	O
should	O	O
be	O	O
its	O	O
own	O	O
answer	O	O
(	O	O
so	O	O
I	O	O
can	O	O
upvote	O	O
it	O	O
)	O	O
Though	O	O
it	O	O
does	O	O
need	O	O
tweak	O	O
to	O	O
multiply	O	B-API
by	O	O
100	O	O
.	O	O

python	O	O
how	O	O
to	O	O
sum	O	B-API
together	O	O
all	O	B-API
values	O	B-API
within	O	O
a	O	O
time	O	B-API
interval	O	O
in	O	O
datetime64	O	O
?	O	O

was	O	O
trying	O	O
to	O	O
do	O	O
a	O	O
"	O	O
for	O	O
i	O	O
in	O	O
range	O	O
(	O	O
len	O	B-API
(	O	O
results	O	O
))"	O	O
before	O	O
the	O	O
"	O	O
for	O	O
item	O	B-API
in	O	O
results	O	O
[	O	O
i	O	O
]"	O	O
that	O	O
you	O	O
did	O	O
but	O	O
not	O	O
working	O	O
for	O	O
me	O	O
...	O	O

But	O	O
,	O	O
on	O	O
the	O	O
other	O	O
hand	O	O
,	O	O
if	O	O
your	O	O
columns	O	O
aren't	O	O
in	O	O
the	O	O
same	O	O
order	O	B-API
,	O	O
then	O	O
my	O	O
suggestion	O	O
won't	O	O
work	O	O
.	O	O

When	O	O
I	O	O
execute	O	O
the	O	O
program	O	O
for	O	O
the	O	O
data	O	B-API
of	O	O
the	O	O
same	O	O
day	O	B-API
,	O	O
processor	O	O
time	O	B-API
becomes	O	O
long	O	O
from	O	O
the	O	O
same	O	O
point	O	O
.	O	O

I'm	O	O
new	O	O
to	O	O
pandas	O	O
,	O	O
python	O	O
,	O	O
and	O	O
scripting	O	O
in	O	O
general	O	O
,	O	O
so	O	O
am	O	O
still	O	O
getting	O	O
my	O	O
head	O	B-API
around	O	B-API
the	O	O
basics	O	O
.	O	O

You	O	O
can	O	O
,	O	O
for	O	O
example	O	O
,	O	O
use	O	B-API
interpolation	O	O
to	O	O
get	O	B-API
equally	O	O
spaced	O	O
datapoints	O	O
out	O	O
off	O	O
your	O	O
timeseries	O	O
.	O	O

What	O	O
I	O	O
was	O	O
hoping	O	O
for	O	O
was	O	O
to	O	O
add	O	B-API
up	O	O
all	O	B-API
of	O	O
the	O	O
frequencies	O	O
across	O	O
the	O	O
websites	O	O
and	O	O
to	O	O
create	O	O
two	O	O
columns	O	O
:	O	O
Column	O	O
A	O	O
with	O	O
the	O	O
word	O	O
,	O	O
and	O	O
Column	O	O
B	O	O
with	O	O
all	O	B-API
of	O	O
the	O	O
frequencies	O	O
added	O	O
together	O	O
.	O	O

It	O	O
does	O	O
not	O	O
work	O	O
without	O	O
dropping	O	O
index	O	B-API
.	O	O

Now	O	O
I	O	O
was	O	O
wondering	O	O
how	O	O
I	O	O
could	O	O
subtract	O	B-API
my	O	O
multi-year	O	O
timeseries	O	O
from	O	O
this	O	O
standard	O	O
year	O	B-API
,	O	O
in	O	O
order	O	B-API
to	O	O
get	O	B-API
a	O	O
timeseries	O	O
that	O	O
show	O	B-API
which	O	O
days	O	B-API
were	O	O
below	O	O
or	O	O
above	O	O
it's	O	O
standard	O	O
.	O	O

I	O	O
may	O	O
try	O	O
installing	O	O
an	O	O
older	O	O
version	O	O
to	O	O
find	O	B-API
out	O	O
what	O	O
was	O	O
actually	O	O
getting	O	O
calculated	O	O
.	O	O

Is	O	O
there	O	O
any	O	B-API
disadvantage	O	O
?	O	O

The	O	O
length	O	O
of	O	O
the	O	O
frame	O	O
is	O	O
over	O	B-API
2	O	O
million	O	O
rows	O	O
and	O	O
looping	O	O
to	O	O
extract	O	B-API
the	O	O
elements	O	O
I	O	O
need	O	O
is	O	O
a	O	O
poor	O	O
choice	O	B-API
.	O	O

edit	O	O
I	O	O
believe	O	O
'	O	O
endog	O	O
'	O	O
as	O	O
defined	O	O
is	O	O
incorrect-I	O	O
should	O	O
be	O	O
passing	O	O
the	O	O
values	O	B-API
for	O	O
which	O	O
I	O	O
want	O	O
to	O	O
predict	O	O
;	O	O
therefore	O	O
I've	O	O
created	O	O
a	O	O
date	O	B-API
range	O	O
of	O	O
12	O	O
periods	O	O
past	O	O
the	O	O
last	O	B-API
recorded	O	O
value	O	O
.	O	O

@USER	O	O
It	O	O
should	O	O
be	O	O
a	O	O
little	O	O
quicker	O	O
with	O	O
a	O	O
boolean	O	O
index	O	B-API
like	O	O
that	O	O
,	O	O
but	O	O
it	O	O
does	O	O
do	O	O
a	O	O
cast	O	O
(	O	O
timedelta	O	O
)	O	O
so	O	O
I'm	O	O
not	O	O
100%	O	O
sure	O	O
on	O	O
that	O	O
.	O	O

I	O	O
still	O	O
get	O	B-API
the	O	O
same	O	O
TypeError	O	O
message	O	O
using	O	O
the	O	O
line	O	O
you	O	O
suggest	O	O
.	O	O

Use	O	O
regex	O	O
with	O	O
`	O	O
python	O	O
`	O	O
engine	O	O
#CODE	O	O

(	O	O
it's	O	O
pretty	O	O
clear	O	B-API
that	O	O
`	O	O
id	O	O
`	O	O
maps	O	O
to	O	O
`	O	O
individual	O	O
`	O	O
,	O	O
but	O	O
I	O	O
would	O	O
clean	O	B-API
that	O	O
up	O	O
too	O	O
)	O	O
.	O	O

Being	O	O
able	O	O
to	O	O
quickly	O	O
determine	O	O
the	O	O
time	O	B-API
difference	O	B-API
between	O	B-API
Order	O	O
1	O	O
and	O	O
Order	O	O
2	O	O
(	O	O
per	O	O
PersonID	O	O
)	O	O
would	O	O
be	O	O
great	O	O
too	O	O
.	O	O

Thus	O	O
,	O	O
if	O	O
there	O	O
is	O	O
an	O	O
update	O	B-API
to	O	O
some	O	O
value	O	O
on	O	O
a	O	O
memory	O	O
page	O	O
,	O	O
that	O	O
page	O	O
is	O	O

and	O	O
make	O	O
this	O	O
a	O	O
Series	O	B-API
,	O	O
mapping	O	O
names	O	B-API
to	O	O
their	O	O
respective	O	O
numbers	O	O
:	O	O
#CODE	O	O

That	O	O
is	O	O
,	O	O
for	O	O
each	O	O
second	O	B-API
there	O	O
is	O	O
a	O	O
value	O	O
and	O	O
they	O	O
should	O	O
not	O	O
be	O	O
averaged	O	O
,	O	O
just	O	O
grouped	O	O
together	O	O
to	O	O
a	O	O
new	O	O
series	O	O
..	O	O

Specifically	O	O
,	O	O
in	O	O
this	O	O
case	O	O
,	O	O
I'd	O	O
only	O	O
like	O	O
to	O	O
drop	O	B-API
row	O	O
with	O	O
Indices	O	O
'	O	O
1991-12-31	O	O
'	O	O
and	O	O
'	O	O
1992-01-31	O	O
'	O	O
.	O	O

Or	O	O
read	O	O
it	O	O
in	O	O
directly	O	O
as	O	O
a	O	O
csv	O	O
,	O	O
by	O	O
appending	O	O
'	O	O
na	O	O
'	O	O
to	O	O
the	O	O
list	O	B-API
of	O	O
values	O	B-API
to	O	O
be	O	O
considered	O	O
NaN	O	O
:	O	O
#CODE	O	O

I	O	O
fail	O	O
to	O	O
see	O	O
the	O	O
corelation	O	O
between	O	B-API
"	O	O
John	O	O
"	O	O
and	O	O
the	O	O
dates	O	B-API
in	O	O
the	O	O
target	O	O
.	O	O

I	O	O
get	O	B-API
:	O	O

The	O	O
question	O	O
is	O	O
,	O	O
how	O	O
can	O	O
I	O	O
remove	O	B-API
or	O	O
filter	O	B-API
out	O	O
all	O	B-API
entries	O	O
that	O	O
have	O	O
frequency	O	O
1	O	O
?	O	O

For	O	O
all	O	B-API
the	O	O
other	O	O
names	O	B-API
that	O	O
are	O	O
not	O	O
in	O	O
the	O	O
top	O	O
ten	O	O
frequencies	O	O
I	O	O
want	O	O
to	O	O
combine	O	B-API
their	O	O
number	O	O
of	O	O
occurences	O	O
together	O	O
under	O	O
say	O	O
the	O	O
name	O	B-API
"	O	O
other	O	O
"	O	O
.	O	O

You	O	O
should	O	O
get	O	B-API
the	O	O
following	O	O
result	O	O
:	O	O

Which	O	O
indeed	O	O
is	O	O
longer	O	O
(	O	O
50	O	O
)	O	O
than	O	O
my	O	O
number	O	O
of	O	O
columns	O	O
/	O	O
indices	O	B-API
(	O	O
25	O	O
)	O	O
.	O	O

I	O	O
am	O	O
new	O	O
to	O	O
Python	O	O
(	O	O
and	O	O
programming	O	O
in	O	O
general	O	O
!	O	O
)	O	O
,	O	O
trying	O	O
to	O	O
conduct	O	O
some	O	O
data	O	B-API
analysis	O	O
using	O	O
Pandas	O	O
.	O	O

I	O	O
would	O	O
like	O	O
to	O	O
combine	O	B-API
these	O	O
columns	O	O
into	O	O
start	O	O
time	O	B-API
(	O	O
index	O	B-API
)	O	O
and	O	O
length	O	O
in	O	O
actual	O	O
seconds	O	B-API
.	O	O

I'm	O	O
looking	O	O
to	O	O
find	O	B-API
,	O	O
for	O	O
each	O	O
Census	O	O
Block	O	O
centroid	O	O
,	O	O
the	O	O
distance	O	O
to	O	O
it's	O	O
closest	O	B-API
restaurant	O	O
.	O	O

You	O	O
will	O	O
get	O	B-API
the	O	O
exception	O	O
"	O	O
appended	O	O
items	O	O
do	O	O
not	O	O
match	O	B-API
existing	O	O
items	O	O
in	O	O
table	O	B-API
!	O	O

Honestly	O	O
-	O	O
we	O	O
were	O	O
going	O	O
to	O	O
originally	O	O
do	O	O
visualizations	O	O
with	O	O
it	O	O
(	O	O
heatmaps	O	O
)	O	O
-	O	O
but	O	O
for	O	O
a	O	O
lot	O	O
of	O	O
reasons	O	O
we're	O	O
now	O	O
going	O	O
to	O	O
use	O	B-API
D3	O	O
...	O	O

For	O	O
example	O	O
,	O	O
if	O	O
I	O	O
say	O	O
year	O	B-API
,	O	O
the	O	O
entire	O	O
column	O	O
needs	O	O
to	O	O
be	O	O
appended	O	O
into	O	O
a	O	O
list	O	B-API
like	O	O
[	O	O
1	O	O
year	O	B-API
,	O	O
3	O	O
minutes	O	B-API
,	O	O
2	O	O
hours	O	B-API
]	O	O
.	O	O

Anyone	O	O
have	O	O
any	O	B-API
suggestions	O	O
for	O	O
how	O	O
to	O	O
accomplish	O	O
this	O	O
?	O	O

Yeah	O	O
I	O	O
know	O	O
it	O	O
gives	O	O
NaN	O	O
padding	O	O
,	O	O
but	O	O
only	O	O
on	O	O
the	O	O
indices	O	B-API
the	O	O
joining	O	O
is	O	O
done	O	O
over	O	B-API
.	O	O

The	O	O
paired	O	O
measurements	O	O
should	O	O
have	O	O
the	O	O
same	O	O
month	O	B-API
,	O	O
just	O	O
different	O	O
years	O	O
.	O	O

You	O	O
can	O	O
get	O	B-API
started	O	O
on	O	O
debugging	O	O
this	O	O
by	O	O
just	O	O
adding	O	O
a	O	O
line	O	O
to	O	O
your	O	O
code	O	O
and	O	O
running	O	O
again	O	O
:	O	O
#CODE	O	O

When	O	O
I	O	O
run	O	O
the	O	O
solution	O	O
I	O	O
get	O	B-API
the	O	O
error	O	O
.	O	O

Then	O	O
let's	O	O
add	O	B-API
a	O	O
helper	O	O
column	O	O
,	O	O
called	O	O
Safe	O	O
,	O	O
that	O	O
will	O	O
be	O	O
a	O	O
concatenation	O	O
of	O	O
all	O	B-API
the	O	O
Safex	O	O
columns	O	O
.	O	O

product	O	B-API
1111	O	O
non-null	O	O
object	O	O

In	O	O
R	O	O
,	O	O
using	O	O
the	O	O
car	O	O
package	O	O
,	O	O
there	O	O
is	O	O
a	O	O
useful	O	O
function	O	B-API
`	O	O
some	O	O
(	O	O
x	O	O
,	O	O
n	O	O
)`	O	O
which	O	O
is	O	O
similar	O	O
to	O	O
head	O	B-API
but	O	O
selects	O	O
,	O	O
in	O	O
this	O	O
example	O	O
,	O	O
10	O	O
rows	O	O
at	O	B-API
random	O	B-API
from	O	O
x	O	O
.	O	O

The	O	O
separator	O	O
(	O	O
between	O	B-API
cells	O	O
)	O	O
is	O	O
defined	O	O
by	O	O
the	O	O
operating	O	O
system	O	O
(	O	O
at	O	B-API
least	O	O
under	O	O
Windows	O	O
)	O	O
,	O	O
and	O	O
when	O	O
the	O	O
system	O	O
wide	O	O
list	O	B-API
separator	O	O
differs	O	O
from	O	O
comma	O	O
,	O	O
pandas	O	O
(	O	O
or	O	O
anything	O	O
else	O	O
I	O	O
tried	O	O
)	O	O
cannot	O	O
determine	O	O
what	O	O
separator	O	O
should	O	O
be	O	O
used	O	O
.	O	O

Setting	O	O
up	O	O
a	O	O
histogram	O	B-API
with	O	O
a	O	O
range	O	O
and	O	O
an	O	O
appropriate	O	O
bin	O	O
size	O	B-API
is	O	O
an	O	O
unknown	O	O
.	O	O

Thanks	O	O
TravisJ	O	O
,	O	O
I	O	O
guess	O	O
I	O	O
was	O	O
just	O	O
struggling	O	O
to	O	O
get	O	B-API
the	O	O
(	O	O
...	O	O
something	O	O
involving	O	O
group	O	B-API
...	O	O
)	O	O
in	O	O
when	O	O
i	O	O
was	O	O
using	O	O
the	O	O
ax=fig1	O	O
....	O	O
method	O	O
.	O	O

I	O	O
am	O	O
optimising	O	O
the	O	O
span	O	O
of	O	O
an	O	O
exponential	O	B-API
moving	O	O
average	O	B-API
and	O	O
the	O	O
number	O	O
of	O	O
lagged	O	O
variables	O	O
that	O	O
I	O	O
use	O	B-API
in	O	O
the	O	O
regression	O	O
.	O	O

The	O	O
error	O	O
message	O	O
that	O	O
I	O	O
get	O	B-API
is	O	O
:	O	O
#CODE	O	O

It	O	O
doesn't	O	O
however	O	O
take	O	B-API
advantage	O	O
of	O	O
the	O	O
psql	O	O
package	O	O
in	O	O
Pandas	O	O
.	O	O

On	O	O
a	O	O
much	O	O
larger	O	O
data	O	B-API
set	O	B-API
,	O	O
this	O	O
runs	O	O
in	O	O
790	O	O
ms	O	O
compared	O	O
to	O	O
1345	O	O
ms	O	O
for	O	O
ajcr's	O	O
and	O	O
Primer's	O	O
solutions	O	O
.	O	O

I've	O	O
put	O	B-API
together	O	O
one	O	O
approach	O	O
to	O	O
that	O	O
solution	O	O
that	O	O
should	O	O
scale	O	O
relatively	O	O
well	O	O
.	O	O

I	O	O
was	O	O
hoping	O	O
there	O	O
was	O	O
an	O	O
easy	O	O
way	O	O
to	O	O
get	O	B-API
the	O	O
set	O	B-API
of	O	O
B	O	O
values	O	B-API
per	O	O
each	O	O
A	O	O
value	O	O
like	O	O
`	O	O
{	O	O
'	O	O
one	O	O
'	O	O
:[	O	O
'	O	O
A	O	O
'	O	O
,	O	O
'	O	O
B	O	O
']	O	O
,	O	O
'	O	O
two	O	O
'	O	O
:[	O	O
'	O	O
A	O	O
']	O	O
,	O	O
'	O	O
three	O	O
'	O	O
:[	O	O
'	O	O
B	O	O
']	O	O
}	O	O
`	O	O
but	O	O
I	O	O
don't	O	O
see	O	O
anything	O	O
like	O	O
that	O	O
in	O	O
the	O	O
pandas	O	O
documentation	O	O

To	O	O
avoid	O	O
chained	O	O
indexing	O	O
,	O	O
you	O	O
need	O	O
to	O	O
get	O	B-API
all	O	B-API
your	O	O
conditions	O	O
into	O	O
a	O	O
single	O	O
set	O	B-API
of	O	O
brackets	O	O
.	O	O

But	O	O
trying	O	O
to	O	O
parse	O	B-API
the	O	O
column	O	O
name	O	B-API
and	O	O
hierarchy	O	O
and	O	O
auto-generate	O	O
the	O	O
insertable	O	O
thing	O	O
with	O	O
matching	O	O
index	O	B-API
is	O	O
unpleasant	O	O
.	O	O

The	O	O
seaborn	O	O
package	O	O
will	O	O
allow	O	O
you	O	O
to	O	O
plot	O	B-API
long	O	O
form	O	O
data	O	B-API
like	O	O
you	O	O
have	O	O
without	O	O
pivoting	O	O
but	O	O
pandas	O	O
requires	O	O
shared	O	O
index	O	B-API
and	O	O
one	O	O
column	O	O
per	O	O
plotted	O	O
line	O	O
by	O	O
default	O	O
so	O	O
your	O	O
solution	O	O
is	O	O
the	O	O
correct	O	O
one	O	O
.	O	O

Unable	O	O
to	O	O
filter	O	B-API
out	O	O
missing	O	O
(	O	O
NaN	O	O
)	O	O
location	O	O
data	O	B-API
while	O	O
using	O	O
Pandas	O	O
and	O	O
Geocoder	O	O
modules	O	O
in	O	O
Python	O	O

problem	O	O
is	O	O
the	O	O
sum	O	B-API
i	O	O
now	O	O
get	O	B-API
is	O	O
lined	O	O
up	O	O
in	O	O
week	O	B-API
intervals	O	O
but	O	O
not	O	O
in	O	O
the	O	O
right	O	O
sequence	O	O
.	O	O
this	O	O
wouldn't	O	O
be	O	O
a	O	O
problem	O	O
but	O	O
i	O	O
need	O	O
to	O	O
get	O	B-API
to	O	O
the	O	O
month	O	B-API
of	O	O
each	O	O
date	O	B-API
in	O	O
order	O	B-API
to	O	O
do	O	O
the	O	O
next	O	B-API
step	O	B-API
i	O	O
guess	O	O
.	O	O

How	O	O
could	O	O
I	O	O
sum	O	B-API
consecutive	O	O
day	O	B-API
values	O	B-API
here	O	O
,	O	O
so	O	O
I	O	O
would	O	O
get	O	B-API
something	O	O
like	O	O
this	O	O
?	O	O

I	O	O
changed	O	B-API
this	O	O
to	O	O
use	O	B-API
\t	O	O
as	O	O
the	O	O
separator	O	O
.	O	O

It's	O	O
possible	O	O
,	O	O
but	O	O
if	O	O
your	O	O
data	O	B-API
is	O	O
organized	O	O
it's	O	O
very	O	O
quick	O	O
with	O	O
shifting	O	O
it	O	O

@USER	O	O
fixed	O	O
,	O	O
was	O	O
a	O	O
typo	O	O
;	O	O
this	O	O
take	O	B-API
a	O	O
full	O	B-API
uri	O	O

Just	O	O
get	O	B-API
rid	O	O
of	O	O
it	O	O
and	O	O
reindent	O	O
the	O	O
loop	O	O
body	O	O
to	O	O
the	O	O
left	O	O
one	O	O
level	O	O
.	O	O

However	O	O
,	O	O
I	O	O
still	O	O
get	O	B-API
the	O	O
warning	O	O
.	O	O

For	O	O
any	O	B-API
x	O	O
in	O	O
dataset2	O	O
it	O	O
has	O	O
mapped	O	O
value	O	O
in	O	O
col2	O	O
.	O	O

but	O	O
you	O	O
then	O	O
need	O	O
to	O	O
store	O	O
these	O	O
dfs	O	O
somewhere	O	O
which	O	O
means	O	O
either	O	O
in	O	O
a	O	O
list	O	B-API
or	O	O
tuple	O	O
or	O	O
some	O	O
other	O	O
container	O	B-API
or	O	O
use	O	B-API
a	O	O
generator	O	O

and	O	O
so	O	O
on	O	O
for	O	O
the	O	O
remaining	O	O
location	O	O
categories	O	B-API
.	O	O

@USER	O	O
do	O	O
**	O	O
all	O	B-API
**	O	O
the	O	O
columns	O	O
in	O	O
the	O	O
DF	O	O
require	O	B-API
that	O	O
same	O	O
replacement	O	O
?	O	O

did	O	O
you	O	O
get	O	B-API
any	O	B-API
warnings	O	O
while	O	O
installing	O	O
numpy	O	O
or	O	O
pandas	O	O
?	O	O

This	O	O
`	O	O
df	O	O
`	O	O
consist	O	O
of	O	O
volume	O	O
observations	O	O
at	O	B-API
every	O	O
10	O	O
second	O	B-API
for	O	O
22	O	O
non-consecutive	O	O
days	O	B-API
.	O	O

I've	O	O
also	O	O
included	O	O
a	O	O
section	O	O
to	O	O
immediately	O	O
identify	O	O
any	O	B-API
redundant	O	O
genes	O	O
that	O	O
don't	O	O
have	O	O
any	O	B-API
SNPs	O	O
that	O	O
fall	O	O
within	O	O
their	O	O
range	O	O
.	O	O

Using	O	O
some	O	O
string	O	O
formatting	O	O
to	O	O
get	O	B-API
the	O	O
index	O	B-API
,	O	O
but	O	O
works	O	O
for	O	O
any	O	B-API
combination	O	O
of	O	O
months	O	O
(	O	O
as	O	O
long	O	O
as	O	O
the	O	O
first	O	B-API
month	O	B-API
is	O	O
explicitly	O	O
included	O	O
)	O	O
.	O	O

Any	O	O
suggestions	O	O
please	O	O
?	O	O

I	O	O
get	O	B-API
:	O	O
#CODE	O	O

I	O	O
understand	O	O
that	O	O
we	O	O
can	O	O
line	O	O
them	O	O
all	O	B-API
together	O	O
side	O	O
by	O	O
side	O	O
so	O	O
their	O	O
dates	O	B-API
match	O	B-API
and	O	O
loop	O	O
row	O	O
by	O	O
row	O	O
,	O	O
but	O	O
then	O	O
when	O	O
i	O	O
have	O	O
100k	O	O
different	O	O
securities	O	O
,	O	O
this	O	O
is	O	O
slow	O	B-API
in	O	O
memory	O	O
.	O	O

I	O	O
would	O	O
like	O	O
to	O	O
automate	O	O
this	O	O
table	O	B-API
so	O	O
If	O	O
I	O	O
change	O	O
my	O	O
parameters	O	O
in	O	O
my	O	O
code	O	O
,	O	O
I	O	O
get	O	B-API
a	O	O
new	O	O
table	O	B-API
with	O	O
that	O	O
new	O	O
data	O	B-API
.	O	O

But	O	O
I	O	O
get	O	B-API
,	O	O
which	O	O
I	O	O
cannot	O	O
understand	O	O
,	O	O
#CODE	O	O

Here's	O	O
the	O	O
product	O	B-API
:	O	O
#CODE	O	O

(	O	O
My	O	O
actual	O	O
problem	O	O
involves	O	O
parsing	O	O
strings	O	O
into	O	O
lists	O	O
,	O	O
then	O	O
checking	O	O
for	O	O
presents	O	O
of	O	O
a	O	O
1	O	O
or	O	O
0	O	O
in	O	O
one	O	O
list	O	B-API
and	O	O
if	O	O
so	O	O
marking	O	O
the	O	O
cosponsoring	O	O
element	O	O
in	O	O
the	O	O
other	O	O
list	O	B-API
with	O	O
a	O	O
asterix	O	O
,	O	O
but	O	O
I	O	O
didn't	O	O
want	O	O
to	O	O
put	O	B-API
that	O	O
in	O	O
my	O	O
example	O	O
and	O	O
it	O	O
is	O	O
long	O	O
and	O	O
harder	O	O
to	O	O
follow	O	O
.	O	O

What	O	O
is	O	O
the	O	O
error	O	O
you	O	O
get	O	B-API
?	O	O

So	O	O
first	O	B-API
chunk	O	O
is	O	O
stored	O	O
as	O	O
integer	O	O
and	O	O
in	O	O
second	O	B-API
chunk	O	O
gets	O	O
NaN	O	O
values	O	B-API
and	O	O
store	O	O
cannot	O	O
convert	O	B-API
NaN	O	O
to	O	O
integer	O	O

Just	O	O
play	O	O
around	O	B-API
with	O	O
it	O	O
to	O	O
get	O	B-API
it	O	O
right	O	O
.	O	O

I	O	O
get	O	B-API
the	O	O
following	O	O
error	O	O
:	O	O
#CODE	O	O

Edit	O	O
:	O	O
Here's	O	O
an	O	O
example	O	O
of	O	O
generating	O	O
a	O	O
close-enough	O	O
data	O	B-API
set	O	B-API
,	O	O
so	O	O
you	O	O
can	O	O
get	O	B-API
some	O	O
idea	O	O
of	O	O
what	O	O
I	O	O
mean	O	B-API
:	O	O
#CODE	O	O

@USER	O	O
that	O	O
means	O	O
you	O	O
have	O	O
non	O	O
string	O	O
values	O	B-API
mixed	O	O
in	O	O
;	O	O
you	O	O
need	O	O
to	O	O
specify	O	O
`	O	O
na=True	O	O
`	O	O
or	O	O
`	O	O
na=False	O	O
`	O	O
depending	O	O
on	O	O
what	O	O
those	O	O
values	O	B-API
are	O	O
.	O	O
see	O	O
my	O	O
edits	O	O
.	O	O

Preferably	O	O
,	O	O
use	O	B-API
Pandas	O	O
for	O	O
the	O	O
data	O	B-API
structure	O	O
and	O	O
Python	O	O
for	O	O
the	O	O
language	O	O
.	O	O

Then	O	O
as	O	O
in	O	O
the	O	O
first	O	B-API
point	O	O
,	O	O
I	O	O
would	O	O
like	O	O
to	O	O
calculate	O	O
the	O	O
number	O	O
of	O	O
continuous	O	O
up	O	O
and	O	O
down	O	O
sequences	O	O
from	O	O
the	O	O
previous	O	O
point	O	O
.	O	O

0	O	O
can	O	O
be	O	O
changed	O	B-API
to	O	O
1	O	O
or	O	O
other	O	O
values	O	B-API
later	O	O
in	O	O
the	O	O
code	O	O

and	O	O
in	O	O
the	O	O
instance	O	O
when	O	O
i	O	O
am	O	O
able	O	O
to	O	O
set	O	B-API
the	O	O
index	O	B-API
of	O	O
the	O	O
df	O	O
to	O	O
the	O	O
range	O	O
,	O	O
the	O	O
data	O	B-API
in	O	O
the	O	O
4	O	O
columns	O	O
change	O	O
to	O	O
NaN	O	O
since	O	O
they	O	O
have	O	O
no	O	O
data	O	B-API
that	O	O
matches	O	O
the	O	O
new	O	O
index	O	B-API
.	O	O

(	O	O
Note	O	O
that	O	O
this	O	O
produces	O	O
an	O	O
unrealistically	O	O
high	O	O
number	O	O
of	O	O
flooding	O	O
events	O	O
,	O	O
but	O	O
that's	O	O
just	O	O
because	O	O
of	O	O
how	O	O
the	O	O
sample	O	B-API
data	O	B-API
is	O	O
set	O	B-API
up	O	O
and	O	O
not	O	O
reflective	O	O
of	O	O
a	O	O
typical	O	O
pond	O	O
,	O	O
though	O	O
I'm	O	O
not	O	O
an	O	O
expert	O	O
on	O	O
pond	O	O
flooding	O	O
!	O	O
)	O	O
#CODE	O	O

What	O	O
output	O	O
do	O	O
you	O	O
get	O	B-API
from	O	O
this	O	O
?	O	O

`	O	O
Ideally	O	O
,	O	O
for	O	O
the	O	O
pages	O	O
that	O	O
have	O	O
multiple	O	O
groups	O	B-API
of	O	O
34	O	O
,	O	O
i'd	O	O
like	O	O
to	O	O
add	O	B-API
a	O	O
suffix	O	O
of	O	O
_1	O	O
,	O	O
_2	O	O
,	O	O
_3	O	O
,	O	O
etc	O	O
.	O	O

That	O	O
means	O	O
duplicating	O	O
values	O	B-API
from	O	O
cols	O	O
`	O	O
product_id	O	O
`	O	O
and	O	O
tem_name	O	O
`	O	O
as	O	O
long	O	O
as	O	O
there	O	O
are	O	O
items	O	O
in	O	O
list	O	B-API
`	O	O
prices	O	O
`	O	O
.	O	O

cool	O	B-API
,	O	O
but	O	O
I	O	O
get	O	B-API
a	O	O
syntax	O	O
error	O	O
for	O	O

problem	O	O
is	O	O
the	O	O
sum	O	B-API
i	O	O
now	O	O
get	O	B-API
is	O	O
lined	O	O
up	O	O
in	O	O
week	O	B-API
intervals	O	O
but	O	O
not	O	O
in	O	O
the	O	O
right	O	O
sequence	O	O
.	O	O
this	O	O
wouldn't	O	O
be	O	O
a	O	O
problem	O	O
but	O	O
i	O	O
need	O	O
to	O	O
get	O	B-API
to	O	O
the	O	O
month	O	B-API
of	O	O
each	O	O
date	O	B-API
in	O	O
order	O	B-API
to	O	O
do	O	O
the	O	O
next	O	B-API
step	O	B-API
i	O	O
guess	O	O
.	O	O

For	O	O
empty	O	B-API
date	O	B-API
cells	O	O
I	O	O
am	O	O
inserting	O	O
a	O	O
NaT	O	O
,	O	O
which	O	O
I	O	O
would	O	O
have	O	O
thought	O	O
would	O	O
be	O	O
fine	O	O
,	O	O
but	O	O
in	O	O
Oracle	O	O
that	O	O
is	O	O
becoming	O	O
some	O	O
weird	O	O
invalid	O	O
time	O	B-API
that	O	O
displays	O	O
as	O	O
"	O	O
0001-255-255	O	O
00:00	O	O
:	O	O
00	O	O
"	O	O
(	O	O
Something	O	O
like	O	O
MAXINT	O	O
or	O	O
0	O	O
being	O	O
converted	O	O
to	O	O
a	O	O
timestamp	O	O
I'm	O	O
guessing	O	O
?	O	O
)	O	O
#CODE	O	O

I	O	O
would	O	O
like	O	O
to	O	O
get	O	B-API
the	O	O
following	O	O
result	O	O
:	O	O
#CODE	O	O

so	O	O
in	O	O
all	O	B-API
both	O	O
suggestions	O	O
below	O	O
worked	O	O
for	O	O
me	O	O
:	O	O

I	O	O
get	O	B-API
the	O	O
following	O	O
error	O	O
message	O	O
:	O	O
#CODE	O	O

I	O	O
would	O	O
suggest	O	O
using	O	O
the	O	O
duplicated	O	B-API
method	O	O
on	O	O
the	O	O
Pandas	O	O
Index	O	B-API
itself	O	O
:	O	O
#CODE	O	O

I	O	O
would	O	O
like	O	O
to	O	O
group	O	B-API
the	O	O
x	O	O
values	O	B-API
into	O	O
equal	O	B-API
size	O	B-API
bins	O	O
,	O	O
and	O	O
for	O	O
each	O	O
bin	O	O
take	O	B-API
the	O	O
average	O	B-API
value	O	O
of	O	O
both	O	O
x	O	O
and	O	O
y	O	O
.	O	O

For	O	O
this	O	O
data	O	B-API
set	O	B-API
the	O	O
two	O	O
numbers	O	O
are	O	O
always	O	O
equal	O	B-API
.	O	O

Do	O	O
you	O	O
want	O	O
to	O	O
check	O	O
if	O	O
the	O	O
value	O	O
is	O	O
in	O	O
the	O	O
provided	O	O
bounds	O	O
and	O	O
return	O	O
a	O	O
boolean	O	O
True	O	O
/	O	O
False	O	O
array	O	B-API
,	O	O
or	O	O
you	O	O
want	O	O
to	O	O
represent	O	O
your	O	O
values	O	B-API
in	O	O
categories	O	B-API
represented	O	O
by	O	O
those	O	O
bounds	O	O
?	O	O

The	O	O
series	O	O
I'd	O	O
like	O	O
to	O	O
get	O	B-API
would	O	O
contain	O	O
:	O	O
#CODE	O	O

The	O	O
error	O	O
I	O	O
get	O	B-API
:	O	O
#CODE	O	O

How	O	O
do	O	O
you	O	O
deal	O	O
with	O	O
apparently	O	O
overlapping	O	O
date	O	B-API
ranges	O	O
?	O	O

There	O	O
are	O	O
more	O	O
columns	O	O
in	O	O
the	O	O
data	O	B-API
that	O	O
are	O	O
not	O	O
shown	O	O
above	O	O
,	O	O
and	O	O
using	O	O
this	O	O
code	O	O
causes	O	O
the	O	O
non-numeric	O	O
columns	O	O
to	O	O
drop	O	B-API
off	O	O
.	O	O

Any	O	O
suggestions	O	O
?	O	O

python	O	O
-	O	O
trying	O	O
to	O	O
get	O	B-API
a	O	O
new	O	O
pandas	O	O
release	O	B-API

In	O	O
the	O	O
process	O	B-API
of	O	O
creating	O	O
an	O	O
example	O	O
with	O	O
code	O	O
,	O	O
I	O	O
managed	O	O
to	O	O
get	O	B-API
it	O	O
working	O	O
.	O	O

Can	O	O
you	O	O
post	O	O
raw	O	O
data	O	B-API
and	O	O
example	O	O
code	O	O
that	O	O
demonstrates	O	O
this	O	O
'	O	O
cutting	O	O
'	O	O
off	O	O

Running	O	O
your	O	O
code	O	O
on	O	O
the	O	O
sample	O	B-API
data	O	B-API
produces	O	O
the	O	O
same	O	O
result	O	O
.	O	O

I	O	O
want	O	O
to	O	O
take	O	B-API
advantage	O	O
of	O	O
sortedness	O	O
since	O	O
with	O	O
very	O	O
large	O	O
series	O	O
merging	O	O
when	O	O
we	O	O
know	O	O
it's	O	O
sorted	O	O
should	O	O
be	O	O
linear	O	O
in	O	O
total	O	O
length	O	O
of	O	O
the	O	O
arrays	O	O
,	O	O
whereas	O	O
any	O	B-API
sort	O	B-API
will	O	O
be	O	O
non-linear	O	O
.	O	O

What	O	O
if	O	O
you	O	O
just	O	O
changed	O	B-API
the	O	O
index	O	B-API
from	O	O
date	O	B-API
/	O	O
status	O	O
to	O	O
date	O	B-API
/	O	O
var1	O	O
/	O	O
status	O	O
?	O	O

which	O	O
when	O	O
imported	O	O
into	O	O
pandas	O	O
data	O	B-API
frames	O	O
and	O	O
each	O	O
joined	O	B-API
to	O	O
a	O	O
common	O	O
timestamp	O	O
,	O	O
with	O	O
a	O	O
day	O	B-API
of	O	O
year	O	B-API
field	O	B-API
added	O	O
,	O	O
so	O	O
looking	O	O
something	O	O
like	O	O
:	O	O
#CODE	O	O

This	O	O
works	O	O
only	O	O
if	O	O
your	O	O
object	O	O
is	O	O
table	O	B-API
format	O	B-API
(	O	O
rather	O	O
than	O	O
fixed	O	O
format	O	B-API
)	O	O
.	O	O

Drop	O	O
range	O	O
of	O	O
columns	O	O
by	O	O
labels	O	O

You	O	O
could	O	O
put	O	B-API
```	O	O
[	O	O
'	O	O
col1	O	O
']```	O	O
at	O	B-API
the	O	O
end	O	O
to	O	O
get	O	B-API
an	O	O
int	O	O
.	O	O

Hence	O	O
,	O	O
the	O	O
width	O	O
of	O	O
each	O	O
bin	O	O
over	O	B-API
the	O	O
interval	O	O
from	O	O
[	O	O
-1	O	O
,	O	O
1	O	O
]	O	O
should	O	O
be	O	O
`	O	O
2	O	O
/	O	O
10=	O	O
0.20	O	O
`	O	O
;	O	O
however	O	O
,	O	O
the	O	O
graph	O	O
does	O	O
not	O	O
have	O	O
any	O	B-API
bins	O	O
with	O	O
a	O	O
width	O	O
of	O	O
0.20	O	O
.	O	O

For	O	O
encoding	O	O
training	O	O
data	O	B-API
you	O	O
can	O	O
use	O	B-API
fit_transform	O	O
which	O	O
will	O	O
discover	O	O
the	O	O
category	O	O
labels	O	O
and	O	O
create	O	O
appropriate	O	O
dummy	O	O
variables	O	O
.	O	O

I	O	O
think	O	O
you're	O	O
confusing	O	O
how	O	O
to	O	O
filter	O	B-API
here	O	O
,	O	O
if	O	O
you're	O	O
looking	O	O
for	O	O
a	O	O
specific	O	O
value	O	O
then	O	O
`	O	O
stock	O	O
[	O	O
stock	O	O
[	O	O
'	O	O
Whs	O	O
']	O	O
==	O	O
'	O	O
VKO	O	O
']`	O	O
will	O	O
return	O	O
only	O	O
the	O	O
rows	O	O
where	O	B-API
that	O	O
condition	O	O
is	O	O
satisfied	O	O
,	O	O
for	O	O
your	O	O
last	O	B-API
part	O	O
the	O	O
reason	O	O
you	O	O
get	O	B-API
an	O	O
empty	O	B-API
row	O	O
is	O	O
that	O	O
you're	O	O
slicing	O	O
the	O	O
first	O	B-API
3	O	O
rows	O	O
and	O	O
then	O	O
comparing	O	O
the	O	O
first	O	B-API
value	O	O
with	O	O
your	O	O
string	O	O
but	O	O
the	O	O
first	O	B-API
string	O	O
value	O	O
is	O	O
'	O	O
VKO	O	O
'	O	O
and	O	O
not	O	O
'	O	O
ZZZ	O	O
'	O	O
,	O	O
you	O	O
should	O	O
do	O	O
this	O	O
:	O	O
`	O	O
stock	O	O
[	O	O
stock	O	O
[	O	O
'	O	O
Whs	O	O
']	O	O
==	O	O
'	O	O
ZZZ	O	O
']`	O	O
to	O	O
filter	O	B-API
the	O	O
resuls	O	O
first	O	B-API

I	O	O
had	O	O
changed	O	B-API
the	O	O
data	O	B-API
on	O	O
the	O	O
local	O	O
file	O	O
.	O	O

Note	O	O
that	O	O
this	O	O
is	O	O
slightly	O	O
different	O	O
as	O	O
we	O	O
are	O	O
returning	O	O
the	O	O
first	O	B-API
index	O	B-API
here	O	O
(	O	O
and	O	O
not	O	O
the	O	O
normally	O	O
returned	O	O
last	O	B-API
,	O	O
youy	O	O
could	O	O
do	O	O
either	O	O
)	O	O
.	O	O

I'm	O	O
not	O	O
sure	O	O
how	O	O
the	O	O
archive	O	O
block	O	O
reading	O	O
works	O	O
and	O	O
how	O	O
much	O	O
data	O	B-API
it	O	O
loads	O	B-API
into	O	O
memory	O	O
,	O	O
but	O	O
it's	O	O
clear	O	B-API
that	O	O
you	O	O
will	O	O
have	O	O
to	O	O
somehow	O	O
control	O	O
the	O	O
size	O	B-API
of	O	O
the	O	O
chunks	O	O
.	O	O

Regarding	O	O
nesting	O	O
of	O	O
functions	O	O
:	O	O
if	O	O
you	O	O
believe	O	O
a	O	O
function	O	B-API
has	O	O
a	O	O
general	O	O
purpose	O	O
or	O	O
is	O	O
reusable	O	O
,	O	O
then	O	O
it	O	O
should	O	O
be	O	O
defined	O	O
at	O	B-API
the	O	O
top	O	O
level	O	O
of	O	O
a	O	O
module	O	O
or	O	O
some	O	O
place	O	B-API
where	O	B-API
other	O	O
functions	O	O
can	O	O
call	O	O
it	O	O
.	O	O

I	O	O
get	O	B-API
an	O	O
error	O	O
saying	O	O
:	O	O
lambda	O	O
(	O	O
)	O	O
takes	O	O
exactly	O	O
1	O	O
argument	O	O
(	O	O
3	O	O
given	O	O
)	O	O

You	O	O
can	O	O
get	O	B-API
the	O	O
list	O	B-API
of	O	O
columns	O	O
with	O	O
:	O	O
#CODE	O	O

One	O	O
is	O	O
I	O	O
only	O	O
wanted	O	O
to	O	O
get	O	B-API
the	O	O
mean	O	B-API
of	O	O
the	O	O
next	O	B-API
rows	O	O
that	O	O
relate	O	O
to	O	O
the	O	O
same	O	O
group	O	B-API
.	O	O

By	O	O
default	O	O
this	O	O
will	O	O
add	O	B-API
a	O	O
column	O	O
of	O	O
integers	O	O
(	O	O
because	O	O
R	O	O
factors	O	O
are	O	O
encoded	O	O
as	O	O
integers	O	O
)	O	O
.	O	O

I	O	O
am	O	O
trying	O	O
to	O	O
calculate	O	O
the	O	O
percent	O	O
change	O	O
by	O	O
month	O	B-API
for	O	O
each	O	O
product	O	B-API
.	O	O

If	O	O
i	O	O
want	O	O
only	O	O
USA	O	O
Equities	O	O
vs	O	O
all	O	B-API
other	O	O
equity	O	O
and	O	O
not	O	O
the	O	O
enitre	O	O
89	O	O
columns	O	O
how	O	O
do	O	O
i	O	O
do	O	O
it	O	O
?	O	O

Pandas	O	O
:	O	O
Efficient	O	O
way	O	O
to	O	O
get	O	B-API
first	O	B-API
row	O	O
with	O	O
element	O	O
that	O	O
is	O	O
smaller	O	O
than	O	O
a	O	O
given	O	O
value	O	O

I	O	O
first	O	B-API
thought	O	O
this	O	O
was	O	O
a	O	O
spacing	O	O
issue	O	O
in	O	O
the	O	O
columns	O	O
values	O	B-API
,	O	O
so	O	O
I	O	O
replaced	O	O
them	O	O
with	O	O
underscores	O	O
,	O	O
but	O	O
it	O	O
also	O	O
doesn't	O	O
work	O	O
in	O	O
columns	O	O
which	O	O
only	O	O
contain	O	O
a	O	O
single	O	O
word	O	O
and	O	O
no	O	O
spaces	O	O
?	O	O

Are	O	O
you	O	O
getting	O	O
the	O	O
values	O	B-API
from	O	O
the	O	O
GUI	O	O
ok	O	O
,	O	O
but	O	O
your	O	O
calculations	O	O
are	O	O
returning	O	O
nothin	O	O
?	O	O

This	O	O
is	O	O
not	O	O
precisely	O	O
what	O	O
I'm	O	O
after	O	O
,	O	O
but	O	O
I	O	O
think	O	O
I'll	O	O
have	O	O
to	O	O
write	O	O
a	O	O
loop	O	O
top	O	O
get	O	B-API
that	O	O
.	O	O

Hence	O	O
,	O	O
the	O	O
width	O	O
of	O	O
each	O	O
bin	O	O
over	O	B-API
the	O	O
interval	O	O
from	O	O
[	O	O
-1	O	O
,	O	O
1	O	O
]	O	O
should	O	O
be	O	O
`	O	O
2	O	O
/	O	O
10=	O	O
0.20	O	O
`	O	O
;	O	O
however	O	O
,	O	O
the	O	O
graph	O	O
does	O	O
not	O	O
have	O	O
any	O	B-API
bins	O	O
with	O	O
a	O	O
width	O	O
of	O	O
0.20	O	O
.	O	O

I'm	O	O
having	O	O
a	O	O
problem	O	O
trying	O	O
to	O	O
get	O	B-API
a	O	O
character	O	O
count	O	B-API
column	O	O
of	O	O
the	O	O
string	O	O
values	O	B-API
in	O	O
another	O	O
column	O	O
,	O	O
and	O	O
haven't	O	O
figured	O	O
out	O	O
how	O	O
to	O	O
do	O	O
it	O	O
efficiently	O	O
.	O	O

I	O	O
think	O	O
I	O	O
get	O	B-API
the	O	O
idea	O	O
.	O	O

How	O	O
can	O	O
I	O	O
get	O	B-API
the	O	O
position	O	O
of	O	O
index	O	B-API
`	O	O
18	O	O
`	O	O
?	O	O

When	O	O
using	O	O
`	O	O
groupy-apply	O	O
`	O	O
,	O	O
instead	O	O
of	O	O
dropping	O	O
the	O	O
group	O	B-API
key	O	O
index	O	B-API
using	O	O
:	O	O
#CODE	O	O

No	O	O
real	O	B-API
advantage	O	O
if	O	O
there	O	O
are	O	O
just	O	O
two	O	O
categories	O	B-API
:	O	O
#CODE	O	O

@USER	O	O
I	O	O
suspect	O	O
something	O	O
else	O	O
is	O	O
going	O	O
on	O	O
then	O	O
,	O	O
because	O	O
when	O	O
I	O	O
memory	O	O
profile	O	O
this	O	O
way	O	O
(	O	O
with	O	O
`	O	O
drop	O	B-API
`)	O	O
using	O	O
the	O	O
snippet	O	O
that	O	O
Michael	O	O
Laszlo	O	O
posted	O	O
,	O	O
I	O	O
do	O	O
not	O	O
see	O	O
memory	O	O
growth	O	O
.	O	O

Of	O	O
course	O	O
you	O	O
may	O	O
not	O	O
like	O	O
the	O	O
index	O	B-API
as	O	O
tuples	O	O
;	O	O
you	O	O
could	O	O
reset	O	B-API
the	O	O
index	O	B-API
within	O	O
the	O	O
list	O	B-API
comprehension	O	O
to	O	O
get	O	B-API
the	O	O
following	O	O
if	O	O
you	O	O
prefer	O	O
(	O	O
for	O	O
example	O	O
,	O	O
this	O	O
if	O	O
for	O	O
part	O	O
1	O	O
):	O	O
#CODE	O	O

Here	O	O
is	O	O
how	O	O
I	O	O
am	O	O
trying	O	O
to	O	O
get	O	B-API
the	O	O
output	O	O
to	O	O
look	O	O
like	O	O
:	O	O
#CODE	O	O

memory	O	O
efficient	O	O
Python	O	O
(	O	O
pandas	O	O
)	O	O
aggregates	O	O
of	O	O
categories	O	B-API
from	O	O
one	O	O
csv	O	O
file	O	O
per	O	O
period	O	O

But	O	O
this	O	O
last	O	B-API
line	O	O
generate	O	O
the	O	O
error	O	O
message	O	O
:	O	O
`	O	O
no	O	O
item	O	B-API
named	O	O
timestamp	O	O
`	O	O
.	O	O

The	O	O
problem	O	O
here	O	O
,	O	O
well	O	O
the	O	O
biggest	O	O
one	O	O
,	O	O
is	O	O
that	O	O
your	O	O
`	O	O
data	O	B-API
`	O	O
is	O	O
string	O	O
,	O	O
not	O	O
valid	O	B-API
data	O	B-API
structure	O	O
,	O	O
same	O	O
thing	O	O
with	O	O
dictionary	O	O
inside	O	O
it	O	O
,	O	O
you	O	O
creating	O	O
strings	O	O
,	O	O
not	O	O
data	O	B-API
structures	O	O
.	O	O

I	O	O
also	O	O
want	O	O
to	O	O
create	O	O
a	O	O
new	O	O
column	O	O
that	O	O
shows	O	O
the	O	O
difference	O	B-API
in	O	O
days	O	B-API
between	O	B-API
the	O	O
end	O	O
and	O	O
begin	O	O
dates	O	B-API
.	O	O

In	O	O
the	O	O
next	O	B-API
column	O	O
(	O	O
B	O	O
)	O	O
,	O	O
I	O	O
want	O	O
to	O	O
create	O	O
an	O	O
indexed	O	O
series	O	O
that	O	O
begins	O	O
at	O	B-API
1000	O	O
based	O	O
on	O	O
the	O	O
percent	O	O
changes	O	O
.	O	O

I	O	O
can't	O	O
use	O	B-API
fixed	O	O
position	O	O
to	O	O
slice	O	B-API
it	O	O
.	O	O

This	O	O
gets	O	O
you	O	O
to	O	O
where	O	B-API
I	O	O
am	O	O
.	O	O

I	O	O
am	O	O
using	O	O
this	O	O
to	O	O
generate	O	O
nodes	O	O
in	O	O
a	O	O
graph	O	O
,	O	O
if	O	O
x1	O	O
,	O	O
x2	O	O
are	O	O
not	O	O
exactly	O	O
equal	O	B-API
,	O	O
networkx	O	O
recognizes	O	O
them	O	O
as	O	O
different	O	O
nodes	O	O
,	O	O
if	O	O
x1=x2	O	O
,	O	O
i	O	O
get	O	B-API
a	O	O
recombinant	O	O
tree	O	O
which	O	O
is	O	O
what	O	O
i	O	O
want	O	O
.	O	O

My	O	O
example	O	O
was	O	O
not	O	O
good	O	O
enough	O	O
,	O	O
as	O	O
your	O	O
script	O	O
smartly	O	O
took	O	O
the	O	O
size	O	B-API
from	O	O
the	O	O
length	O	O
of	O	O
the	O	O
df	O	O
.	O	O

iPython's	O	O
Rmagic	O	O
is	O	O
already	O	O
able	O	O
to	O	O
perform	O	O
an	O	O
automagic	O	O
conversion	O	O
between	O	B-API
the	O	O
two	O	O
in	O	O
a	O	O
number	O	O
of	O	O
situations	O	O
,	O	O
and	O	O
might	O	O
be	O	O
a	O	O
good	O	O
way	O	O
to	O	O
get	O	B-API
familiar	O	O
with	O	O
Python	O	O
.	O	O

So	O	O
if	O	O
your	O	O
dataset	O	O
is	O	O
really	O	O
large	O	O
,	O	O
perhaps	O	O
store	O	O
them	O	O
first	O	B-API
in	O	O
on-disk	O	O
database	O	O
/	O	O
HDF	O	O
rather	O	O
than	O	O
csv	O	O
file	O	O
and	O	O
sort	O	B-API
them	O	O
there	O	O
,	O	O
and	O	O
then	O	O
query	O	B-API
.	O	O

One	O	O
had	O	O
no	O	O
problem	O	O
at	O	B-API
all	O	B-API
(	O	O
the	O	O
xlsx	O	O
file	O	O
,	O	O
example	O	O
2	O	O
)	O	O
and	O	O
the	O	O
other	O	O
(	O	O
xls	O	O
,	O	O
example	O	O
1	O	O
)	O	O
had	O	O
a	O	O
difference	O	B-API
between	O	B-API
the	O	O
columns	O	O
.	O	O

then	O	O
with	O	O
the	O	O
`	O	O
sorted	O	O
`	O	O
function	O	B-API
and	O	O
`	O	O
datetime	O	O
`	O	O
module	O	O
(	O	O
remember	O	O
the	O	O
`	O	O
sorted	O	O
`	O	O
function	O	B-API
change	O	O
the	O	O
`	O	O
data	O	B-API
`	O	O
it	O	O
self	O	O
)	O	O
#CODE	O	O

BUT	O	O
,	O	O
I	O	O
get	O	B-API
the	O	O
"	O	O
SettingWithCopyWarning	O	O
"	O	O
:	O	O

This	O	O
is	O	O
machine	O	O
generated	O	O
data	O	B-API
.	O	O

You	O	O
can't	O	O
use	O	B-API
`	O	O
or	O	O
`	O	O
with	O	O
arrays	O	O
,	O	O
if	O	O
you	O	O
try	O	O
this	O	O
you	O	O
get	O	B-API
an	O	O
error	O	O
`	O	O
ValueError	O	O
:	O	O
The	O	O
truth	O	O
value	O	O
of	O	O
a	O	O
Series	O	B-API
is	O	O
ambiguous	O	O
.	O	O

Incidentally	O	O
,	O	O
this	O	O
is	O	O
the	O	O
same	O	O
result	O	O
that	O	O
you	O	O
would	O	O
get	O	B-API
with	O	O
the	O	O
Spearman	O	O
R	O	O
coefficient	O	O
as	O	O
well	O	O
.	O	O

How	O	O
could	O	O
I	O	O
do	O	O
to	O	O
have	O	O
exactly	O	O
one	O	O
calendar	O	O
year	O	B-API
between	O	B-API
dates	O	B-API
in	O	O
spite	O	O
of	O	O
leap	O	O
years	O	O
?	O	O

"	O	O
However	O	O
,	O	O
we	O	O
still	O	O
have	O	O
one	O	O
large	O	O
difference	O	B-API
.	O	O

All	O	O
that	O	O
remains	O	O
is	O	O
to	O	O
merged	O	O
the	O	O
contents	O	O
of	O	O
the	O	O
second-level	O	O
dictionaries	O	O
:	O	O
#CODE	O	O

I	O	O
am	O	O
trying	O	O
to	O	O
create	O	O
a	O	O
single	O	O
image	O	B-API
with	O	O
heatmaps	O	O
representing	O	O
the	O	O
correlation	O	O
of	O	O
features	O	O
of	O	O
data	O	B-API
points	O	O
for	O	O
each	O	O
label	O	O
separately	O	O
.	O	O

I	O	O
have	O	O
two	O	O
Series	O	B-API
which	O	O
have	O	O
a	O	O
format	O	B-API
equal	O	B-API
to	O	O
this	O	O
:	O	O
#CODE	O	O

However	O	O
,	O	O
when	O	O
I	O	O
do	O	O
the	O	O
following	O	O
,	O	O
the	O	O
error	O	O
does	O	O
not	O	O
show	O	B-API
up	O	O
and	O	O
I	O	O
get	O	B-API
the	O	O
expected	O	O
result	O	O
:	O	O
#CODE	O	O

As	O	O
brackets	O	O
are	O	O
part	O	O
of	O	O
the	O	O
regex	O	O
syntax	O	O
if	O	O
you're	O	O
trying	O	O
to	O	O
match	O	B-API
literal	O	O
brackets	O	O
you	O	O
need	O	O
to	O	O
escape	O	O
them	O	O
:	O	O
#CODE	O	O

Yeah	O	O
,	O	O
the	O	O
best	O	O
idea	O	O
I've	O	O
had	O	O
this	O	O
whole	O	O
time	O	B-API
was	O	O
to	O	O
actually	O	O
sign	O	B-API
up	O	O
to	O	O
SO	O	O
so	O	O
I	O	O
can	O	O
post	O	O
my	O	O
own	O	O
questions	O	O
instead	O	O
of	O	O
trying	O	O
to	O	O
funble	O	O
my	O	O
way	O	O
through	O	O
problems	O	O
by	O	O
patching	O	O
together	O	O
answers	O	O
to	O	O
other	O	O
peoples	O	O
questions	O	O
-	O	O
sometimes	O	O
what	O	O
I	O	O
need	O	O
just	O	O
isn't	O	O
covered	O	O
in	O	O
other	O	O
people's	O	O
questions	O	O
.	O	O

But	O	O
when	O	O
I	O	O
try	O	O
and	O	O
import	O	O
pandas	O	O
I	O	O
get	O	B-API
:	O	O
#CODE	O	O

However	O	O
,	O	O
I	O	O
can't	O	O
get	O	B-API
the	O	O
column	O	O
to	O	O
fill	O	B-API
up	O	O
with	O	O
the	O	O
appropriate	O	O
user	O	O
inputted	O	O
value	O	O
.	O	O

Also	O	O
I'm	O	O
not	O	O
getting	O	O
any	O	B-API
traceback	O	O
messages	O	O
but	O	O
I	O	O
think	O	O
I	O	O
have	O	O
an	O	O
idea	O	O
of	O	O
where	O	B-API
my	O	O
problem	O	O
may	O	O
be	O	O
.	O	O

Basically	O	O
I'm	O	O
trying	O	O
to	O	O
get	O	B-API
at	O	B-API
this	O	O
:	O	O
#CODE	O	O

So	O	O
this	O	O
is	O	O
not	O	O
a	O	O
fully	O	O
working	O	O
answer	O	O
,	O	O
but	O	O
maybe	O	O
it	O	O
can	O	O
be	O	O
extended	O	O
to	O	O
ultimatively	O	O
get	O	B-API
you	O	O
there	O	O
.	O	O

I	O	O
have	O	O
a	O	O
pandas	O	O
Series	O	B-API
holding	O	O
one	O	O
numpy	O	O
array	O	B-API
per	O	O
entry	O	O
(	O	O
same	O	O
length	O	O
for	O	O
all	O	B-API
entries	O	O
)	O	O
and	O	O
I	O	O
would	O	O
like	O	O
to	O	O
convert	O	B-API
this	O	O
to	O	O
a	O	O
2D	O	O
numpy	O	O
array	O	B-API
.	O	O

For	O	O
example	O	O
,	O	O
let's	O	O
say	O	O
I	O	O
want	O	O
to	O	O
select	O	B-API
50%	O	O
(	O	O
but	O	O
this	O	O
could	O	O
change	O	O
)	O	O
.	O	O

For	O	O
this	O	O
purpose	O	O
I	O	O
would	O	O
like	O	O
to	O	O
find	O	B-API
the	O	O
soonest	O	O
date	O	B-API
(	O	O
month	O	B-API
)	O	O
and	O	O
from	O	O
there	O	O
start	O	O
counting	O	O
months	O	O
and	O	O
their	O	O
averages	O	O
.	O	O

You've	O	O
changed	O	B-API
your	O	O
data	O	B-API
,	O	O
so	O	O
the	O	O
script	O	O
as	O	O
written	O	O
doesn't	O	O
work	O	O
.	O	O

Hopefully	O	O
you'll	O	O
get	O	B-API
an	O	O
answer	O	O
soon	O	O
.	O	O

This	O	O
should	O	O
get	O	B-API
you	O	O
to	O	O
the	O	O
point	O	O
in	O	O
your	O	O
code	O	O
where	O	B-API
you	O	O
start	O	O
dropping	O	O
columns	O	O
and	O	O
start	O	O
concatenating	O	O
.	O	O

So	O	O
,	O	O
if	O	O
k	O	O
were	O	O
equal	O	B-API
to	O	O
2	O	O
,	O	O
and	O	O
this	O	O
were	O	O
my	O	O
data	O	B-API
frame	O	O
:	O	O
#CODE	O	O

It	O	O
seems	O	O
as	O	O
though	O	O
the	O	O
second	O	B-API
approach	O	O
,	O	O
using	O	O
"	O	O
where	O	B-API
"	O	O
is	O	O
only	O	O
returning	O	O
data	O	B-API
from	O	O
the	O	O
last	O	B-API
few	O	O
appended	O	O
files	O	O
,	O	O
while	O	O
the	O	O
first	O	B-API
approach	O	O
is	O	O
returning	O	O
much	O	O
more	O	O
data	O	B-API
.	O	O

I	O	O
have	O	O
to	O	O
improve	O	O
this	O	O
to	O	O
get	O	B-API
rid	O	O
of	O	O
redundancy	O	O
,	O	O
and	O	O
I	O	O
am	O	O
not	O	O
sure	O	O
how	O	O
to	O	O
go	O	O
about	O	O
this	O	O
.	O	O

Are	O	O
you	O	O
able	O	O
to	O	O
post	O	O
raw	O	O
data	O	B-API
and	O	O
code	O	O
to	O	O
reproduce	O	O
this	O	O
issue	O	O
?	O	O

The	O	O
relative	O	O
size	O	B-API
between	O	B-API
consecutive	O	O
levels	O	O
.	O	O

This	O	O
will	O	O
potentially	O	O
cater	O	O
the	O	O
corner	O	O
cases	O	O
if	O	O
you	O	O
happen	O	O
to	O	O
have	O	O
conditions	O	O
like	O	O
:	O	O
"	O	O
value	O	O
"	O	O
360	O	O
then	O	O
+360	O	O
else	O	O
-360	O	O
but	O	O
the	O	O
sequence	O	O
of	O	O
the	O	O
update	O	B-API
will	O	O
cause	O	O
the	O	O
results	O	O
reapply	O	O
,	O	O
ie	O	O
.	O	O

I'll	O	O
put	O	B-API
an	O	O
example	O	O
of	O	O
what	O	O
I'm	O	O
suggesting	O	O
in	O	O
my	O	O
answer	O	O
.	O	O

But	O	O
you	O	O
said	O	O
you	O	O
want	O	O
only	O	O
the	O	O
time	O	B-API
points	O	O
from	O	O
the	O	O
longest	O	O
`	O	O
csv	O	O
`	O	O
.	O	O

replacing	O	O
this	O	O
in	O	O
code	O	O
just	O	O
drop	O	B-API
those	O	O
whole	O	O
rows	O	O
...	O	O

Thank	O	O
you	O	O
for	O	O
response	O	O
and	O	O
for	O	O
helping	O	O
me	O	O
get	O	B-API
to	O	O
next	O	B-API
level	O	O
of	O	O
pyhton	O	O
,	O	O
great	O	O
stuff	O	O
!	O	O

For	O	O
instance	O	O
,	O	O
you	O	O
can	O	O
insert	O	B-API
new	O	O
values	O	B-API
into	O	O
the	O	O
index	O	B-API
(	O	O
and	O	O
even	O	O
choose	O	B-API
what	O	O
value	O	O
it	O	O
should	O	O
have	O	O
):	O	O
#CODE	O	O

What	O	O
I	O	O
need	O	O
to	O	O
do	O	O
is	O	O
to	O	O
compute	O	O
the	O	O
average	O	B-API
temperature	O	O
for	O	O
every	O	O
run	O	O
,	O	O
averaging	O	O
all	O	B-API
the	O	O
temperature	O	O
measurements	O	O
belonging	O	O
to	O	O
a	O	O
run	O	O
.	O	O

@USER	O	O
I	O	O
get	O	B-API
`	O	O
Type	O	O
Error	O	B-API
:	O	O
'	O	O
bool	O	B-API
'	O	O
object	O	O
is	O	O
not	O	O
callable	O	O
`	O	O
when	O	O
I	O	O
do	O	O
that	O	O

For	O	O
your	O	O
specific	O	O
request	O	O
of	O	O
entries	O	O
between	O	B-API
12:00	O	O
to	O	O
13:00	O	O
for	O	O
every	O	O
single	O	O
day	O	B-API
,	O	O
you	O	O
can	O	O
fetch	O	O
the	O	O
rows	O	O
with	O	O
:	O	O
#CODE	O	O

Also	O	O
,	O	O
their	O	O
order	O	B-API
matters	O	O
(	O	O
they	O	O
are	O	O
sorted	O	O
by	O	O
decreasing	O	O
standard	O	O
deviation	O	O
across	O	O
rows	O	O
and	O	O
should	O	O
appear	O	O
in	O	O
this	O	O
order	O	B-API
in	O	O
the	O	O
heatmap	O	O
.	O	O
)	O	O

I'm	O	O
not	O	O
averse	O	O
the	O	O
reformatting	O	O
the	O	O
data	O	B-API
in	O	O
Pandas	O	O
-->	O	O
dumping	O	O
to	O	O
CSV	O	O
-->	O	O
importing	O	O
to	O	O
NetworkX	O	O
,	O	O
but	O	O
it	O	O
seems	O	O
as	O	O
if	O	O
I	O	O
should	O	O
be	O	O
able	O	O
to	O	O
generate	O	O
the	O	O
edges	O	O
from	O	O
the	O	O
index	O	B-API
and	O	O
the	O	O
nodes	O	O
from	O	O
the	O	O
values	O	B-API
.	O	O

What	O	O
is	O	O
the	O	O
simplest	O	O
way	O	O
to	O	O
get	O	B-API
a	O	O
sum	O	B-API
of	O	O
only	O	O
numbers	O	O
across	O	O
the	O	O
entire	O	O
frame	O	O
?	O	O

I	O	O
think	O	O
you	O	O
mean	O	B-API
a	O	O
Lorenz	O	O
plot	O	B-API
:	O	O
#URL	O	O
This	O	O
would	O	O
make	O	O
sense	O	O
then	O	O
as	O	O
it	O	O
requires	O	O
a	O	O
specific	O	O
preordering	O	O
of	O	O
the	O	O
data	O	B-API
.	O	O

Any	O	O
suggestions	O	O
?	O	O

Despite	O	O
the	O	O
title	O	B-API
,	O	O
similar	O	O
problems	O	O
can	O	O
occur	O	O
with	O	O
other	O	O
operating	O	O
systems	O	O
if	O	O
you	O	O
mix	O	O
32-bit	O	O
and	O	O
64-fit	O	O
versions	O	O
.	O	O

Use	O	O
`	O	O
select_as_coordinates	O	O
`	O	O
to	O	O
actually	O	O
execute	O	O
your	O	O
query	O	B-API
;	O	O
this	O	O
returns	O	O
an	O	O
`	O	O
Int64Index	O	O
`	O	O
of	O	O
the	O	O
row	O	O
number	O	O
(	O	O
the	O	O
coordinates	O	O
)	O	O
.	O	O

Somehow	O	O
create	O	O
a	O	O
mapping	O	O
so	O	O
that	O	O
instead	O	O
of	O	O
the	O	O
labels	O	O
being	O	O
29	O	O
,	O	O
30	O	O
etc	O	O
,	O	O
they	O	O
say	O	O
"	O	O
week	O	B-API
29	O	O
"	O	O
,	O	O
"	O	O
Week	O	O
30	O	O
"	O	O
etc	O	O
.	O	O

The	O	O
fix	O	B-API
you	O	O
describe	O	B-API
would	O	O
work	O	O
,	O	O
of	O	O
course	O	O
,	O	O
but	O	O
then	O	O
I	O	O
could	O	O
skip	O	O
pandas	O	O
all-together	O	O
and	O	O
directly	O	O
plot	O	B-API
the	O	O
results	O	O
of	O	O
my	O	O
individual	O	O
simulations	O	O
.	O	O

These	O	O
two	O	O
timezones	O	O
have	O	O
different	O	O
names	O	B-API
but	O	O
represent	O	O
the	O	O
same	O	O
thing	O	O
,	O	O
however	O	O

which	O	O
would	O	O
just	O	O
change	O	O
the	O	O
last	O	B-API
data	O	B-API
point	O	O
.	O	O

What	O	O
do	O	O
you	O	O
mean	O	B-API
by	O	O
reproducible	O	O
example	O	O
?	O	O

But	O	O
thought	O	O
i'd	O	O
make	O	O
it	O	O
clear	O	B-API
what	O	O
my	O	O
next	O	B-API
objective	O	O
was	O	O
,	O	O
in	O	O
case	O	O
someone	O	O
could	O	O
illuminate	O	O
a	O	O
better	O	O
method	O	O
to	O	O
get	O	B-API
there	O	O
.	O	O

What	O	O
output	O	O
do	O	O
you	O	O
get	O	B-API
when	O	O
you	O	O
just	O	O
enter	O	O
`	O	O
pd	O	O
`	O	O
in	O	O
the	O	O
console	O	O
?	O	O

When	O	O
I	O	O
train	O	O
on	O	O
each	O	O
label	O	O
I	O	O
get	O	B-API
et	O	O
better	O	O
than	O	O
73%	O	O
on	O	O
each	O	O
label	O	O
.	O	O

but	O	O
what	O	O
value	O	O
does	O	O
it	O	O
grab	O	O
when	O	O
indexing	O	O
?	O	O
in	O	O
other	O	O
words	O	O
,	O	O
if	O	O
i'm	O	O
just	O	O
testing	O	O
one	O	O
side	O	O
i'll	O	O
get	O	B-API
the	O	O
value	O	O
corresponding	O	O
to	O	O
that	O	O
row	O	O
if	O	O
true	O	O
.	O	O
since	O	O
both	O	O
sides	O	O
could	O	O
be	O	O
true	O	O
and	O	O
one	O	O
of	O	O
them	O	O
is	O	O
always	O	O
true	O	O
,	O	O
which	O	O
row's	O	O
values	O	B-API
will	O	O
be	O	O
selected	O	O
?	O	O

However	O	O
,	O	O
this	O	O
is	O	O
a	O	O
bug	O	O
as	O	O
you	O	O
should	O	O
get	O	B-API
an	O	O
error	O	O
.	O	O

guys	O	O
at	O	B-API
least	O	O
tell	O	O
me	O	O
why	O	O
i	O	O
am	O	O
getting	O	O
downvoted	O	O
?	O	O

In	O	O
some	O	O
cases	O	O
the	O	O
data	O	B-API
might	O	O
be	O	O
out	O	O
of	O	O
sync	O	O
which	O	O
makes	O	O
direct	O	O
comparisons	O	O
difficult	O	O
.	O	O

I	O	O
would	O	O
like	O	O
to	O	O
generate	O	O
a	O	O
matrix	O	B-API
which	O	O
contains	O	B-API
the	O	O
output	O	O
of	O	O
the	O	O
function	O	B-API
for	O	O
every	O	O
combination	O	O
of	O	O
X	O	O
and	O	O
Y	O	O
.	O	O

I'm	O	O
trying	O	O
to	O	O
get	O	B-API
the	O	O
data	O	B-API
to	O	O
in	O	O
the	O	O
column	O	O
"	O	O
Structure	O	O
"	O	O
to	O	O
repeat	O	B-API
the	O	O
row	O	O
labels	O	O
so	O	O
it	O	O
look	O	O
like	O	O
this	O	O
:	O	O
#CODE	O	O

decision	O	O
for	O	O
single	O	O
rows	O	O
to	O	O
get	O	B-API
converted	O	O
into	O	O
a	O	O
series	O	O
-	O	O
why	O	O
not	O	O
a	O	O

I	O	O
get	O	B-API
#CODE	O	O

More	O	O
info	O	B-API
as	O	O
requested	O	O
#CODE	O	O

[	O	O
Their	O	O
product	O	B-API
page	O	O
]	O	O
(	O	O
#URL	O	O
)	O	O
holds	O	O
the	O	O
answer	O	O
.	O	O

Next	O	O
,	O	O
you	O	O
wish	O	O
to	O	O
get	O	B-API
the	O	O
specific	O	O
groups	O	B-API
from	O	O
this	O	O
`	O	O
grouped	O	O
`	O	O
object	O	O
.	O	O

To	O	O
get	O	B-API
datetime64	O	O
that	O	O
uses	O	O
seconds	O	B-API
directly	O	O
:	O	O
#CODE	O	O

The	O	O
only	O	O
option	O	O
you	O	O
may	O	O
have	O	O
is	O	O
to	O	O
setup	O	B-API
your	O	O
data	O	B-API
structures	O	O
to	O	O
be	O	O
light	O	O
weight	O	O
so	O	O
each	O	O
worker	O	O
isn't	O	O
boated	O	O
by	O	O
redundant	O	O
copies	O	O
of	O	O
the	O	O
same	O	O
data	O	B-API
or	O	O
excessive	O	O
amounts	O	O
of	O	O
data	O	B-API
which	O	O
might	O	O
be	O	O
better	O	O
off	O	O
split	O	B-API
across	O	O
different	O	O
workers	O	O
.	O	O

Inplace	O	O
dropping	O	O
seems	O	O
more	O	O
like	O	O
idiomatic	O	O
pandas	O	O
to	O	O
me	O	O
than	O	O
making	O	O
a	O	O
copy	O	B-API
only	O	O
to	O	O
instantly	O	O
garbage	O	O
collect	O	O
the	O	O
now-defunct	O	O
original	O	O
.	O	O

And	O	O
fortunately	O	O
,	O	O
these	O	O
days	O	B-API
,	O	O
`	O	O
-pylab	O	O
`	O	O
has	O	O
been	O	O
deprecated	O	B-API
and	O	O
using	O	O
`	O	O
--	O	O
matplotlib	O	O
`	O	O
and	O	O
importing	O	O
`	O	O
pylab	O	O
`	O	O
manually	O	O
is	O	O
encouraged	O	O
.	O	O

Are	O	O
you	O	O
sure	O	O
you	O	O
don't	O	O
mean	O	B-API
`	O	O
range	O	O
(	O	O
1	O	O
,	O	O
len	O	B-API
(	O	O
DF	O	O
)):	O	O
`	O	O
?	O	O

Where	O	O
"	O	O
timeblock	O	O
"	O	O
#1	O	O
will	O	O
include	O	O
the	O	O
first	O	B-API
4:59	O	O
minutes	O	B-API
of	O	O
observation	O	O
period	O	O
#1	O	O
,	O	O
#2	O	O
will	O	O
include	O	O
5:00	O	O
to	O	O
9:59	O	O
minutes	O	B-API
...	O	O
through	O	O
to	O	O
25:00	O	O
and	O	O
over	O	B-API
,	O	O
for	O	O
each	O	O
observation	O	O
period	O	O
.	O	O

It	O	O
seems	O	O
like	O	O
I'm	O	O
maybe	O	O
getting	O	O
confused	O	O
between	O	B-API
the	O	O
underlying	O	O
data	O	B-API
and	O	O
views	O	O
on	O	O
it	O	O
.	O	O

When	O	O
I	O	O
try	O	O
specifying	O	O
index_col=0	O	O
,	O	O
as	O	O
some	O	O
examples	O	O
in	O	O
the	O	O
documentation	O	O
do	O	O
,	O	O
I	O	O
get	O	B-API
a	O	O
"	O	O
IndexError	O	O
:	O	O
list	O	B-API
index	O	B-API
out	O	O
of	O	O
range	O	O
"	O	O
error	O	O
,	O	O
which	O	O
was	O	O
a	O	O
solution	O	O
to	O	O
several	O	O
related	O	O
questions	O	O
but	O	O
for	O	O
some	O	O
reason	O	O
isn't	O	O
working	O	O
for	O	O
me	O	O
.	O	O

That's	O	O
what	O	O
I	O	O
thought	O	O
about	O	O
my	O	O
original	O	O
code	O	O
but	O	O
for	O	O
some	O	O
reason	O	O
when	O	O
I	O	O
check	O	O
len	O	B-API
(	O	O
Sframe	O	O
)	O	O
at	O	B-API
the	O	O
end	O	O
in	O	O
the	O	O
main	O	B-API
code	O	O
,	O	O
it	O	O
still	O	O
has	O	O
the	O	O
duplicate	O	O
values	O	B-API
even	O	O
if	O	O
the	O	O
conditional	O	O
statement	O	O
applies	O	O
option	O	O
2	O	O
to	O	O
remove	O	B-API
duplicates	O	O
.	O	O

The	O	O
main	O	B-API
thing	O	O
I	O	O
need	O	O
to	O	O
do	O	O
is	O	O
to	O	O
group	O	B-API
the	O	O
days	O	B-API
by	O	O
week	O	B-API
such	O	O
that	O	O
I	O	O
can	O	O
get	O	B-API
sum	O	B-API
of	O	O
the	O	O
data	O	B-API
to	O	O
be	O	O
by	O	O
week	O	B-API
.	O	O

To	O	O
move	O	O
the	O	O
third	O	O
row	O	O
to	O	O
the	O	O
first	O	B-API
,	O	O
you	O	O
can	O	O
create	O	O
an	O	O
index	O	B-API
moving	O	O
the	O	O
target	O	O
row	O	O
to	O	O
the	O	O
first	O	B-API
element	O	O
.	O	O

So	O	O
using	O	O
your	O	O
approach	O	O
,	O	O
how	O	O
can	O	O
I	O	O
:	O	O
1	O	O
)	O	O
plot	O	B-API
the	O	O
scores	O	O
as	O	O
a	O	O
histogram	O	B-API
in	O	O
a	O	O
memory-conscious	O	O
way	O	O
,	O	O
and	O	O
2	O	O
)	O	O
extract	O	B-API
the	O	O
scores	O	O
belonging	O	O
to	O	O
the	O	O
certain	O	O
cell	O	O
types	O	O
to	O	O
plot	O	B-API
those	O	O
as	O	O
well	O	O
?	O	O

I	O	O
have	O	O
a	O	O
CSV	O	O
file	O	O
,	O	O
I	O	O
wanted	O	O
to	O	O
filter	O	B-API
it	O	O
where	O	B-API
I	O	O
keep	O	O
just	O	O
rows	O	O
where	O	B-API
I	O	O
have	O	O
values	O	B-API
in	O	O
row	O	O
"	O	O
d	O	O
"	O	O
bigger	O	O
then	O	O
0	O	O
.	O	O

Simulations	O	O
can	O	O
be	O	O
repeated	O	O
for	O	O
different	O	O
scenarios	O	O
and	O	O
each	O	O
one	O	O
of	O	O
these	O	O
scenarios	O	O
will	O	O
produce	O	O
a	O	O
different	O	O
hourly	O	O
set	O	B-API
of	O	O
data	O	B-API
for	O	O
each	O	O
room	O	O
and	O	O
each	O	O
variable	O	O
.	O	O

To	O	O
get	O	B-API
around	O	B-API
this	O	O
,	O	O
I'm	O	O
passing	O	O
in	O	O
a	O	O
large	O	O
number	O	O
for	O	O
the	O	O
max_results	O	O
parameter	O	O
and	O	O
specifying	O	O
a	O	O
chunksize	O	O
.	O	O

You	O	O
get	O	B-API
back	O	B-API
a	O	O
float	O	O
because	O	O
each	O	O
row	O	O
contains	O	B-API
a	O	O
mix	O	O
of	O	O
`	O	O
float	O	O
`	O	O
and	O	O
`	O	O
int	O	O
`	O	O
types	O	O
.	O	O

Should	O	O
I	O	O
use	O	B-API
something	O	O
different	O	O
.	O	O

The	O	O
best	O	O
would	O	O
be	O	O
to	O	O
convert	O	B-API
that	O	O
one	O	O
file	O	O
to	O	O
a	O	O
an	O	O
actual	O	O
comma	O	O
(	O	O
semicolon	O	O
or	O	O
other	O	O
)	O	O
separated	O	O
file	O	O
or	O	O
make	O	O
sure	O	O
that	O	O
compound	O	B-API
values	O	B-API
are	O	O
quoted	O	O
(	O	O
"	O	O
Alabama	O	O
County	O	O
")	O	O
and	O	O
then	O	O
specify	O	O
the	O	O
quotechar	O	O
:	O	O
#CODE	O	O

I	O	O
would	O	O
like	O	O
to	O	O
calculate	O	O
the	O	O
average	O	B-API
of	O	O
time	O	B-API
per	O	O
org	O	O
per	O	O
cluster	O	O
.	O	O

I	O	O
found	O	O
a	O	O
way	O	O
which	O	O
seems	O	O
very	O	O
inefficient	O	O
(	O	O
stacking	O	O
and	O	O
unstacking	O	O
which	O	O
will	O	O
create	O	O
many	O	O
many	O	O
columns	O	O
in	O	O
case	O	O
of	O	O
millions	O	O
of	O	O
categories	O	B-API
)	O	O
.	O	O

I	O	O
was	O	O
going	O	O
to	O	O
suggest	O	O
cumcount	O	B-API
and	O	O
tail	O	B-API
(	O	O
1	O	O
)	O	O
,	O	O
but	O	O
you're	O	O
after	O	O
something	O	O
else	O	O
(	O	O
these	O	O
would	O	O
be	O	O
much	O	O
faster	O	O
)	O	O
.	O	O

This	O	O
is	O	O
because	O	O
working	O	O
with	O	O
dictionaries	O	O
is	O	O
so	O	O
easy	O	O
and	O	O
thinking	O	O
of	O	O
them	O	O
like	O	O
simple	O	O
dicts	O	O
often	O	O
means	O	O
you	O	O
can	O	O
find	O	B-API
a	O	O
solution	O	O
to	O	O
an	O	O
issue	O	O
without	O	O
having	O	O
to	O	O
get	O	B-API
too	O	O
deep	O	O
into	O	O
pandas	O	O
.	O	O

If	O	O
you're	O	O
trying	O	O
to	O	O
slice	O	B-API
each	O	O
string	O	O
to	O	O
get	O	B-API
the	O	O
substring	O	O
from	O	O
5	O	O
to	O	O
7	O	O
,	O	O
you	O	O
need	O	O
a	O	O
`	O	O
:	O	O
`	O	O
,	O	O
not	O	O
a	O	O
`	O	O
,	O	O
`	O	O
:	O	O
#CODE	O	O

However	O	O
,	O	O
since	O	O
each	O	O
of	O	O
your	O	O
new	O	O
`	O	O
DataFrames	O	O
`	O	O
is	O	O
a	O	O
summary	O	B-API
of	O	O
a	O	O
single	O	O
customer	O	O
,	O	O
I	O	O
would	O	O
suggest	O	O
writing	O	O
one	O	O
function	O	B-API
that	O	O
can	O	O
return	O	O
all	O	B-API
of	O	O
your	O	O
desired	O	O
results	O	O
in	O	O
a	O	O
single	O	O
`	O	O
Series	O	B-API
`	O	O
.	O	O

I	O	O
want	O	O
to	O	O
get	O	B-API
statistics	O	O
of	O	O
debt_ratio	O	O
based	O	O
on	O	O
subgroups	O	O
of	O	O
market_capitalization	O	O
.	O	O

Any	O	O
ideas	O	O
why	O	O
this	O	O
error	O	O
might	O	O
be	O	O
showing	O	O
up	O	O
so	O	O
I	O	O
can	O	O
know	O	O
what	O	O
to	O	O
go	O	O
after	O	O
to	O	O
fix	O	B-API
?	O	O

I	O	O
believe	O	O
it	O	O
is	O	O
getting	O	O
at	O	B-API
what	O	O
I	O	O
want	O	O
.	O	O

I	O	O
haven't	O	O
done	O	O
any	O	B-API
stress	O	O
testing	O	O
but	O	O
I'd	O	O
imagine	O	O
this	O	O
could	O	O
get	O	B-API
slow	O	B-API
on	O	O
very	O	O
large	O	O
DataFrames	O	O
.	O	O

Is	O	O
there	O	O
a	O	O
quick	O	O
way	O	O
to	O	O
sort	O	B-API
my	O	O
data	O	B-API
by	O	O
a	O	O
given	O	O
column	O	O
that	O	O
only	O	O
takes	O	O
chunks	O	O
into	O	O
account	O	O
and	O	O
doesn't	O	O
require	O	B-API
loading	O	O
entire	O	O
datasets	O	O
in	O	O
memory	O	O
?	O	O

Take	O	O
a	O	O
look	O	O
at	O	B-API
the	O	O
regex	O	O
docs	O	O
.	O	O

Any	O	O
logic	O	O
requirements	O	O
(	O	O
like	O	O
comparing	O	O
elem+1	O	O
to	O	O
elem	O	O
)	O	O
should	O	O
be	O	O
in	O	O
your	O	O
question	O	O
so	O	O
there	O	O
is	O	O
no	O	O
confusion	O	O
.	O	O

I'd	O	O
like	O	O
to	O	O
get	O	B-API
a	O	O
list	O	B-API
as	O	O
`	O	O
[	O	O
'	O	O
abcd	O	O
'	O	O
,	O	O
'	O	O
ddse	O	O
'	O	O
,	O	O
'	O	O
123d	O	O
'	O	O
,	O	O
'	O	O
aaaaa*	O	O
']`	O	O
.	O	O

but	O	O
get	O	B-API
the	O	O
following	O	O
error	O	O
:	O	O

I	O	O
get	O	B-API
#CODE	O	O

Ideally	O	O
the	O	O
question	O	O
would	O	O
provide	O	O
a	O	O
self-contained	O	O
piece	O	O
of	O	O
code	O	O
generating	O	O
the	O	O
data	O	B-API
structure	O	O
,	O	O
or	O	O
even	O	O
just	O	O
something	O	O
like	O	O
`	O	O
df	O	O
=	O	O
[[	O	O
1	O	O
,	O	O
2	O	O
]	O	O
,	O	O
[	O	O
2	O	O
,	O	O
3	O	O
]	O	O
,	O	O
[	O	O
4	O	O
,	O	O
5	O	O
]]`	O	O
,	O	O
enough	O	O
to	O	O
try	O	O
to	O	O
get	O	B-API
an	O	O
answer	O	O
without	O	O
diving	O	O
into	O	O
panda	O	O
.	O	O

I'm	O	O
running	O	O
daily	O	O
simulations	O	O
in	O	O
a	O	O
batch	O	O
:	O	O
I	O	O
do	O	O
365	O	O
simluations	O	O
to	O	O
get	O	B-API
results	O	O
for	O	O
a	O	O
full	O	B-API
year	O	B-API
.	O	O

I	O	O
edited	O	O
my	O	O
answer	O	O
to	O	O
use	O	B-API
capwords	O	O
per	O	O
your	O	O
suggestion	O	O
,	O	O
that	O	O
fixed	O	O
the	O	O
problem	O	O
I	O	O
missed	O	O
where	O	B-API
it	O	O
capitalized	O	O
the	O	O
'	O	O
s	O	O
'	O	O
in	O	O
Guy's	O	O
Name	O	O
.	O	O

Does	O	O
not	O	O
work	O	O
exactly	O	O
right	O	O
since	O	O
categories	O	B-API
can	O	O
be	O	O
mixed	O	O
like	O	O
that	O	O
so	O	O
it	O	O
will	O	O
produce	O	O
more	O	O
duplications	O	O

Essentially	O	O
,	O	O
I	O	O
want	O	O
to	O	O
look	O	O
at	O	B-API
quintiles	O	O
(	O	O
since	O	O
there	O	O
are	O	O
5	O	O
days	O	B-API
in	O	O
a	O	O
business	O	O
week	O	B-API
)	O	O
rank	O	B-API
1	O	O
and	O	O
5	O	O
and	O	O
see	O	O
how	O	O
they	O	O
change	O	O
from	O	O
week	O	B-API
to	O	O
week	O	B-API
.	O	O

Doing	O	O
this	O	O
transformation	O	O
for	O	O
500,000	O	O
file	O	O
takes	O	O
time	O	B-API
.	O	O

The	O	O
requirement	O	O
isn't	O	O
easy	O	O
to	O	O
wrap	O	B-API
once	O	O
mind	O	O
around	O	B-API
,	O	O
so	O	O
sorry	O	O
If	O	O
I	O	O
am	O	O
not	O	O
being	O	O
clear	O	B-API
.	O	O

My	O	O
question	O	O
is	O	O
,	O	O
from	O	O
`	O	O
result	O	O
`	O	O
how	O	O
can	O	O
I	O	O
get	O	B-API
the	O	O
column	O	O
index	O	B-API
of	O	O
the	O	O
first	O	B-API
level	O	O
as	O	O
list	O	B-API
:	O	O
#CODE	O	O

This	O	O
function	O	B-API
will	O	O
then	O	O
work	O	O
out	O	O
the	O	O
maximum	O	B-API
,	O	O
minimum	O	B-API
,	O	O
and	O	O
return	O	O
rages	O	O
of	O	O
values	O	B-API
based	O	O
on	O	O
the	O	O
fact	O	O
I	O	O
want	O	O
5	O	O
categories	O	B-API
:	O	O
(	O	O
1	O	O
,	O	O
2	O	O
)	O	O
,	O	O
(	O	O
3	O	O
,	O	O
4	O	O
)	O	O
,	O	O
(	O	O
5	O	O
,	O	O
6	O	O
)	O	O
,	O	O
(	O	O
7	O	O
,	O	O
8)	O	O
,	O	O
(	O	O
9	O	O
,	O	O
10	O	O
)	O	O
.	O	O

Any	O	O
suggestions	O	O
of	O	O
a	O	O
better	O	O
way	O	O
?	O	O

In	O	O
addition	O	O
this	O	O
is	O	O
unlikely	O	O
to	O	O
be	O	O
only	O	O
time	O	B-API
I	O	O
have	O	O
to	O	O
do	O	O
this	O	O
so	O	O
being	O	O
able	O	O
to	O	O
change	O	O
the	O	O
numbers	O	O
and	O	O
columns	O	O
i'm	O	O
interested	O	O
in	O	O
would	O	O
be	O	O
good	O	O
.	O	O

And	O	O
at	O	B-API
that	O	O
time	O	B-API
i	O	O
think	O	O
the	O	O
state	O	O
becomes	O	O
bad	O	O
,	O	O
so	O	O
subsequent	O	O
calls	O	O
will	O	O
lead	O	O
to	O	O
exceptions	O	O
like	O	O
these	O	O
:	O	O
#CODE	O	O

Let	O	O
me	O	O
fix	O	B-API
that	O	O
and	O	O
return	O	O
to	O	O
this	O	O
issue	O	O
,	O	O
as	O	O
I	O	O
have	O	O
read	O	O
something	O	O
about	O	O
format	O	B-API
changes	O	O
between	O	B-API
10	O	O
and	O	O
12	O	O
.	O	O

All	O	O
the	O	O
data	O	B-API
,	O	O
columns	O	O
222	O	O
and	O	O
333	O	O
are	O	O
offset	O	B-API
as	O	O
required	O	O
,	O	O
but	O	O
it	O	O
isn't	O	O
even	O	O
the	O	O
same	O	O
size	O	B-API
as	O	O
the	O	O
output	O	O
in	O	O
the	O	O
first	O	B-API
order	O	B-API
.	O	O

But	O	O
I	O	O
can	O	O
only	O	O
get	O	B-API
this	O	O
:	O	O
#CODE	O	O

I	O	O
have	O	O
summary-level	O	O
data	O	B-API
of	O	O
the	O	O
count	O	B-API
of	O	O
people	O	O
by	O	O
age	O	O
group	O	B-API
,	O	O
city	O	O
,	O	O
income	O	O
and	O	O
the	O	O
industry	O	O
in	O	O
which	O	O
they	O	O
work	O	O
,	O	O
or	O	O
in	O	O
this	O	O
case	O	O
four	O	O
dimensions	O	O
.	O	O

@USER	O	O
:	O	O
Yes	O	O
,	O	O
it	O	O
can	O	O
as	O	O
I	O	O
said	O	O
,	O	O
"	O	O
They	O	O
all	O	B-API
suck	O	O
in	O	O
different	O	O
ways	O	O
"	O	O
.	O	O

Error	O	B-API
:	O	O
list	O	B-API
indices	O	B-API
must	O	O
be	O	O
integers	O	O
,	O	O
not	O	O
Series	O	B-API

Just	O	O
so	O	O
that	O	O
it	O	O
does	O	O
not	O	O
fail	O	O
silently	O	O
if	O	O
the	O	O
wrong	O	O
kind	O	O
of	O	O
data	O	B-API
is	O	O
passed	O	O
in	O	O
.	O	O

If	O	O
you	O	O
want	O	O
to	O	O
take	O	B-API
advantage	O	O
of	O	O
NumPy	O	O
/	O	O
Pandas	O	O
to	O	O
perform	O	O
fast	O	O
(	O	O
er	O	O
)	O	O
calculations	O	O
you	O	O
must	O	O
keep	O	O
the	O	O
data	O	B-API
in	O	O
a	O	O
NumPy	O	O
array	O	B-API
or	O	O
Pandas	O	O
NDFrame	O	O
.	O	O

Your	O	O
benchmark	O	O
is	O	O
actually	O	O
too	O	O
small	O	O
to	O	O
show	O	B-API
the	O	O
real	O	B-API
difference	O	B-API
.	O	O

I	O	O
was	O	O
able	O	O
to	O	O
resolve	O	O
this	O	O
by	O	O
opening	O	O
/	O	O
closing	O	O
a	O	O
connection	O	O
each	O	O
time	O	B-API
i	O	O
need	O	O
to	O	O
execute	O	O
a	O	O
query	O	B-API
.	O	O

I	O	O
used	O	O
a	O	O
chunksize	O	O
of	O	O
4	O	O
to	O	O
make	O	O
the	O	O
grouping	O	O
noticeable	O	O
on	O	O
the	O	O
small	O	O
dataset	O	O
;	O	O
you'll	O	O
want	O	O
to	O	O
change	O	O
it	O	O
to	O	O
90000	O	O
for	O	O
your	O	O
real	O	B-API
dataset	O	O
.	O	O

It's	O	O
mostly	O	O
trial	O	O
and	O	O
error	O	O
for	O	O
me	O	O
,	O	O
plus	O	O
knowledge	O	O
that	O	O
you	O	O
can	O	O
do	O	O
a	O	O
lot	O	O
just	O	O
with	O	O
```	O	O
rank	O	B-API
```	O	O
and	O	O
```	O	O
count	O	B-API
```	O	O
,	O	O
which	O	O
are	O	O
both	O	O
pretty	O	O
fast	O	O
.	O	O

And	O	O
those	O	O
columns	O	O
which	O	O
have	O	O
differing	O	O
values	O	B-API
:	O	O
#CODE	O	O

(	O	O
I	O	O
will	O	O
use	O	B-API
logistic	O	B-API
regression	O	O
and	O	O
random	O	B-API
forest	O	O
to	O	O
do	O	O
the	O	O
prediction	O	O
,	O	O
which	O	O
support	O	O
sparse	O	O
matrix	O	B-API
.	O	O
)	O	O
Is	O	O
there	O	O
anyway	O	O
to	O	O
efficiently	O	O
slicing	O	O
a	O	O
sparseDataFrame	O	O
or	O	O
for	O	O
the	O	O
whole	O	O
process	O	B-API
I	O	O
am	O	O
doing	O	O
,	O	O
it	O	O
should	O	O
be	O	O
improved	O	O
in	O	O
anyway	O	O
?	O	O

I	O	O
looked	O	O
here	O	O
,	O	O
but	O	O
when	O	O
I	O	O
ran	O	O
that	O	O
in	O	O
iPython	O	O
Notebook	O	O
,	O	O
I	O	O
don't	O	O
get	O	B-API
anything	O	O
.	O	O

does	O	O
not	O	O
produce	O	O
any	O	B-API
difference	O	B-API
in	O	O
terms	O	O
of	O	O
file	O	O
size	O	B-API
than	O	O
...	O	O

You	O	O
will	O	O
either	O	O
have	O	O
to	O	O
split	O	B-API
the	O	O
table	O	B-API
up	O	O
or	O	O
choose	O	B-API
another	O	O
storage	O	O
format	O	B-API
.	O	O

To	O	O
get	O	B-API
the	O	O
number	O	O
of	O	O
groups	O	B-API
you	O	O
can	O	O
use	O	B-API
the	O	O
ngroups	O	O
attribute	O	O
:	O	O
#CODE	O	O

this	O	O
does	O	O
not	O	O
seem	O	O
to	O	O
work	O	O
and	O	O
I	O	O
am	O	O
not	O	O
sure	O	O
if	O	O
it	O	O
just	O	O
is	O	O
not	O	O
possible	O	O
,	O	O
I	O	O
can	O	O
always	O	O
generate	O	O
separate	O	O
dictionaries	O	O
from	O	O
a	O	O
master	O	O
dictionary	O	O
to	O	O
get	O	B-API
around	O	B-API
having	O	O
to	O	O
update	O	B-API
data	O	B-API
in	O	O
multiple	O	O
locations	O	O

I	O	O
want	O	O
to	O	O
compare	O	O
these	O	O
two	O	O
data	O	B-API
frames	O	O
by	O	O
row	O	O
based	O	O
on	O	O
column	O	O
Value	O	O
and	O	O
keep	O	O
the	O	O
row	O	O
from	O	O
first	O	B-API
or	O	O
second	O	B-API
depending	O	O
where	O	B-API
the	O	O
Value	O	O
is	O	O
bigger	O	O
.	O	O

Then	O	O
,	O	O
you	O	O
can	O	O
run	O	O
`	O	O
sudo	O	O
port	O	O
install	O	O
py27-pandas	O	O
`	O	O
to	O	O
get	O	B-API
Python	O	O
and	O	O
all	O	B-API
of	O	O
the	O	O
dependencies	O	O
installed	O	O
.	O	O

See	O	O
the	O	O
shape	O	B-API
method	O	O
of	O	O
the	O	O
input	O	O
array	O	B-API
,	O	O
and	O	O
you	O	O
should	O	O
get	O	B-API
something	O	O
like	O	O
`	O	O
(	O	O
N	O	O
,	O	O
)`	O	O
and	O	O
not	O	O
`	O	O
(	O	O
N	O	O
,	O	O
1	O	O
)`	O	O
.	O	O

So	O	O
,	O	O
will	O	O
the	O	O
lower	O	B-API
value	O	O
always	O	O
come	O	O
first	O	B-API
,	O	O
or	O	O
could	O	O
that	O	O
change	O	O
?	O	O

and	O	O
get	O	B-API
the	O	O
following	O	O
error	O	O
:	O	O

In	O	O
order	O	B-API
to	O	O
have	O	O
the	O	O
index	O	B-API
the	O	O
exact	O	O
same	O	O
as	O	O
the	O	O
first	O	B-API
example	O	O
you'd	O	O
need	O	O
to	O	O
change	O	O
to	O	O
int	O	O
from	O	O
float	O	O
.	O	O

The	O	O
graph	O	O
bit	O	O
is	O	O
sorted	O	O
but	O	O
the	O	O
part	O	O
i'm	O	O
finding	O	O
hard	O	O
is	O	O
the	O	O
fact	O	O
the	O	O
column	O	O
headers	O	O
can	O	O
change	O	O
so	O	O
picking	O	O
up	O	O
their	O	O
data	O	B-API
without	O	O
manually	O	O
calling	O	O
them	O	O
is	O	O
something	O	O
I'm	O	O
unable	O	O
to	O	O
do	O	O
.	O	O

If	O	O
pytables	O	O
used	O	O
msgpack	O	O
it	O	O
would	O	O
be	O	O
easier	O	O
for	O	O
other	O	O
languages	O	O
to	O	O
read	O	O
the	O	O
data	O	B-API
but	O	O
obviously	O	O
their	O	O
target	O	O
is	O	O
python	O	O
.	O	O

The	O	O
company	O	O
name	O	B-API
may	O	O
be	O	O
variable	O	O
length	O	O
,	O	O
it	O	O
will	O	O
however	O	O
always	O	O
be	O	O
after	O	O
the	O	O
first	O	B-API
`	O	O
\s	O	O
`	O	O

To	O	O
get	O	B-API
the	O	O
same	O	O
form	O	O
of	O	O
broadcasting	O	O
to	O	O
occur	O	O
like	O	O
the	O	O
diagram	O	O
above	O	O
shows	O	O
we	O	O
have	O	O
to	O	O
decompose	O	O
to	O	O
numpy	O	O
arrays	O	O
which	O	O
then	O	O
become	O	O
anonymous	O	O
data	O	B-API
:	O	O
#CODE	O	O

I	O	O
want	O	O
to	O	O
generate	O	O
a	O	O
plot	O	B-API
showing	O	O
these	O	O
dates	O	B-API
graphically	O	O
.	O	O

How	O	O
is	O	O
it	O	O
possible	O	O
to	O	O
get	O	B-API
the	O	O
label	O	O
of	O	O
value	O	O
'	O	O
12	O	O
'	O	O
?	O	O

You	O	O
shall	O	O
note	O	O
that	O	O
`	O	O
and	O	O
`	O	O
and	O	O
`	O	O
or	O	O
`	O	O
are	O	O
not	O	O
appropriate	O	O
for	O	O
a	O	O
vector	O	O
of	O	O
booleans	O	O
,	O	O
use	O	B-API
`	O	O
`	O	O
and	O	O
`	O	O
|	O	O
`	O	O
instead	O	O
.	O	O

No	O	O
,	O	O
this	O	O
table	O	B-API
is	O	O
used	O	O
by	O	O
a	O	O
lot	O	O
of	O	O
other	O	O
code	O	O
(	O	O
mostly	O	O
C#	O	O
)	O	O
,	O	O
I	O	O
am	O	O
just	O	O
doing	O	O
some	O	O
data	O	B-API
analysis	O	O
on	O	O
it	O	O
from	O	O
Python	O	O
,	O	O
so	O	O
I'm	O	O
not	O	O
in	O	O
a	O	O
position	O	O
to	O	O
change	O	O
the	O	O
semantics	O	O
/	O	O
data	O	B-API
structure	O	O
.	O	O

#	O	O
Valid	O	O
positions	O	O
in	O	O
output	O	O
array	O	B-API
to	O	O
be	O	O
changed	O	B-API

Is	O	O
there	O	O
a	O	O
bug	O	O
in	O	O
my	O	O
code	O	O
or	O	O
is	O	O
there	O	O
another	O	O
reason	O	O
for	O	O
the	O	O
huge	O	O
computation	O	O
speed	O	O
difference	O	B-API
between	O	B-API
those	O	O
two	O	O
lines	O	B-API
of	O	O
code	O	O
?	O	O

I	O	O
also	O	O
used	O	O
a	O	O
longer	O	O
window	O	O
because	O	O
there	O	O
were	O	O
only	O	O
15	O	O
values	O	B-API
per	O	O
array	O	B-API
but	O	O
you	O	O
seemed	O	O
to	O	O
be	O	O
planning	O	O
on	O	O
using	O	O
the	O	O
last	O	B-API
50	O	O
days	O	B-API
.	O	O

I	O	O
am	O	O
trying	O	O
to	O	O
get	O	B-API
the	O	O
data	O	B-API
into	O	O
the	O	O
following	O	O
shape	O	B-API
:	O	O
#CODE	O	O

I	O	O
then	O	O
get	O	B-API
the	O	O
following	O	O
error	O	O
:	O	O
#CODE	O	O

I	O	O
want	O	O
to	O	O
:	O	O
plot	O	B-API
a	O	O
heatmap	O	O
of	O	O
x	O	O
,	O	O
y	O	O
and	O	O
the	O	O
colour	O	O
is	O	O
the	O	O
z	O	O
value	O	O
..	O	O

I'm	O	O
also	O	O
running	O	O
python	O	O
3.4	O	O
and	O	O
I	O	O
didn't	O	O
get	O	B-API
any	O	B-API
warning	O	O
when	O	O
I	O	O
ran	O	O
your	O	O
code	O	O
exactly	O	O
as	O	O
is	O	O
.	O	O

This	O	O
does	O	O
it	O	O
in	O	O
a	O	O
one	O	O
liner	O	O
but	O	O
is	O	O
not	O	O
so	O	O
readable	O	O
,	O	O
basically	O	O
it	O	O
tests	O	O
where	O	B-API
the	O	O
value	O	O
counts	O	O
for	O	O
each	O	O
column	O	O
is	O	O
equal	O	B-API
to	O	O
1	O	O
,	O	O
filters	O	O
the	O	O
resultant	O	O
list	O	B-API
out	O	O
and	O	O
uses	O	O
the	O	O
index	O	B-API
as	O	O
a	O	O
boolean	O	O
indec	O	O
:	O	O
#CODE	O	O

I	O	O
still	O	O
think	O	O
pandas	O	O
is	O	O
not	O	O
correctly	O	O
handling	O	O
your	O	O
empty	O	B-API
column	O	O
and	O	O
you	O	O
end	O	O
up	O	O
with	O	O
either	O	O
with	O	O
5	O	O
columns	O	O
,	O	O
or	O	O
with	O	O
6	O	O
columns	O	O
,	O	O
but	O	O
shifted	O	O
one	O	O
to	O	O
the	O	O
left	O	O
.	O	O

However	O	O
,	O	O
I	O	O
am	O	O
receiving	O	O
this	O	O
warning	O	O
`	O	O
/	O	O
usr	O	O
/	O	O
local	O	O
/	O	O
lib	O	O
/	O	O
python2.7	O	O
/	O	O
dist-packages	O	O
/	O	O
pandas	O	O
/	O	O
core	O	O
/	O	O
index	O	B-API
.	O	O

It	O	O
looks	O	O
like	O	O
this	O	O
changed	O	B-API
at	O	B-API
some	O	O
point	O	O
;	O	O
maybe	O	O
he	O	O
has	O	O
an	O	O
old	O	O
version	O	O
of	O	O
pandas	O	O
where	O	B-API
S	O	O
and	O	O
Sec	O	O
are	O	O
no	O	O
good	O	O
.	O	O

I	O	O
have	O	O
also	O	O
heard	O	O
of	O	O
Orange	O	O
library	O	B-API
for	O	O
imputation	O	O
,	O	O
but	O	O
haven't	O	O
had	O	O
a	O	O
chance	O	O
to	O	O
use	O	B-API
it	O	O
yet	O	O
.	O	O

I	O	O
managed	O	O
to	O	O
find	O	B-API
how	O	O
this	O	O
is	O	O
almost	O	O
done	O	O
:	O	O
#CODE	O	O

For	O	O
this	O	O
purpose	O	O
you	O	O
need	O	O
pandas	O	O
-	O	O
most	O	O
popular	O	O
python	O	O
package	O	O
for	O	O
working	O	O
with	O	O
timeseries	O	O
and	O	O
another	O	O
analytic	O	O
data	O	B-API
.	O	O

well	O	O
,	O	O
what	O	O
I	O	O
am	O	O
trying	O	O
to	O	O
do	O	O
is	O	O
to	O	O
have	O	O
all	O	B-API
my	O	O
results	O	O
ready	O	O
out	O	O
of	O	O
mysql	O	O
,	O	O
and	O	O
then	O	O
do	O	O
different	O	O
types	O	O
of	O	O
merging	O	O
to	O	O
get	O	B-API
my	O	O
plots	O	O
.	O	O

I	O	O
agree	O	O
with	O	O
Chang	O	O
that	O	O
it	O	O
would	O	O
help	O	O
to	O	O
have	O	O
a	O	O
very	O	O
clear	O	B-API
example	O	O
of	O	O
how	O	O
the	O	O
exact	O	O
alignment	O	O
should	O	O
be	O	O
.	O	O

You	O	O
mention	O	O
in	O	O
update	O	B-API
2	O	O
above	O	O
that	O	O
you	O	O
want	O	O
to	O	O
get	O	B-API
the	O	O
columns	O	O
and	O	O
the	O	O
only	O	O
way	O	O
is	O	O
opening	O	O
the	O	O
hdf	O	O
.	O	O

So	O	O
where	O	B-API
those	O	O
indices	O	B-API
don't	O	O
match	O	B-API
up	O	O
(	O	O
50	O	O
,	O	O
and	O	O
51	O	O
)	O	O
,	O	O
you	O	O
get	O	B-API
`	O	O
NaN	O	O
`	O	O
as	O	O
I	O	O
would	O	O
hope	O	O
.	O	O

However	O	O
,	O	O
if	O	O
I	O	O
save	O	B-API
it	O	O
as	O	O
a	O	O
csv	O	O
file	O	O
and	O	O
reload	O	O
it	O	O
again	O	O
,	O	O
I	O	O
got	O	O
error	O	O
message	O	O
and	O	O
the	O	O
plot	O	B-API
is	O	O
not	O	O
quite	O	O
right	O	O
either	O	O
,	O	O
#CODE	O	O

My	O	O
main	O	B-API
goal	O	O
is	O	O
to	O	O
match	O	B-API
the	O	O
index	O	B-API
value	O	O
from	O	O
`	O	O
ds2	O	O
`	O	O
into	O	O
`	O	O
ds1	O	O
`	O	O
and	O	O
replace	O	B-API
it	O	O
with	O	O
corresponding	O	O
value	O	O
,	O	O
so	O	O
the	O	O
output	O	O
would	O	O
look	O	O
like	O	O
#CODE	O	O

That	O	O
would	O	O
be	O	O
a	O	O
possibility	O	O
but	O	O
the	O	O
problem	O	O
is	O	O
that	O	O
each	O	O
frame5	O	O
has	O	O
a	O	O
different	O	O
index	O	B-API
.	O	O

First	O	O
,	O	O
you	O	O
need	O	O
some	O	O
kind	O	O
of	O	O
mapping	O	O
of	O	O
what	O	O
makes	O	O
up	O	O
each	O	O
level	O	O
.	O	O

PyTables	O	O
3.1	O	O
was	O	O
just	O	O
released	O	O
that	O	O
changes	O	O
the	O	O
file	O	O
caching	O	O
mechanism	O	O
at	O	B-API
least	O	O
on	O	O
a	O	O
lower	O	B-API
HDF5	O	O
version	O	O
,	O	O
do	O	O
to	O	O
see	O	O
your	O	O
version	O	O
:	O	O
#CODE	O	O

backfilling	O	O
data	O	B-API
from	O	O
one	O	O
column	O	O
into	O	O
another	O	O

Also	O	O
,	O	O
I	O	O
know	O	O
I	O	O
am	O	O
missing	O	O
patterns	O	O
that	O	O
may	O	O
be	O	O
useful	O	O
because	O	O
if	O	O
a	O	O
pattern	O	O
exists	O	B-API
between	O	B-API
Variable_1	O	O
and	O	O
Variable_2	O	O
and	O	O
Variable_3	O	O
and	O	O
Variable_4	O	O
are	O	O
missing	O	O
completely	O	O
at	O	B-API
random	O	B-API
,	O	O
then	O	O
concatenating	O	O
them	O	O
as	O	O
strings	O	O
will	O	O
not	O	O
capture	O	O
the	O	O
pattern	O	O
between	O	B-API
Variable_1	O	O
and	O	O
Variable_2	O	O
.	O	O

Do	O	O
you	O	O
know	O	O
what	O	O
is	O	O
the	O	O
difference	O	B-API
in	O	O
this	O	O
case	O	O
between	O	B-API
both	O	O
?	O	O

The	O	O
goal	O	O
is	O	O
to	O	O
take	O	B-API
the	O	O
2x2	O	O
piece	O	O
of	O	O
df	O	O
with	O	O
index	O	B-API
(	O	O
4	O	O
,	O	O
5	O	O
)	O	O
and	O	O
columns	O	O
(	O	O
'	O	O
date	O	B-API
'	O	O
,	O	O
'	O	O
val	O	O
')	O	O
and	O	O
replace	O	B-API
it	O	O
with	O	O
a	O	O
same-shaped	O	O
,	O	O
same-typed	O	O
2x2	O	O
block	O	O
.	O	O

Convert	O	O
Matrix	O	O
format	O	B-API
to	O	O
Column	O	O
in	O	O
Pandas	O	O

`	O	O
nan	O	O
`	O	O
is	O	O
commonly	O	O
used	O	O
for	O	O
this	O	O
purpose	O	O
,	O	O
but	O	O
here	O	O
I'm	O	O
actually	O	O
just	O	O
using	O	O
the	O	O
time	O	B-API
that	O	O
was	O	O
already	O	O
there	O	O
if	O	O
there	O	O
isn't	O	O
a	O	O
new	O	O
one	O	O
defined	O	O
for	O	O
it	O	O
in	O	O
the	O	O
`	O	O
time_map	O	O
`	O	O
`	O	O
dict	O	O
`	O	O
.	O	O

I	O	O
want	O	O
to	O	O
drop	O	B-API
all	O	B-API
values	O	B-API
after	O	O
index	O	B-API
`	O	O
5	O	O
`	O	O
because	O	O
it	O	O
has	O	O
no	O	O
values	O	B-API
,	O	O
but	O	O
not	O	O
index	O	B-API
`	O	O
2	O	O
`	O	O
,	O	O
`	O	O
3	O	O
`	O	O
.	O	O

You	O	O
should	O	O
be	O	O
able	O	O
to	O	O
uninstall	O	O
Anaconda	O	O
(	O	O
it	O	O
is	O	O
only	O	O
a	O	O
directory	O	O
)	O	O
to	O	O
reverse	O	O
any	O	B-API
changes	O	O
.	O	O

Since	O	O
it	O	O
is	O	O
a	O	O
very	O	O
large	O	O
data	O	B-API
frame	O	O
,	O	O
I	O	O
think	O	O
it	O	O
might	O	O
be	O	O
inefficient	O	O
to	O	O
do	O	O
a	O	O
loop	O	O
and	O	O
row	O	O
by	O	O
row	O	O
extraction	O	O
.	O	O

Since	O	O
the	O	O
NumPy	O	O
array	O	B-API
has	O	O
no	O	O
index	O	B-API
,	O	O
there	O	O
should	O	O
be	O	O
no	O	O
"	O	O
Unalignable	O	O
boolean	O	O
Series	O	B-API
"	O	O
problem	O	O
.	O	O

My	O	O
guess	O	O
is	O	O
that	O	O
I	O	O
am	O	O
either	O	O
not	O	O
applying	O	O
the	O	O
functions	O	O
correctly	O	O
for	O	O
a	O	O
column	O	O
or	O	O
the	O	O
values	O	B-API
I	O	O
am	O	O
getting	O	O
arent	O	O
integers	O	O
.	O	O

which	O	O
gives	O	O
you	O	O
your	O	O
date	O	B-API
as	O	O
a	O	O
list	O	B-API
arranged	O	O
in	O	O
the	O	O
order	O	B-API
of	O	O
importance	O	O
...	O	O

I'm	O	O
not	O	O
sure	O	O
what	O	O
the	O	O
difference	O	B-API
was	O	O
.	O	O

The	O	O
mongodb	O	O
collection	O	O
contains	O	B-API
sensor	O	O
values	O	B-API
tagged	O	O
with	O	O
date	O	B-API
and	O	O
time	O	B-API
.	O	O

This	O	O
should	O	O
not	O	O
make	O	O
any	O	B-API
difference	O	B-API
.	O	O

I	O	O
would	O	O
like	O	O
to	O	O
split	O	B-API
that	O	O
file	O	O
into	O	O
files	O	O
of	O	O
len	O	B-API
(	O	O
index	O	B-API
)	O	O
=	O	O
2	O	O
,	O	O
using	O	O
linux	O	O
:	O	O
#CODE	O	O

You	O	O
can	O	O
coerce	O	O
the	O	O
response	O	O
into	O	O
a	O	O
data	O	B-API
frame	O	O
after	O	O
you	O	O
get	O	B-API
it	O	O
.	O	O

Oh	O	O
wait	O	O
,	O	O
your	O	O
matrix	O	B-API
must	O	O
already	O	O
be	O	O
in	O	O
the	O	O
form	O	O
of	O	O
differences	O	O
from	O	O
the	O	O
mean	O	B-API
(	O	O
by	O	O
column	O	O
)	O	O
?	O	O

Any	O	O
suggestions	O	O
?	O	O

I	O	O
get	O	B-API
the	O	O
following	O	O
error	O	O
:	O	O
#CODE	O	O

I	O	O
am	O	O
curious	O	O
why	O	O
doing	O	O
`	O	O
unique_df	O	O
[	O	O
i	O	O
]	O	O
=	O	O
"	O	O
AAA	O	O
"`	O	O
no	O	O
longer	O	O
modifies	O	O
the	O	O
data	O	B-API
frame	O	O
values	O	B-API
.	O	O

Unfortunately	O	O
I	O	O
get	O	B-API
an	O	O
error	O	O
,	O	O
and	O	O
the	O	O
shading	O	O
doesn't	O	O
work	O	O
.	O	O

The	O	O
range	O	O
of	O	O
the	O	O
values	O	B-API
in	O	O
`	O	O
megaball	O	O
`	O	O
are	O	O
from	O	O
1	O	O
to	O	O
25	O	O
,	O	O
and	O	O
this	O	O
line	O	O
of	O	O
code	O	O
:	O	O
#CODE	O	O

yes	O	O
it	O	O
works	O	O
fine	O	O
but	O	O
I	O	O
need	O	O
to	O	O
drop	O	B-API
'	O	O
2014-07-16	O	O
14:24	O	O
'	O	O
thnx	O	O

If	O	O
you	O	O
have	O	O
more	O	O
pressing	O	O
things	O	O
to	O	O
do	O	O
,	O	O
you	O	O
could	O	O
temporarily	O	O
rename	O	B-API
it	O	O
out	O	O
of	O	O
the	O	O
way	O	O
to	O	O
get	O	B-API
through	O	O
your	O	O
installs	O	O
,	O	O
then	O	O
rename	O	B-API
it	O	O
back	O	B-API
.	O	O

As	O	O
you	O	O
can	O	O
see	O	O
,	O	O
the	O	O
lines	O	B-API
overlap	O	O
perfectly	O	O
for	O	O
the	O	O
days	O	B-API
where	O	B-API
there	O	O
is	O	O
data	O	B-API
:	O	O
no	O	O
original	O	O
data	O	B-API
is	O	O
'	O	O
changed	O	B-API
'	O	O
.	O	O

I	O	O
have	O	O
a	O	O
massive	O	O
file	O	O
with	O	O
per	O	O
timestamp	O	O
survey	O	O
data	O	B-API
from	O	O
about	O	O
thousands	O	O
of	O	O
different	O	O
people	O	O
and	O	O
over	O	B-API
20	O	O
different	O	O
locations	O	O
.	O	O

So	O	O
if	O	O
you	O	O
have	O	O
a	O	O
million	O	O
items	O	O
that	O	O
,	O	O
on	O	O
average	O	B-API
,	O	O
belong	O	O
to	O	O
three	O	O
categories	O	B-API
each	O	O
,	O	O
then	O	O
you	O	O
need	O	O
storage	O	O
for	O	O
the	O	O
million	O	O
items	O	O
plus	O	O
three	O	O
million	O	O
references	O	O
.	O	O

Given	O	O
how	O	O
the	O	O
sample	O	B-API
was	O	O
built	O	O
,	O	O
there	O	O
was	O	O
a	O	O
need	O	O
to	O	O
weight	O	O
adjust	O	O
the	O	O
respondent	O	O
data	O	B-API
so	O	O
that	O	O
not	O	O
every	O	O
one	O	O
is	O	O
deemed	O	O
as	O	O
"	O	O
equal	O	B-API
"	O	O
when	O	O
performing	O	O
the	O	O
analysis	O	O
.	O	O

What	O	O
I'm	O	O
hoping	O	O
to	O	O
achieve	O	O
is	O	O
knowing	O	O
where	O	B-API
the	O	O
first	O	B-API
/	O	O
last	O	B-API
row	O	O
of	O	O
trimmed	O	O
data	O	B-API
is	O	O
located	O	O
so	O	O
I	O	O
can	O	O
set	O	B-API
up	O	O
a	O	O
for-loop	O	O
to	O	O
go	O	O
through	O	O
the	O	O
data	O	B-API
and	O	O
perform	O	O
mathematical	O	O
calculations	O	O
with	O	O
the	O	O
values	O	B-API
and	O	O
then	O	O
send	O	O
those	O	O
results	O	O
back	O	B-API
into	O	O
new	O	O
columns	O	O
attached	O	O
directly	O	O
to	O	O
the	O	O
same	O	O
date	O	B-API
as	O	O
the	O	O
date	O	B-API
in	O	O
question	O	O
.	O	O

Ultimately	O	O
I	O	O
want	O	O
to	O	O
be	O	O
able	O	O
to	O	O
loop	O	O
through	O	O
the	O	O
json	O	O
to	O	O
display	O	O
the	O	O
dates	O	B-API
and	O	O
corresponding	O	O
values	O	B-API
,	O	O
but	O	O
I	O	O
cant	O	O
do	O	O
that	O	O
until	O	O
this	O	O
error	O	O
is	O	O
no	O	O
longer	O	O
happening	O	O
.	O	O

They	O	O
are	O	O
however	O	O
extremely	O	O
useful	O	O
once	O	O
you	O	O
get	O	B-API
to	O	O
grips	O	O
with	O	O
them	O	O
.	O	O

I	O	O
know	O	O
the	O	O
values	O	B-API
within	O	O
the	O	O
CSV	O	O
are	O	O
not	O	O
all	O	B-API
"	O	O
NaN	O	O
"	O	O
so	O	O
why	O	O
does	O	O
the	O	O
output	O	O
looks	O	O
like	O	O
this	O	O
and	O	O
how	O	O
can	O	O
I	O	O
get	O	B-API
the	O	O
correct	O	O
output	O	O
with	O	O
the	O	O
numbers	O	O
in	O	O
reach	O	O
of	O	O
the	O	O
rows	O	O
?	O	O

I've	O	O
filtered	O	O
my	O	O
data	O	B-API
as	O	O
suggested	O	O
here	O	O
:	O	O
With	O	O
Pandas	O	O
in	O	O
Python	O	O
,	O	O
select	O	B-API
the	O	O
highest	O	O
value	O	O
row	O	O
for	O	O
each	O	O
group	O	B-API
#CODE	O	O

I	O	O
was	O	O
able	O	O
to	O	O
get	O	B-API
the	O	O
more	O	O
precise	O	O
value	O	O
in	O	O
my	O	O
previous	O	O
environment	O	O
by	O	O
doing	O	O
the	O	O
incremental	O	O
update	O	B-API
to	O	O
cumulative	O	O
mean	O	B-API
instead	O	O
of	O	O
taking	O	O
a	O	O
batch	O	O
sum	O	B-API
and	O	O
divide	O	B-API
.	O	O

Then	O	O
use	O	B-API
the	O	O
`	O	O
~	O	O
`	O	O
to	O	O
flip	O	O
the	O	O
bools	O	O
.	O	O

