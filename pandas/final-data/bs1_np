`	O	O
fromiter	B-API	O
`	O	O
wants	O	O
a	O	O
1d	O	O
input	O	O
,	O	O
e.g.	O	B-API
`	O	O
[	O	O
1	O	O
,	O	O
2	O	O
,	O	O
3	O	O
]`	O	O
(	O	O
or	O	O
the	O	O
generator	O	O
equivalent	O	O
)	O	O
.	O	O

read	O	O
more	O	O
:	O	O
take()	B-API	O

For	O	O
this	O	O
I'm	O	O
using	O	O
an	O	O
instance	O	O
of	O	O
the	O	O
`	O	O
numpy	O	O
`	O	O
class	O	O
`	O	O
RandomState	B-API	O
`	O	O
.	O	O

You	O	O
can	O	O
write	O	O
a	O	O
thinly	O	O
wrapped	O	O
subclass	O	O
to	O	O
`	O	O
np.ndarray	B-API	B-API
`	O	O
.	O	O

Using	O	O
`	O	O
ndarray.reshape	B-API	B-API
`	O	O
#CODE	O	O

E.g.	O	B-API
this	O	O
works	O	O
in	O	O
the	O	O
interpreter	O	O
:	O	O
`	O	O
>>>	O	O
a	O	O
=	O	O
np.arange	B-API	B-API
(	O	O
10	O	O
,	O	O
dtype=float	O	O
)	O	O
.resize	B-API	B-API
(	O	O
1	O	O
,	O	O
5	O	O
)`	O	O
,	O	O
because	O	O
the	O	O
interpreter	O	O
doesn't	O	O
"	O	O
see	O	O
"	O	O
the	O	O
intermediate	O	O
value	O	O
.	O	O

I	O	O
attempted	O	O
your	O	O
suggestion	O	O
but	O	O
got	O	O
stuck	O	O
trying	O	O
to	O	O
iterate	O	O
through	O	O
the	O	O
existing	O	O
dtype	B-API	O
.	O	O

`	O	O
numpy.setdiff1d	B-API	B-API
(	O	O
a	O	O
,	O	O
a	O	O
[	O	O
sel_id	O	O
])`	O	O
should	O	O
do	O	O
the	O	O
trick	O	O
.	O	O

Instead	O	O
of	O	O
disabling	O	O
the	O	O
behavior	O	O
you	O	O
could	O	O
try	O	O
using	O	O
np.select	B-API	B-API
:	O	O

+1	O	O
I	O	O
liked	O	O
you	O	O
approach	O	O
,	O	O
but	O	O
how	O	O
to	O	O
make	O	O
`	O	O
np.copyto()	B-API	B-API
`	O	O
work	O	O
with	O	O
a	O	O
memoryvew	O	O
?	O	O

Just	O	O
import	O	O
Decimal	O	O
and	O	O
for	O	O
the	O	O
printing	O	O
just	O	O
write	O	O
print	O	O
Decimal	O	O
(	O	O
ndarray	B-API	O
[	O	O
i	O	O
])	O	O
.	O	O

Or	O	O
,	O	O
for	O	O
that	O	O
matter	O	O
,	O	O
numpy.genfromtxt	B-API	B-API
.	O	O

glad	O	O
to	O	O
hear	O	O
it	O	O
-	O	O
I	O	O
only	O	O
recently	O	O
found	O	O
out	O	O
about	O	O
`	O	O
np.einsum	B-API	B-API
`	O	O
myself	O	O
,	O	O
and	O	O
it	O	O
has	O	O
rocked	O	O
my	O	O
world	O	O
ever	O	O
since	O	O

The	O	O
`	O	O
dtype	B-API	O
`	O	O
could	O	O
be	O	O
deduced	O	O
from	O	O
one	O	O
(	O	O
or	O	O
more	O	O
)	O	O
of	O	O
the	O	O
dictionary	O	O
items	O	O
:	O	O
#CODE	O	O

I	O	O
didn't	O	O
realize	O	O
`	O	O
array_split	B-API	O
`	O	O
existed	O	O
!	O	O

However	O	O
,	O	O
in	O	O
that	O	O
case	O	O
,	O	O
you	O	O
could	O	O
just	O	O
do	O	O
:	O	O
(	O	O
`	O	O
searchsorted	B-API	O
`	O	O
uses	O	O
bisection	O	O
)	O	O
#CODE	O	O

Btw	O	O
.	O	O
you	O	O
can	O	O
also	O	O
implicitly	O	O
force	O	O
the	O	O
`	O	O
dtype	B-API	O
`	O	O
to	O	O
be	O	O
`	O	O
float	O	O
`	O	O
when	O	O
using	O	O
dots	O	O
:	O	O
#CODE	O	O

dtypes	B-API	O
.	O	O

I	O	O
would	O	O
prefer	O	O
using	O	O
the	O	O
xor	O	O
ufunc	O	O
I	O	O
think	O	O
,	O	O
which	O	O
is	O	O
`	O	O
bitwise_xor	B-API	O
`	O	O
(	O	O
or	O	O
`	O	O
logical_xor	B-API	O
`)	O	O
:	O	O
#CODE	O	O

This	O	O
is	O	O
the	O	O
root	O	O
of	O	O
why	O	O
your	O	O
`	O	O
fromarrays	B-API	O
`	O	O
works	O	O
,	O	O
but	O	O
not	O	O
the	O	O
`	O	O
append_fields	O	O
`	O	O
.	O	O

The	O	O
dtype	B-API	O
should	O	O
be	O	O
big	O	O
endian	O	O
.	O	O

parameterArray	O	O
+=	O	O
line.split()	O	B-API
\nline	O	O
=	O	O
self.inputBuffer.next()	O	B-API
\	O	O
nnp.parameterArray	O	B-API
=	O	O
np.array	B-API	B-API
(	O	O
parameterArray	O	O
)	O	O

As	O	O
JoshAdel	O	O
points	O	O
out	O	O
,	O	O
`	O	O
vectorize	B-API	O
`	O	O
wraps	O	O
`	O	O
frompyfunc	B-API	O
`	O	O
.	O	O

Sorry	O	O
,	O	O
the	O	O
line	O	O
was	O	O
output	O	O
[	O	O
i	O	O
,	O	O
j	O	O
]	O	O
=	O	O
np.sum	B-API	B-API
(	O	O
ssd_difference	O	O
[	O	O
#URL	O	O
(	O	O
)	O	O
)	O	O

(	O	O
or	O	O
`	O	O
np.array	B-API	B-API
([[	O	O
1	O	O
]	O	O
,	O	O
[	O	O
2	O	O
]	O	O
,	O	O
[	O	O
3	O	O
]	O	O
,	O	O
[	O	O
4	O	O
]])	O	O
.shape	B-API	B-API
`)	O	O

Thank	O	O
you	O	O
for	O	O
the	O	O
great	O	O
tipp	O	O
with	O	O
`	O	O
plt.hist	B-API	B-API
(	O	O
img.ravel()	O	B-API
)`	O	O
!	O	O

The	O	O
`	O	O
recarray	B-API	O
`	O	O
class	O	O
accepts	O	O
an	O	O
aligned	O	O
parameter	O	O
,	O	O
but	O	O
looks	O	O
to	O	O
lose	O	O
it	O	O
in	O	O
`	O	O
format_parser	B-API	O
`	O	O
.	O	O

In	O	O
case	O	O
someone	O	O
comes	O	O
past	O	O
this	O	O
,	O	O
numpy	O	O
(	O	O
as	O	O
of	O	O
1.8	O	O
I	O	O
think	O	O
)	O	O
support	O	O
higher	O	O
that	O	O
2D	O	O
generation	O	O
of	O	O
position	O	O
grids	O	O
with	O	O
meshgrid	B-API	O
.	O	O

`	O	O
numpy.random.choice	B-API	B-API
`	O	O
is	O	O
not	O	O
implemented	O	O
in	O	O
Python	O	O
but	O	O
in	O	O
a	O	O
`	O	O
.pyx	O	B-API
`	O	O
file	O	O
which	O	O
needs	O	O
to	O	O
be	O	O
compiled	O	O
to	O	O
C	O	O
using	O	O
Cython	O	O
.	O	O

A	O	O
plain	O	O
`	O	O
.copy	B-API	B-API
`	O	O
did	O	O
work	O	O
for	O	O
me	O	O
.	O	O

`	O	O
A	O	O
[	O	O
np.ix_	B-API	B-API
(	O	O
x	O	O
,	O	O
y	O	O
)]`	O	O

einsum	B-API	O
:	O	O
5.2	O	O
s	O	O

10**423	O	O
exceeds	O	O
the	O	O
largest	O	O
int	O	O
representable	O	O
as	O	O
an	O	O
integer	O	O
(	O	O
or	O	O
float	O	O
)	O	O
NumPy	O	O
dtype	B-API	O
,	O	O
so	O	O
there	O	O
is	O	O
no	O	O
point	O	O
in	O	O
using	O	O
NumPy	O	O
here	O	O
:	O	O
`	O	O
np.iinfo	B-API	B-API
(	O	O
'	O	O
int64	O	O
')	O	O
.max	B-API	B-API
<	O	O
10**423	O	O
`	O	O
.	O	O

Probably	O	O
,	O	O
better	O	O
performance	O	O
is	O	O
by	O	O
using	O	O
`	O	O
numpy.fromiter	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

Why	O	O
are	O	O
the	O	O
polyfit	B-API	O
constants	O	O
from	O	O
the	O	O
third	O	O
case	O	O
listed	O	O
as	O	O
NAN	O	O
?	O	O

Try	O	O
`	O	O
numpy.array_split	B-API	B-API
`	O	O
.	O	O

Using	O	O
np.repeat	B-API	B-API
on	O	O
sub-arrays	O	O

shows	O	O
that	O	O
'	O	O
region	O	O
'	O	O
has	O	O
an	O	O
`	O	O
object	O	O
`	O	O
dtype	B-API	O
:	O	O
#CODE	O	O

What	O	O
I	O	O
am	O	O
looking	O	O
for	O	O
is	O	O
something	O	O
along	O	O
the	O	O
original	O	O
functionality	O	O
of	O	O
`	O	O
np.unique	B-API	B-API
`	O	O
#CODE	O	O

In	O	O
my	O	O
opinion	O	O
,	O	O
np.matrix	B-API	B-API
should	O	O
override	O	O
for	O	O
addition	O	O
and	O	O
subtraction	O	O
as	O	O
well	O	O
.	O	O

or	O	O
`	O	O
np.vstack	B-API	B-API
`	O	O
,	O	O
`	O	O
np.dstack	B-API	B-API
`	O	O
`	O	O
np.r_	B-API	B-API
`	O	O
,	O	O
`	O	O
np.c_	B-API	B-API
`	O	O
,	O	O
`	O	O
np.concatenate	B-API	B-API
`	O	O
depending	O	O
on	O	O
the	O	O
desired	O	O
shapes	O	O
.	O	O

TypeError	O	O
when	O	O
using	O	O
SymPy	O	O
matrices	O	O
for	O	O
numpy.linalg.eig	B-API	B-API

Doing	O	O
`	O	O
a.astype	O	B-API
(	O	O
float	O	O
)`	O	O
actually	O	O
creates	O	O
a	O	O
*	O	O
new	O	O
*	O	O
ndarray	B-API	O
which	O	O
is	O	O
of	O	O
type	O	O
`	O	O
float	O	O
`	O	O
.	O	O

Trying	O	O
to	O	O
vectorize	B-API	O
the	O	O
code	O	O
also	O	O
resulted	O	O
in	O	O
very	O	O
poor	O	O
performance	O	O
,	O	O

Also	O	O
look	O	O
into	O	O
the	O	O
genfromtxt	B-API	O
and	O	O
loadtxt	B-API	O
family	O	O
of	O	O
Numpy	O	O
functions	O	O
.	O	O

`	O	O
coll	O	O
[	O	O
1	O	O
]	O	O
.set_color	B-API	B-API
(	O	O
"	O	O
r	O	O
")	O	O
#	O	O
this	O	O
does	O	O
not	O	O
work	O	O
,	O	O
coll	O	O
not	O	O
indexable	O	O
this	O	O
way	O	O
`	O	O

The	O	O
`	O	O
testing.assert_equal	B-API	B-API
`	O	O
approach	O	O
is	O	O
almost	O	O
good	O	O
,	O	O
except	O	O
that	O	O
it	O	O
presumably	O	O
fails	O	O
if	O	O
`	O	O
__debug__	O	O
`	O	O
is	O	O
False	O	O
!	O	O

I've	O	O
just	O	O
checked	O	O
and	O	O
found	O	O
out	O	O
that	O	O
my	O	O
implementation	O	O
is	O	O
about	O	O
2.x	O	O
times	O	O
*	O	O
faster	O	O
*	O	O
than	O	O
using	O	O
`	O	O
numpy.convolve	B-API	B-API
`	O	O
.	O	O

Not	O	O
as	O	O
concise	O	O
as	O	O
I	O	O
wanted	O	O
(	O	O
I	O	O
was	O	O
experimenting	O	O
with	O	O
`	O	O
mask_indices	B-API	O
`	O	O
)	O	O
,	O	O
but	O	O
this	O	O
will	O	O
also	O	O
do	O	O
the	O	O
work	O	O
:	O	O
#CODE	O	O

The	O	O
documentation	O	O
of	O	O
`	O	O
numpy.nonzero()	B-API	B-API
`	O	O
describes	O	O
how	O	O
its	O	O
result	O	O
must	O	O
be	O	O
interpreted	O	O
.	O	O

scikits-learn	O	O
pca	B-API	O
dimension	O	O
reduction	O	O
issue	O	O

`	O	O
np.mean	B-API	B-API
`	O	O
can	O	O
also	O	O
preserve	O	O
dimensions	O	O
if	O	O
needed	O	O
.	O	O

Are	O	O
there	O	O
alternatives	O	O
to	O	O
do	O	O
the	O	O
sorts	O	O
of	O	O
things	O	O
`	O	O
einsum	B-API	O
`	O	O
can	O	O
do	O	O
with	O	O
sparse	O	O
matrices	O	O
?	O	O

Your	O	O
immediate	O	O
problem	O	O
is	O	O
`	O	O
numpy.putmask	B-API	B-API
`	O	O
.	O	O

why	O	O
not	O	O
`	O	O
np.array	B-API	B-API
([	O	O
o.value1	O	B-API
for	O	O
o	O	O
in	O	O
objects	O	O
])`	O	O
?	O	O

In	O	O
a	O	O
comment	O	O
to	O	O
`	O	O
@USER	O	O
`	O	O
s	O	O
answer	O	O
I	O	O
suggested	O	O
`	O	O
np.delete	B-API	B-API
`	O	O
.	O	O

I	O	O
have	O	O
a	O	O
`	O	O
numpy.ndarray	B-API	B-API
`	O	O
.	O	O

I	O	O
believe	O	O
it	O	O
comes	O	O
down	O	O
to	O	O
the	O	O
fact	O	O
that	O	O
Python	O	O
calls	O	O
a	O	O
`	O	O
__getitem__	B-API	O
`	O	O
on	O	O
your	O	O
objects	O	O
and	O	O
treats	O	O
the	O	O
entire	O	O
block	O	O
of	O	O
code	O	O
of	O	O
`	O	O
for	O	O
`	O	O
loop	O	O
as	O	O
an	O	O
inline	O	O
statement	O	O
.	O	O

In	O	O
the	O	O
Notes	O	O
section	O	O
to	O	O
column_stack	B-API	O
,	O	O
it	O	O
points	O	O
out	O	O
this	O	O
:	O	O

`	O	O
logical_or	B-API	O
(	O	O
a	O	O
,	O	O
logical_or	B-API	O
(	O	O
b	O	O
,	O	O
c	O	O
))`	O	O

How	O	O
about	O	O
reading	O	O
them	O	O
in	O	O
correctly	O	O
as	O	O
numpy.datetime64	O	B-API
objects	O	O
using	O	O
numpy.loadtxt	B-API	B-API
(	O	O
they	O	O
are	O	O
coming	O	O
from	O	O
a	O	O
csv	O	O
file	O	O
)	O	O
?	O	O

Also	O	O
-	O	O
I	O	O
see	O	O
that	O	O
np.getfromtxt()	O	B-API
has	O	O
a	O	O
'	O	O
dtype	B-API	O
'	O	O
option	O	O
which	O	O
allows	O	O
the	O	O
user	O	O
to	O	O
specify	O	O
the	O	O
datatype	O	O
of	O	O
each	O	O
column	O	O
.	O	O

No	O	O
worries	O	O
,	O	O
the	O	O
dtype	B-API	O
is	O	O
inferred	O	O
as	O	O
`	O	O
int64	O	O
`	O	O
unless	O	O
you	O	O
pass	O	O
it	O	O
explicitly	O	O

whats	O	O
the	O	O
result	O	O
of	O	O
`	O	O
print	O	O
a	O	O
`	O	O
after	O	O
`	O	O
a	O	O
=	O	O
np.loadtxt	B-API	B-API
`	O	O

Keep	O	O
in	O	O
mind	O	O
that	O	O
`	O	O
np.cov	B-API	B-API
`	O	O
is	O	O
basically	O	O
doing	O	O
`	O	O
data.dot	O	B-API
(	O	O
data.T	O	O
)`	O	O
.	O	O

If	O	O
you	O	O
want	O	O
to	O	O
vectorize	B-API	O
operations	O	O
,	O	O
you	O	O
need	O	O
to	O	O
think	O	O
in	O	O
terms	O	O
of	O	O
these	O	O
higher	O	O
dimensional	O	O
arrays	O	O
.	O	O

Does	O	O
`	O	O
s2	O	O
=	O	O
pd.Series	B-API	O
(	O	O
s	O	O
,	O	O
dtype	B-API	O
=o	O	O
bject	O	O
)`	O	O
work	O	O
?	O	O

`	O	O
PyArray_DATA	B-API	O
`	O	O
is	O	O
defined	O	O
in	O	O

`	O	O
a	O	O
[:	O	O
,	O	O
:	O	O
,	O	O
5	O	O
]	O	O
.shape	B-API	B-API
=	O	O
(	O	O
10	O	O
,	O	O
10	O	O
,	O	O
1	O	O
)`	O	O

Can	O	O
you	O	O
print	O	O
`	O	O
datas	O	O
[	O	O
0	O	O
]	O	O
.shape	B-API	B-API
`	O	O
?	O	O

actually	O	O
used	O	O
is	O	O
this	O	O
line	O	O
within	O	O
the	O	O
definition	O	O
for	O	O
`	O	O
np.array_repr	B-API	B-API
`	O	O

That's	O	O
why	O	O
`	O	O
dstack	B-API	O
`	O	O
behaves	O	O
the	O	O
way	O	O
it	O	O
does	O	O
.	O	O

>>>	O	O
x	O	O
=	O	O
np.asanyarray	B-API	B-API
(	O	O
[	O	O
]	O	O
,	O	O
dtype=	O	O
'	O	O
float64	O	O
')	O	O

This	O	O
doesn't	O	O
work	O	O
for	O	O
floating	O	O
point	O	O
types	O	O
(	O	O
it	O	O
will	O	O
not	O	O
consider	O	O
+	O	O
0.0	O	O
and	O	O
-	O	O
0.0	O	O
the	O	O
same	O	O
value	O	O
)	O	O
,	O	O
and	O	O
`	O	O
np.intersect1d	B-API	B-API
`	O	O
uses	O	O
sorting	O	O
,	O	O
so	O	O
it	O	O
is	O	O
has	O	O
linearithmic	O	O
,	O	O
not	O	O
linear	O	O
,	O	O
performance	O	O
.	O	O

But	O	O
off	O	O
course	O	O
,	O	O
isreal	B-API	O
would	O	O
be	O	O
more	O	O
readable	O	O
:-)	O	O

mshgrd	O	O
=	O	O
ax.pcolormesh	B-API	B-API
(	O	O
X	O	O
,	O	O
Y	O	O
,	O	O
Z	O	O
)	O	O

Otherwise	O	O
,	O	O
the	O	O
performance	O	O
advantages	O	O
of	O	O
using	O	O
numpy	O	O
are	O	O
quickly	O	O
nullified	O	O
,	O	O
regardless	O	O
of	O	O
how	O	O
you	O	O
implement	O	O
your	O	O
ringbuffer	B-API	O
.	O	O

The	O	O
answer	O	O
is	O	O
numpy.clip	B-API	B-API
#CODE	O	O

Can	O	O
you	O	O
please	O	O
go	O	O
into	O	O
more	O	O
depth	O	O
about	O	O
nesting	O	O
a	O	O
recarray	B-API	O
in	O	O
another	O	O
by	O	O
using	O	O
the	O	O
np.object	O	B-API
method	O	O
?	O	O

Why	O	O
do	O	O
you	O	O
need	O	O
`	O	O
vectorize	B-API	O
`	O	O
for	O	O
that	O	O
?	O	O

I	O	O
did	O	O
try	O	O
gc.colletc()	O	B-API
without	O	O
success	O	O
but	O	O
adding	O	O
a	O	O
clf()	B-API	O
inside	O	O
the	O	O
loop	O	O
does	O	O
the	O	O
trick	O	O
!	O	O

not	O	O
a	O	O
bad	O	O
solution	O	O
;	O	O
though	O	O
I	O	O
am	O	O
somewhat	O	O
wary	O	O
of	O	O
the	O	O
performance	O	O
of	O	O
random.shuffle	B-API	B-API
.	O	O

date2num	B-API	O
,	O	O
ValueError	O	O
:	O	O
ordinal	O	O
must	O	O
be	O	O
>	O	O
=	O	O
1	O	O

And	O	O
you	O	O
could	O	O
override	O	O
`	O	O
__mul__	B-API	O
`	O	O
,	O	O
`	O	O
__add__	B-API	O
`	O	O
,	O	O
`	O	O
__sub__	B-API	O
`	O	O
accordingly	O	O
,	O	O
but	O	O
I	O	O
don't	O	O
know	O	O
exactly	O	O
how	O	O
numpy-like	O	O
you	O	O
actually	O	O
*	O	O
need	O	O
*	O	O
this	O	O
to	O	O
be	O	O
,	O	O
so	O	O
I	O	O
can't	O	O
say	O	O
for	O	O
sure	O	O
.	O	O

`	O	O
np.array	B-API	B-API
=	O	O
partial	O	O
(	O	O
np.array	B-API	B-API
,	O	O
dtype=	O	O
np.float32	O	B-API
)`	O	O
with	O	O
`	O	O
partial	O	O
`	O	O
from	O	O
the	O	O
`	O	O
functools	O	O
`	O	O
module	O	O
.	O	O

A	O	O
solution	O	O
that	O	O
worked	O	O
uses	O	O
griddata	B-API	O
.	O	O

Numpy	O	O
1.7.0	O	O
assert_array_almost_equal	B-API	O
documentation	O	O

You	O	O
can	O	O
read	O	O
matlab	O	O
(	O	O
.mat	B-API	B-API
)	O	O
files	O	O
in	O	O
Python	O	O
,	O	O
try	O	O
this	O	O
:	O	O
#CODE	O	O

Thanks	O	O
for	O	O
the	O	O
idea	O	O
of	O	O
genfromtxt()	B-API	O
.	O	O

If	O	O
you	O	O
are	O	O
using	O	O
numpy	O	O
,	O	O
for	O	O
multidimensional	O	O
lists	O	O
`	O	O
numpy.repeat	B-API	B-API
`	O	O
is	O	O
your	O	O
best	O	O
bet	O	O
.	O	O

If	O	O
the	O	O
following	O	O
equation	O	O
is	O	O
element-wise	O	O
True	O	O
,	O	O
then	O	O
allclose	B-API	O
returns	O	O
`	O	O
True	O	O
`	O	O
:	O	O
#CODE	O	O

`	O	O
np.vstack	B-API	B-API
`	O	O
just	O	O
vertically	O	O
stacks	O	O
the	O	O
arrays	O	O
you	O	O
pass	O	O
to	O	O
it	O	O
,	O	O
and	O	O
so	O	O
something	O	O
else	O	O
in	O	O
your	O	O
code	O	O
may	O	O
be	O	O
cutting	O	O
off	O	O
the	O	O
rest	O	O
of	O	O
the	O	O
results	O	O
inadvertently	O	O
.	O	O

If	O	O
you	O	O
move	O	O
the	O	O
line	O	O
`	O	O
np_verticies=	O	O
np.array	B-API	B-API
(	O	O
verticies	O	O
)`	O	O
outside	O	O
of	O	O
`	O	O
Fnumpy	O	O
`	O	O
and	O	O
the	O	O
timed	O	O
section	O	O
your	O	O
results	O	O
will	O	O
be	O	O
very	O	O
different	O	O
:	O	O
#CODE	O	O

`	O	O
fromiter	B-API	O
`'	O	O
s	O	O
example	O	O
is	O	O
essentially	O	O
this	O	O
:	O	O
`	O	O
np.fromiter	B-API	B-API
((	O	O
x*x	O	O
for	O	O
x	O	O
in	O	O
range	O	O
(	O	O
5	O	O
))	O	O
,	O	O
int	O	O
)`	O	O
.	O	O

In	O	O
Python	O	O
,	O	O
I	O	O
have	O	O
a	O	O
numpy.array	B-API	B-API
of	O	O
integers	O	O
`	O	O
[	O	O
2	O	O
,	O	O
4	O	O
,	O	O
7	O	O
,	O	O
8	O	O
,	O	O
9	O	O
,	O	O
10	O	O
,	O	O
15	O	O
,	O	O
10	O	O
8]	O	O
`	O	O
.	O	O

I	O	O
will	O	O
go	O	O
with	O	O
newaxis	B-API	O
then	O	O
.	O	O

pcolormesh	B-API	O
returns	O	O
a	O	O
QuadMesh	B-API	O
.	O	O

And	O	O
when	O	O
I	O	O
call	O	O
each	O	O
of	O	O
the	O	O
instructions	O	O
inside	O	O
f()	B-API	O
individually	O	O
it	O	O
gives	O	O
me	O	O
an	O	O
other	O	O
result	O	O
(	O	O
which	O	O
is	O	O
correct	O	O
):	O	O
#CODE	O	O

Here's	O	O
one	O	O
vectorized	O	O
approach	O	O
based	O	O
on	O	O
`	O	O
np.einsum	B-API	B-API
`	O	O
-	O	O
#CODE	O	O

What's	O	O
the	O	O
`	O	O
dtype	B-API	O
`	O	O
of	O	O
these	O	O
arrays	O	O
?	O	O

try	O	O
adding	O	O
a	O	O
`	O	O
show()	B-API	O
`	O	O
in	O	O
the	O	O
end	O	O

`	O	O
pandas.DataFrame	B-API	O
`	O	O

You	O	O
can	O	O
define	O	O
your	O	O
own	O	O
types	O	O
by	O	O
creating	O	O
a	O	O
class	O	O
and	O	O
writing	O	O
a	O	O
`	O	O
__add__	B-API	O
`	O	O
or	O	O
`	O	O
__sub__	B-API	O
`	O	O
method	O	O
.	O	O

On	O	O
the	O	O
other	O	O
hand	O	O
,	O	O
if	O	O
I	O	O
did	O	O
with	O	O
`	O	O
genfromtxt	B-API	O
`	O	O
,	O	O
the	O	O
third	O	O
column	O	O
is	O	O
problem	O	O
because	O	O
it	O	O
includes	O	O
comma	O	O
inside	O	O
double-quota	O	O
.	O	O

Apparently	O	O
,	O	O
if	O	O
there	O	O
is	O	O
no	O	O
'	O	O
missing_value	O	O
'	O	O
attribute	O	O
Netcdf4	O	O
defaults	O	O
to	O	O
a	O	O
missing	O	O
value	O	O
appropriate	O	O
for	O	O
the	O	O
dtype	B-API	O
.	O	O

do	O	O
be	O	O
aware	O	O
that	O	O
if	O	O
you	O	O
have	O	O
NaNs	O	O
,	O	O
there	O	O
is	O	O
an	O	O
equivalent	O	O
np.nanstd	B-API	B-API
with	O	O
the	O	O
similar	O	O
ddof	O	O
options	O	O

[	O	O
True	O	O
,	O	O
True	O	O
]]	O	O
,	O	O
dtype	B-API	O
=b	O	O
ool	O	O
)`	O	O

@USER	O	O
true	O	O
,	O	O
although	O	O
`	O	O
np.array	B-API	B-API
([	O	O
x	O	O
for	O	O
bb	O	O
in	O	O
b	O	O
for	O	O
x	O	O
in	O	O
bb	O	O
])`	O	O
will	O	O
do	O	O
the	O	O
job	O	O
.	O	O

return	O	O
matrix_power	B-API	O
(	O	O
self	O	O
,	O	O
other	O	O
)	O	O

vector	O	O
=	O	O
numpy.array	B-API	B-API
(	O	O
vector	O	O
);	O	O

If	O	O
so	O	O
then	O	O
you	O	O
should	O	O
have	O	O
no	O	O
problem	O	O
fitting	O	O
the	O	O
`	O	O
numpy.fft.rfftfreq	B-API	B-API
`	O	O
method	O	O
into	O	O
your	O	O
own	O	O
code	O	O
.	O	O

This	O	O
fails	O	O
:	O	O
`	O	O
einsum	B-API	O
(	O	O
'	O	O
i	O	O
...,	O	O
i	O	O
...	O	O

Python	O	O
&	O	O
Numpy	O	O
-	O	O
create	O	O
dynamic	O	O
,	O	O
arbitrary	O	O
subsets	O	O
of	O	O
ndarray	B-API	O

For	O	O
example	O	O
,	O	O
I	O	O
have	O	O
a	O	O
`	O	O
ndarray	B-API	O
`	O	O
that	O	O
is	O	O
:	O	O
#CODE	O	O

I	O	O
went	O	O
with	O	O
the	O	O
np.memmap	B-API	B-API
because	O	O
the	O	O
performance	O	O
is	O	O
similar	O	O
to	O	O
hdf5	O	O
and	O	O
I	O	O
already	O	O
have	O	O
numpy	O	O
in	O	O
production	O	O
.	O	O

its	O	O
np.log	B-API	B-API
not	O	O
m.log	O	B-API

what	O	O
happens	O	O
if	O	O
you	O	O
[	O	O
`	O	O
Py_INCREF	O	O
(	O	O
self	O	O
)`]	O	O
(	O	O
#URL	O	O
)	O	O
after	O	O
`	O	O
.base	B-API	B-API
`	O	O
assignment	O	O
?	O	O

File	O	O
"	O	O
/	O	O
usr	O	O
/	O	O
lib64	O	O
/	O	O
python2.6	O	O
/	O	O
site-packages	O	O
/	O	O
numpy	O	O
/	O	O
core	O	O
/	O	O
fromnumeric.py	O	B-API
"	O	O
,	O	O
line	O	O
806	O	O
,	O	O
in	O	O
searchsorted	B-API	O

why	O	O
isn't	O	O
the	O	O
`	O	O
ndarray	B-API	O
`	O	O
constructor	O	O
mentioned	O	O
here	O	O
?	O	O

>>>	O	O
z	O	O
=	O	O
numpy.array	B-API	B-API
([	O	O
1	O	O
,	O	O
2	O	O
]	O	O

Is	O	O
there	O	O
an	O	O
equivelent	O	O
to	O	O
`	O	O
fseek	O	O
`	O	O
when	O	O
using	O	O
`	O	O
fromfile	B-API	O
`	O	O
to	O	O
skip	O	O
the	O	O
beginning	O	O
of	O	O
the	O	O
file	O	O
?	O	O

The	O	O
linear	O	O
algebra	O	O
functions	O	O
are	O	O
generally	O	O
grouped	O	O
in	O	O
`	O	O
numpy.linalg	B-API	B-API
`	O	O
.	O	O

np.mean	B-API	B-API
:	O	O
#CODE	O	O

As	O	O
others	O	O
have	O	O
said	O	O
,	O	O
32-bit	O	O
versions	O	O
of	O	O
numpy	O	O
still	O	O
support	O	O
64-bit	O	O
dtypes	B-API	O
.	O	O

`	O	O
vstack	B-API	O
`	O	O
is	O	O
coercing	O	O
the	O	O
type	O	O
of	O	O
`	O	O
d	O	O
`	O	O
to	O	O
the	O	O
type	O	O
of	O	O
`	O	O
e	O	O
`	O	O
.	O	O

`	O	O
df.plot	B-API	B-API
`	O	O
returns	O	O
an	O	O
AxesSubplot	O	O
,	O	O
which	O	O
has	O	O
a	O	O
`	O	O
axvspan	B-API	O
`	O	O
method	O	O
.	O	O

With	O	O
the	O	O
variables	O	O
defined	O	O
above	O	O
,	O	O
`	O	O
np.searchsorted	B-API	B-API
(	O	O
lat	O	O
,	O	O
x	O	O
)`	O	O
is	O	O
16x	O	O
faster	O	O
than	O	O
the	O	O
equivalent	O	O
call	O	O
`	O	O
np.nanargmin	B-API	B-API
((	O	O
lat-x	O	O
)	O	O
**2	O	O
)`	O	O
on	O	O
my	O	O
computer	O	O
.	O	O

Pypy	O	O
with	O	O
iterators	O	O
is	O	O
still	O	O
solving	O	O
this	O	O
about	O	O
3x	O	O
faster	O	O
than	O	O
CPython	O	O
+	O	O
Numpy	O	O
,	O	O
even	O	O
when	O	O
using	O	O
`	O	O
np.searchsorted	B-API	B-API
`	O	O
(	O	O
see	O	O
my	O	O
solution	O	O
)	O	O
.	O	O

and	O	O
`	O	O
hstack	B-API	O
((	O	O
a	O	O
,	O	O
z	O	O
))`	O	O
?	O	O

Have	O	O
you	O	O
tried	O	O
passing	O	O
`	O	O
interpolation=	O	O
'	O	O
nearest	O	O
'`	O	O
to	O	O
`	O	O
imshow	B-API	O
`	O	O
?	O	O

`	O	O
cumsum	B-API	O
`	O	O
might	O	O
not	O	O
be	O	O
the	O	O
best	O	O
example	O	O
.	O	O

I	O	O
think	O	O
you're	O	O
after	O	O
`	O	O
plt.axis	B-API	B-API
([	O	O
xmin	O	O
,	O	O
xmax	O	O
,	O	O
ymin	O	O
,	O	O
ymax	O	O
])`	O	O
:	O	O
#CODE	O	O

Is	O	O
`	O	O
(	O	O
dry	O	O
,	O	O
unrch	O	O
)	O	O
=	O	O
((	O	O
G	O	O
==	O	O
3	O	O
)	O	O
.sum()	B-API	B-API
,	O	O
(	O	O
G	O	O
==	O	O
1	O	O
)	O	O
.sum()	B-API	B-API
)`	O	O
more	O	O
vectorized	O	O
?	O	O

Then	O	O
,	O	O
`	O	O
np.array	B-API	B-API
(	O	O
np.matrix	B-API	B-API
(	O	O
s.strip	O	B-API
(	O	O
'	O	O
[	O	O
]')))`	O	O
will	O	O
do	O	O
the	O	O
same	O	O
magic	O	O
.	O	O

I'm	O	O
trying	O	O
to	O	O
vectorize	B-API	O
Z	O	O
,	O	O
but	O	O
I'm	O	O
finding	O	O
it	O	O
rather	O	O
difficult	O	O
for	O	O
a	O	O
triple	O	O
for	O	O
loop	O	O
.	O	O

How	O	O
would	O	O
that	O	O
be	O	O
done	O	O
using	O	O
np.dot	B-API	B-API
?	O	O

I	O	O
was	O	O
surprised	O	O
how	O	O
descending	O	O
sorting	O	O
of	O	O
np.array	B-API	B-API
seem	O	O
so	O	O
un-pythonic	O	O
.	O	O

`	O	O
numpy.genfromtxt	B-API	B-API
`	O	O
accepts	O	O
generators	O	O
,	O	O
so	O	O
you	O	O
can	O	O
chain	O	O
`	O	O
genfromtext	O	O
`	O	O
and	O	O
`	O	O
ifilter	O	O
`	O	O
:	O	O
#CODE	O	O

I	O	O
also	O	O
tried	O	O
`	O	O
df.query()	B-API	B-API
`	O	O
,	O	O
but	O	O
no	O	O
much	O	O
improvement	O	O
.	O	O

According	O	O
to	O	O
the	O	O
documentation	O	O
(	O	O
e.g.	O	B-API
,	O	O
here	O	O
)	O	O
,	O	O
`	O	O
PyArray_SimpleNew	B-API	O
`	O	O
has	O	O
a	O	O
return	O	O
of	O	O
type	O	O
`	O	O
PyObject	O	O
*	O	O
`	O	O
and	O	O
thus	O	O
the	O	O
above	O	O
should	O	O
be	O	O
perfectly	O	O
fine	O	O
.	O	O

Edit	O	O
:	O	O
`	O	O
np.where	B-API	B-API
`	O	O
is	O	O
optional	O	O
,	O	O
thanks	O	O
@USER	O	O
.	O	O

or	O	O
with	O	O
`	O	O
numpy.concatenate	B-API	B-API
`	O	O
?	O	O

@USER	O	O
you	O	O
can	O	O
do	O	O
it	O	O
,	O	O
it's	O	O
easy	O	O
with	O	O
`	O	O
np.histogram	B-API	B-API
`	O	O
.	O	O

`	O	O
numpy.base_repr	B-API	B-API
`	O	O
uses	O	O
this	O	O
,	O	O
but	O	O
only	O	O
operates	O	O
on	O	O
scalars	O	O
.	O	O

Python	O	O
apply_along_axis	B-API	O
of	O	O
multiple	O	O
arrays	O	O

`	O	O
numpy.average()	B-API	B-API
`	O	O
has	O	O
a	O	O
weights	O	O
option	O	O
,	O	O
but	O	O
`	O	O
numpy.std()	B-API	B-API
`	O	O
does	O	O
not	O	O
.	O	O

I	O	O
wanted	O	O
to	O	O
write	O	O
`	O	O
M.det()	O	B-API
`	O	O
instead	O	O
of	O	O
`	O	O
numpy.linalg.det	B-API	B-API
(	O	O
M	O	O
)`	O	O
,	O	O

I	O	O
was	O	O
working	O	O
with	O	O
something	O	O
like	O	O
```	O	O
s	O	O
=	O	O
pd.DataFrame	B-API	O
([	O	O
'	O	O
1	O	O
'	O	O
,	O	O
'	O	O
na	O	O
'	O	O
,	O	O
'	O	O
3	O	O
'	O	O
,	O	O
'	O	O
4	O	O
'])	O	O
.	O	O

tested	O	O
it	O	O
a	O	O
bit	O	O
myself	O	O
:	O	O
sympy.sin	O	B-API
is	O	O
much	O	O
slower	O	O
than	O	O
numpy.sin	B-API	B-API

I	O	O
was	O	O
thinking	O	O
of	O	O
something	O	O
like	O	O
`	O	O
frombuffer	B-API	O
`	O	O
.	O	O

OLS	O	O
solution	O	O
using	O	O
pinv	B-API	O
/	O	O
svd	B-API	B-API
#CODE	O	O

The	O	O
bad	O	O
days	O	B-API
are	O	O
eliminated	O	O
,	O	O
and	O	O
the	O	O
good	O	O
ones	O	B-API
are	O	O
kept	O	O
.	O	O

@USER	O	O
Well	O	O
in	O	O
this	O	O
case	O	O
,	O	O
`	O	O
searchsorted	B-API	O
`	O	O
is	O	O
basically	O	O
looking	O	O
for	O	O
places	O	O
or	O	O
indices	O	B-API
where	O	B-API
elements	O	O
from	O	O
`	O	O
message	O	O
`	O	O
exists	O	B-API
in	O	O
the	O	O
keys	O	B-API
of	O	O
`	O	O
codes	O	B-API
`	O	O
.	O	O

@USER	O	O
--	O	O
I	O	O
had	O	O
a	O	O
hard	O	O
time	O	B-API
remembering	O	O
how	O	O
`	O	O
translate	O	B-API
`	O	O
and	O	O
`	O	O
maketrans	O	O
`	O	O
work	O	O
for	O	O
quite	O	O
a	O	O
while	O	O
too	O	O
,	O	O
but	O	O
I've	O	O
gotten	O	O
used	O	O
to	O	O
it	O	O
.	O	O

Edit	O	O
:	O	O
if	O	O
you're	O	O
using	O	O
a	O	O
version	O	O
of	O	O
numpy	O	O
>	O	O
=	O	O
1.8.0	O	O
,	O	O
then	O	O
`	O	O
np.linalg.eigvals	B-API	B-API
`	O	O
operates	O	O
over	O	B-API
the	O	O
last	O	B-API
two	O	O
dimensions	O	O
of	O	O
whatever	O	O
array	O	B-API
you	O	O
hand	O	O
it	O	O
,	O	O
so	O	O
if	O	O
you	O	O
reshape	O	B-API
your	O	O
input	O	O
to	O	O
an	O	O
`	O	O
(	O	O
n_subarrays	O	O
,	O	O
nrows	O	O
,	O	O
ncols	O	O
)`	O	O
array	O	B-API
you'll	O	O
only	O	O
have	O	O
to	O	O
call	O	O
`	O	O
eigvals	B-API	O
`	O	O
once	O	O
:	O	O
#CODE	O	O

`	O	O
reshape	B-API	B-API
`	O	O
returns	O	O
a	O	O
view	O	B-API
of	O	O
the	O	O
original	O	O
array	O	B-API
,	O	O
not	O	O
a	O	O
copy	O	B-API
,	O	O
so	O	O
the	O	O
conversion	O	O
to	O	O
3D	O	O
only	O	O
requires	O	O
altering	O	O
the	O	O
`	O	O
shape	O	B-API
`	O	O
and	O	O
`	O	O
strides	O	B-API
`	O	O
attributes	O	O
of	O	O
the	O	O
array	O	B-API
,	O	O
without	O	O
having	O	O
to	O	O
copy	O	B-API
any	O	B-API
of	O	O
the	O	O
actual	O	O
data	O	B-API
.	O	O

sum	O	B-API
this	O	O
new	O	O
array	O	B-API
along	O	O
particular	O	O
axes	O	B-API
;	O	O
and	O	O
then	O	O
maybe	O	O

Calling	O	O
`	O	O
reshape	B-API	B-API
`	O	O
returns	O	O
a	O	O
view	O	B-API
,	O	O
so	O	O
it	O	O
doesn't	O	O
incur	O	O
any	O	B-API
big	O	O
copying	O	O
costs	O	O
or	O	O
anything	O	O
like	O	O
that	O	O
.	O	O

so	O	O
at	O	B-API
some	O	O
point	O	O
in	O	O
the	O	O
execution	O	O
it	O	O
will	O	O
max	O	B-API
my	O	O
memory	O	O
.	O	O

Note	O	O
that	O	O
extension	O	O
to	O	O
even	O	O
higher	O	O
combinatorics	O	O
should	O	O
be	O	O
trivial	O	O
,	O	O
along	O	O
the	O	O
lines	O	B-API
presented	O	O
;	O	O
but	O	O
keep	O	O
an	O	O
eye	O	B-API
on	O	O
the	O	O
n	O	O
used	O	O
in	O	O
that	O	O
case	O	O
.	O	O

These	O	O
functions	O	O
return	O	O
a	O	O
list	O	B-API
,	O	O
which	O	O
I	O	O
convert	O	B-API
to	O	O
a	O	O
numpy	O	O
array	O	B-API
and	O	O
then	O	O
sum	O	B-API
over	O	B-API
.	O	O

Can	O	O
it	O	O
be	O	O
because	O	O
of	O	O
the	O	O
many	O	O
zeros	O	B-API
in	O	O
the	O	O
initial	O	O
table	O	B-API
?	O	O

I	O	O
also	O	O
understand	O	O
that	O	O
sum	B-API	B-API
(	O	O
A	O	O
,	O	O
axis=1	O	O
)	O	O
will	O	O
sum	O	B-API
each	O	O
row	O	O
.	O	O

But	O	O
what	O	O
I	O	O
really	O	O
want	O	O
to	O	O
do	O	O
,	O	O
is	O	O
to	O	O
bin	O	O
`	O	O
array	O	B-API
[:	O	O
,	O	O
1	O	O
]`	O	O
by	O	O
day	O	B-API
(	O	O
as	O	O
derived	O	O
by	O	O
the	O	O
unix	O	O
timestamps	O	O
in	O	O
array	O	B-API
[:	O	O
,	O	O
0	O	O
])	O	O
,	O	O
and	O	O
plot	O	B-API
these	O	O
as	O	O
a	O	O
stacked	O	O
histogram	O	B-API
,	O	O
with	O	O
each	O	O
(	O	O
colored	O	O
)	O	O
stack	O	B-API
representing	O	O
a	O	O
day	O	B-API
.	O	O

It's	O	O
interesting	O	O
to	O	O
see	O	O
that	O	O
when	O	O
I	O	O
go	O	O
back	O	B-API
to	O	O
`	O	O
nloop=1000	O	O
`	O	O
,	O	O
`	O	O
nreps=3	O	O
`	O	O
I	O	O
actually	O	O
see	O	O
a	O	O
slightly	O	O
*	O	O
greater	O	B-API
*	O	O
rate	O	B-API
of	O	O
cache	O	O
misses	O	O
for	O	O
the	O	O
row	O	O
sum	O	B-API
(	O	O
17%	O	O
vs	O	O
13%	O	O
)	O	O
,	O	O
even	O	O
though	O	O
it's	O	O
faster	O	O
than	O	O
the	O	O
column	O	O
sum	O	B-API
.	O	O

You	O	O
can	O	O
concatenate	O	B-API
arrays	O	O
in	O	O
`	O	O
numpy	O	O
`	O	O
.	O	O

If	O	O
you	O	O
are	O	O
100%	O	O
sure	O	O
that	O	O
l2	O	O
would	O	O
only	O	O
be	O	O
one	O	O
column	O	O
then	O	O
you	O	O
can	O	O
reshape	O	B-API
that	O	O
array	O	B-API
to	O	O
make	O	O
it	O	O
one	O	O
dimensional	O	O
before	O	O
doing	O	O
the	O	O
subtraction	O	O
.	O	O

You	O	O
won't	O	O
be	O	O
able	O	O
to	O	O
create	O	O
a	O	O
2D	O	O
array	O	B-API
that	O	O
way	O	O
,	O	O
and	O	O
@USER	O	O
method	O	O
of	O	O
returning	O	O
a	O	O
1D	O	O
array	O	B-API
that	O	O
you	O	O
reshape	O	B-API
afterwards	O	O
is	O	O
a	O	O
sure	O	O
go	O	O
.	O	O

I	O	O
have	O	O
a	O	O
square	O	B-API
matrix	O	B-API
A	O	O
(	O	O
could	O	O
be	O	O
any	O	B-API
size	O	B-API
)	O	O
and	O	O
I	O	O
want	O	O
to	O	O
take	O	B-API
the	O	O
upper	O	B-API
triangular	O	B-API
part	O	O
and	O	O
place	O	B-API
those	O	O
values	O	B-API
in	O	O
an	O	O
array	O	B-API
without	O	O
the	O	O
values	O	B-API
below	O	O
the	O	O
center	O	B-API
diagonal	O	B-API
(	O	O
k=0	O	O
)	O	O
.	O	O

You	O	O
can	O	O
mimic	O	O
this	O	O
behavior	O	O
with	O	O
a	O	O
simple	O	O
function	O	B-API
to	O	O
flatten	O	B-API
a	O	O
list	O	B-API
:	O	O
#CODE	O	O

So	O	O
`	O	O
popt	O	O
`	O	O
,	O	O
according	O	O
to	O	O
the	O	O
documentation	O	O
,	O	O
returns	O	O
*	O	O
"	O	O
Optimal	O	O
values	O	B-API
for	O	O
the	O	O
parameters	O	O
so	O	O
that	O	O
the	O	O
sum	O	B-API
of	O	O
the	O	O
squared	O	O
error	O	O
of	O	O
f	O	B-API
(	O	O
xdata	O	O
,	O	O
popt	O	O
)	O	O
-	O	O
ydata	O	O
is	O	O
minimized	O	O
"	O	O
.	O	O

And	O	O
I'd	O	O
like	O	O
indices	O	B-API
`	O	O
i	O	O
`	O	O
such	O	O
that	O	O
,	O	O
#CODE	O	O

But	O	O
,	O	O
`	O	O
resize	B-API	B-API
`	O	O
looks	O	O
like	O	O
it	O	O
just	O	O
might	O	O
be	O	O
the	O	O
thing	O	O
I'm	O	O
looking	O	O
for	O	O
...	O	O

`	O	O
rfft	B-API	O
`	O	O
,	O	O
apart	O	O
from	O	O
repeated	O	O
terms	O	O
excluded	O	O
,	O	O
and	O	O
an	O	O
almost	O	O
2x	O	O
speed-up	O	O
,	O	O
returns	O	O
the	O	O
exact	O	O
same	O	O
you	O	O
would	O	O
get	O	B-API
from	O	O
`	O	O
fft	B-API	B-API
`	O	O
.	O	O

Plus	O	O
,	O	O
if	O	O
I	O	O
have	O	O
4	O	O
dimensions	O	O
,	O	O
I	O	O
thought	O	O
I	O	O
should	O	O
have	O	O
4	O	O
eigenvalues	O	O
and	O	O
not	O	O
150	O	O
like	O	O
the	O	O
eig	B-API	B-API
gives	O	O
me	O	O
.	O	O

If	O	O
I	O	O
run	O	O
your	O	O
code	O	O
to	O	O
generate	O	O
`	O	O
d	O	O
`	O	O
and	O	O
`	O	O
dx	O	O
`	O	O
with	O	O
`	O	O
eig	B-API	B-API
`	O	O
I	O	O
get	O	B-API
the	O	O
following	O	O
:	O	O
#CODE	O	O

In	O	O
other	O	O
words-	O	O
it	O	O
is	O	O
not	O	O
just	O	O
taking	O	O
a	O	O
min	O	B-API
or	O	O
max	O	B-API
.	O	O

D	O	O
[	O	O
I+1	O	O
,	O	O
J+1	O	O
]	O	O
=	O	O
map	B-API	B-API
(	O	O
norm	O	B-API
,	O	O
x	O	O
[	O	O
I	O	O
]	O	O
-y	O	O
[	O	O
J	O	O
])	O	O
+	O	O
np.minimum	B-API	B-API
(	O	O
np.minimum	B-API	B-API
(	O	O
D	O	O
[	O	O
I	O	O
,	O	O
J	O	O
]	O	O
,	O	O
D	O	O
[	O	O
I	O	O
,	O	O
J+1	O	O
])	O	O
,	O	O
D	O	O
[	O	O
I+1	O	O
,	O	O
J	O	O
])	O	O
?	O	O

`	O	O
dot	B-API	B-API
`	O	O
just	O	O
has	O	O
tighter	O	O
code	O	O
for	O	O
a	O	O
specific	O	O
combination	O	O
of	O	O
dimensions	O	O
.	O	O

numpy	O	O
sum	B-API	B-API
does	O	O
not	O	O
agree	O	O

Since	O	O
you	O	O
are	O	O
only	O	O
adding	O	O
many	O	O
`	O	O
1	O	O
`	O	O
s	O	O
you	O	O
can	O	O
convert	O	B-API
`	O	O
diff	O	B-API
`	O	O
to	O	O
`	O	O
bool	O	B-API
`	O	O
:	O	O
#CODE	O	O

It	O	O
isn't	O	O
mathematically	O	O
possible	O	O
to	O	O
represent	O	O
0	O	O
on	O	O
a	O	O
log	O	B-API
scale	O	O
,	O	O
so	O	O
the	O	O
first	O	B-API
value	O	O
will	O	O
have	O	O
to	O	O
either	O	O
be	O	O
masked	O	B-API
or	O	O
clipped	O	O
to	O	O
a	O	O
very	O	O
small	O	O
positive	O	O
number	O	O
.	O	O

possible	O	O
duplicate	O	O
of	O	O
[	O	O
Efficiently	O	O
count	O	B-API
the	O	O
number	O	O
of	O	O
occurrences	O	O
of	O	O
unique	O	B-API
subarrays	O	O
in	O	O
NumPy	O	O
?	O	O
]	O	O
(	O	O
#URL	O	O
)	O	O

Or	O	O
you	O	O
could	O	O
mask	O	B-API
the	O	O
x	O	O
value	O	O
as	O	O
well	O	O
,	O	O
so	O	O
the	O	O
indices	O	B-API
were	O	O
consistent	O	O
between	O	B-API
x	O	O
and	O	O
y	O	O
#CODE	O	O

Here	O	O
the	O	O
`	O	O
outer	B-API	B-API
`	O	O
method	O	O
of	O	O
the	O	O
`	O	O
multiply	B-API	B-API
`	O	O
ufunc	O	O
is	O	O
used	O	O
to	O	O
create	O	O
the	O	O
new	O	O
20x20	O	O
array	O	B-API
.	O	O

I	O	O
have	O	O
a	O	O
3D	O	O
numpy	O	O
array	O	B-API
consisting	O	O
of	O	O
1's	O	O
and	O	O
zeros	O	B-API
defining	O	O
open	O	B-API
versus	O	O
filled	O	B-API
space	O	B-API
in	O	O
a	O	O
porous	O	O
solid	O	O
(	O	O
it's	O	O
currently	O	O
a	O	O
numpy	O	O
Int64	O	O
array	O	B-API
)	O	O
.	O	O

You	O	O
are	O	O
attempting	O	O
to	O	O
broadcast	O	B-API
a	O	O
4-D	O	O
array	O	B-API
together	O	O
with	O	O
a	O	O
3-D	O	O
array	O	B-API
.	O	O

Scipy	O	O
NDimage	O	O
correlate	O	B-API
:	O	O
unbearably	O	O
slow	O	B-API

I	O	O
know	O	O
that	O	O
I	O	O
can	O	O
reshape	O	B-API
the	O	O
array	O	B-API
to	O	O
a	O	O
100	O	O
x	O	O
2	O	O
array	O	B-API
of	O	O
grid	O	B-API
points	O	O
:	O	O
#CODE	O	O

You	O	O
probably	O	O
could	O	O
get	O	B-API
`	O	O
append	B-API	B-API
`	O	O
to	O	O
work	O	O
,	O	O
but	O	O
it	O	O
just	O	O
does	O	O
a	O	O
step	O	B-API
by	O	O
step	O	B-API
concatenate	O	B-API
,	O	O
which	O	O
is	O	O
slower	O	O
.	O	O

This	O	O
produces	O	O
a	O	O
random	O	B-API
permutation	O	B-API
of	O	O
each	O	O
column's	O	O
indices	O	B-API
.	O	O

As	O	O
it	O	O
happens	O	O
,	O	O
the	O	O
histogram	O	B-API
is	O	O
enough	O	O
for	O	O
the	O	O
former	O	O
.	O	O

I	O	O
see	O	O
how	O	O
the	O	O
symmetry	O	O
of	O	O
the	O	O
trace	O	B-API
lets	O	O
you	O	O
replace	O	B-API
the	O	O
final	O	O
`	O	O
dot	B-API	B-API
`	O	O
.	O	O

In	O	O
that	O	O
question	O	O
,	O	O
I	O	O
sought	O	O
to	O	O
sum	O	B-API
values	O	B-API
in	O	O
a	O	O
numpy	O	O
structured	O	O
array	O	B-API
based	O	O
on	O	O
multiple	O	O
criteria	O	O
,	O	O
including	O	O
matches	O	O
in	O	O
a	O	O
list	O	B-API
.	O	O

to	O	O
delete	O	B-API
the	O	O
lines	O	B-API
that	O	O
had	O	O
zeros	O	B-API
in	O	O
them	O	O
!	O	O

Fill	O	B-API
scipy	O	O
/	O	O
numpy	O	O
matrix	O	B-API
based	O	O
on	O	O
indices	O	B-API
and	O	O
values	O	B-API

It	O	O
looks	O	O
like	O	O
a	O	O
vector	O	O
product	O	B-API
followed	O	O
by	O	O
a	O	O
sum	O	B-API
along	O	O
the	O	O
resulting	O	O
array	O	B-API
.	O	O

The	O	O
trick	O	O
is	O	O
that	O	O
this	O	O
convolve	B-API	B-API
function	O	B-API
can	O	O
be	O	O
used	O	O
in-place	O	O
so	O	O
the	O	O
double	O	O
for	O	O
loop	O	O
:	O	O
#CODE	O	O

But	O	O
this	O	O
reshape	B-API	B-API
should	O	O
produce	O	O
a	O	O
`	O	O
(	O	O
n	O	O
,	O	O
1	O	O
,	O	O
1	O	O
)`	O	O
array	O	B-API
,	O	O
not	O	O
your	O	O
`	O	O
(	O	O
1	O	O
,	O	O
1	O	O
,	O	O
1	O	O
,...	O	O
)`	O	O
array	O	B-API
.	O	O

For	O	O
an	O	O
extreme	O	O
example	O	O
,	O	O
consider	O	O
a	O	O
sequence	O	O
that	O	O
consists	O	O
of	O	O
9	O	O
zeros	O	B-API
followed	O	O
by	O	O
the	O	O
result	O	O
of	O	O
a	O	O
coin	O	O
toss	O	O
,	O	O
9	O	O
zeros	O	B-API
and	O	O
another	O	O
coin	O	O
toss	O	O
,	O	O
etc	O	O
.	O	O

If	O	O
so	O	O
then	O	O
`	O	O
np.array	B-API	B-API
(	O	O
a	O	O
)`	O	O
is	O	O
a	O	O
2d	O	O
array	O	B-API
,	O	O
and	O	O
you	O	O
can	O	O
sum	O	B-API
over	O	B-API
`	O	O
axis=1	O	O
`	O	O
.	O	O

I	O	O
am	O	O
trying	O	O
to	O	O
create	O	O
a	O	O
lat	O	O
/	O	O
lon	O	O
grid	O	B-API
that	O	O
contains	O	B-API
an	O	O
array	O	B-API
of	O	O
found	O	O
indices	O	B-API
where	O	B-API
two	O	O
conditions	O	O
are	O	O
met	O	O
for	O	O
a	O	O
lat	O	O
/	O	O
lon	O	O
combination	O	O
.	O	O

This	O	O
NAMBE	O	O
is	O	O
the	O	O
absolute	O	B-API
difference	O	B-API
between	O	B-API
a	O	O
base	O	B-API
vector	O	O
and	O	O
another	O	O
vector	O	O
,	O	O
divided	O	O
by	O	O
the	O	O
base	O	B-API
vector	O	O
and	O	O
multiplied	O	O
by	O	O
a	O	O
hundred	O	O
,	O	O
in	O	O
pseudo-code	O	O
notation	O	O
:	O	O
#CODE	O	O

this	O	O
my	O	O
code	O	O
to	O	O
and	O	O
i	O	O
want	O	O
to	O	O
use	O	B-API
histogram	O	B-API
data	O	B-API
to	O	O
plot	O	B-API
scatter	O	B-API
where	O	B-API
y	O	O
axis	O	B-API
is	O	O
counts	O	O
center	O	B-API
from	O	O
the	O	O
histogram	O	B-API
,	O	O
is	O	O
there	O	O
any	O	B-API
direct	O	O
command	O	O
or	O	O
way	O	O
to	O	O
do	O	O
this	O	O
?	O	O

Please	O	O
compile	O	O
with	O	O
`	O	O
cython	O	O
-a	O	O
`	O	O
,	O	O
then	O	O
show	O	B-API
us	O	O
the	O	O
C	O	O
code	O	O
that	O	O
the	O	O
`	O	O
a	O	O
[	O	O
0	O	O
]	O	O
+=	O	O
sum	O	B-API
`	O	O
line	O	O
turns	O	O
into	O	O
.	O	O

The	O	O
revised	O	O
question	O	O
is	O	O
still	O	O
a	O	O
duplicate	O	O
,	O	O
see	O	O
[	O	O
this	O	O
question	O	O
]	O	O
(	O	O
#URL	O	O
)	O	O
,	O	O
and	O	O
[	O	O
this	O	O
question	O	O
]	O	O
(	O	O
#URL	O	O
)	O	O
for	O	O
finding	O	O
the	O	O
indices	O	B-API
.	O	O

ValueError	O	O
:	O	O
operands	O	O
could	O	O
not	O	O
be	O	O
broadcast	O	B-API
together	O	O
with	O	O
different	O	O
shapes	O	O
in	O	O
numpy	O	O
?	O	O

There	O	O
are	O	O
thousands	O	O
of	O	O
numbers	O	O
below	O	O
the	O	O
ones	O	B-API
shown	O	O
here	O	O
.	O	O

Assuming	O	O
you	O	O
want	O	O
to	O	O
align	O	B-API
all	O	B-API
the	O	O
arrays	O	O
to	O	O
the	O	O
left	O	O
,	O	O
and	O	O
pad	O	B-API
to	O	O
the	O	O
right	O	O
with	O	O
zeros	O	B-API
,	O	O
then	O	O
you	O	O
could	O	O
first	O	B-API
find	O	B-API
the	O	O
maximum	O	B-API
length	O	O
with	O	O
#CODE	O	O

How	O	O
to	O	O
do	O	O
the	O	O
same	O	O
If	O	O
I	O	O
want	O	O
to	O	O
apply	O	B-API
norm	O	B-API
column-wise	O	O
to	O	O
a	O	O
matrix	O	B-API
?	O	O

The	O	O
easiest	O	O
approach	O	O
is	O	O
to	O	O
reshape	O	B-API
to	O	O
data	O	B-API
to	O	O
a	O	O
long	O	O
format	O	B-API
using	O	O
`	O	O
.stack	B-API	B-API
`	O	O
,	O	O
which	O	O
can	O	O
be	O	O
be	O	O
passed	O	O
straight	O	O
into	O	O
rolling	O	O
mean	O	B-API
.	O	O

It's	O	O
pretty	O	O
low-level	O	O
,	O	O
and	O	O
mostly	O	O
focused	O	O
on	O	O
how	O	O
to	O	O
address	O	O
the	O	O
more	O	O
difficult	O	O
problem	O	O
of	O	O
how	O	O
to	O	O
pass	O	O
C++	O	O
data	O	B-API
to	O	O
and	O	O
from	O	O
NumPy	O	O
without	O	O
copying	O	O
,	O	O
but	O	O
here's	O	O
how	O	O
you'd	O	O
do	O	O
a	O	O
copied	O	O
std	O	B-API
::	O	O
vector	O	O
return	O	O
with	O	O
that	O	O
:	O	O
#CODE	O	O

`	O	O
std	O	B-API
=	O	O
RMS	O	O
(	O	O
data	O	B-API
-	O	O
mean	O	B-API
)`	O	O
.	O	O

This	O	O
generalized	O	O
diagonal	O	B-API
would	O	O
be	O	O
defined	O	O
as	O	O
those	O	O
elements	O	O
of	O	O
the	O	O
array	O	B-API
whose	O	O
0th	O	O
and	O	O
2nd	O	O
index	O	B-API
coincide	O	O
,	O	O
and	O	O
would	O	O
have	O	O
shape	O	B-API
(	O	O
3	O	O
,	O	O
3	O	O
,	O	O
7	O	O
)	O	O
.	O	O

I	O	O
have	O	O
a	O	O
given	O	O
array	O	B-API
`	O	O
[	O	O
0	O	O
,	O	O
0	O	O
,	O	O
0	O	O
,	O	O
0	O	O
,	O	O
0	O	O
,	O	O
0	O	O
,	O	O
1	O	O
,	O	O
1	O	O
,	O	O
2	O	O
,	O	O
1	O	O
,	O	O
0	O	O
,	O	O
0	O	O
,	O	O
0	O	O
,	O	O
0	O	O
,	O	O
1	O	O
,	O	O
0	O	O
,	O	O
1	O	O
,	O	O
2	O	O
,	O	O
1	O	O
,	O	O
0	O	O
,	O	O
2	O	O
,	O	O
3	O	O
`]	O	O
(	O	O
arbitrary	O	O
elements	O	O
from	O	O
0-5	O	O
)	O	O
and	O	O
I	O	O
want	O	O
to	O	O
have	O	O
a	O	O
counter	O	O
for	O	O
the	O	O
occurence	O	O
of	O	O
zeros	O	B-API
in	O	O
a	O	O
row	O	O
.	O	O

To	O	O
see	O	O
the	O	O
benefits	O	O
of	O	O
this	O	O
,	O	O
you	O	O
need	O	O
to	O	O
use	O	B-API
`	O	O
z	O	O
,	O	O
p	O	O
,	O	O
k	O	O
=	O	O
butter	O	O
(	O	O
output=	O	O
'	O	O
zpk	O	O
')`	O	O
and	O	O
then	O	O
work	O	O
with	O	O
poles	O	O
and	O	O
zeros	O	B-API
instead	O	O
of	O	O
numerator	O	O
and	O	O
denominator	O	O
.	O	O

In	O	O
that	O	O
case	O	O
you	O	O
would	O	O
"	O	O
extrapolate	O	O
"	O	O
zeros	O	B-API
to	O	O
the	O	O
left	O	O
and	O	O
the	O	O
right	O	O
.	O	O

can	O	O
numpy	O	O
interpret	O	O
column	O	O
of	O	O
indices	O	B-API
like	O	O
matlab	O	O
does	O	O

To	O	O
get	O	B-API
the	O	O
diagonal	O	B-API
elements	O	O
you	O	O
can	O	O
get	O	B-API
their	O	O
indices	O	B-API
with	O	O
`	O	O
np.triu_indices	B-API	B-API
`	O	O
(	O	O
or	O	O
,	O	O
for	O	O
the	O	O
lower	O	B-API
triangle	O	O
,	O	O
`	O	O
np.tril_indices	B-API	B-API
`)	O	O
and	O	O
then	O	O
index	O	B-API
by	O	O
them	O	O
.	O	O

The	O	O
question	O	O
states	O	O
that	O	O
the	O	O
input	O	O
array	O	B-API
is	O	O
of	O	O
shape	O	B-API
`	O	O
(	O	O
128	O	O
,	O	O
36	O	O
,	O	O
8)	O	O
`	O	O
and	O	O
we	O	O
are	O	O
interested	O	O
in	O	O
finding	O	O
unique	O	B-API
subarrays	O	O
of	O	O
length	O	O
`	O	O
8	O	O
`	O	O
in	O	O
the	O	O
last	O	B-API
dimension	O	O
.	O	O

What	O	O
does	O	O
work	O	O
,	O	O
however	O	O
is	O	O
nesting	O	O
append	B-API	B-API
and	O	O
concatenate	B-API	B-API
#CODE	O	O

(	O	O
`	O	O
b	O	O
`	O	O
will	O	O
be	O	O
broadcast	O	B-API
along	O	O
(	O	O
?	O	O
)	O	O
the	O	O
first	O	B-API
axis	O	B-API
)	O	O
#CODE	O	O

As	O	O
he	O	O
points	O	O
out	O	O
,	O	O
the	O	O
`	O	O
[	O	O
0	O	O
]	O	O
[	O	O
1	O	O
]`	O	O
element	O	O
is	O	O
what	O	O
you'd	O	O
want	O	O
for	O	O
`	O	O
cov	B-API	B-API
(	O	O
a	O	O
,	O	O
b	O	O
)`	O	O
.	O	O

returns	O	O
`	O	O
1	O	O
`	O	O
,	O	O
making	O	O
the	O	O
sum	O	B-API
not	O	O
commutative	O	O
!	O	O

But	O	O
as	O	O
I	O	O
have	O	O
a	O	O
log	O	B-API
of	O	O
values	O	B-API
(	O	O
10000+	O	O
)	O	O
,	O	O
this	O	O
will	O	O
be	O	O
quite	O	O
slow	O	B-API
.	O	O

@USER	O	O
-	O	O
good	O	O
point	O	O
.	O	O
anyway	O	O
,	O	O
`	O	O
diff	B-API	B-API
`	O	O
works	O	O
on	O	O
python	O	O
lists	O	O
too	O	O
.	O	O

It	O	O
will	O	O
also	O	O
work	O	O
if	O	O
they	O	O
are	O	O
both	O	O
arrays	O	O
that	O	O
can	O	O
be	O	O
broadcast	O	B-API
.	O	O

It's	O	O
column	O	O
stack	O	B-API
that	O	O
requires	O	O
equal	O	B-API
length	O	O
strings	O	O
.	O	O

In	O	O
the	O	O
end	O	O
it	O	O
is	O	O
usually	O	O
not	O	O
too	O	O
complicated	O	O
,	O	O
especially	O	O
if	O	O
you	O	O
use	O	B-API
[	O	O
`	O	O
mgrid	B-API	O
`]	O	O
(	O	O
#URL	O	O
)	O	O
or	O	O
similar	O	O
to	O	O
get	O	B-API
the	O	O
indices	O	B-API
.	O	O

The	O	O
absolute	O	B-API
error	O	O
will	O	O
be	O	O
at	O	B-API
most	O	O
1	O	O
/	O	O
2	O	O
ULP	O	O
,	O	O
2	O	O
-150	O	O
.	O	O

AttributeError	O	O
:	O	O
'	O	O
Add	O	O
'	O	O
object	O	O
has	O	O
no	O	O
attribute	O	O
'	O	O
log	O	B-API
'	O	O
Python	O	O

Or	O	O
,	O	O
you	O	O
could	O	O
initialize	O	O
an	O	O
array	O	B-API
of	O	O
all	O	B-API
zeros	O	B-API
if	O	O
you	O	O
know	O	O
the	O	O
size	O	B-API
of	O	O
the	O	O
array	O	B-API
ahead	O	O
of	O	O
time	O	B-API
.	O	O

Are	O	O
you	O	O
checking	O	O
shape	O	B-API
or	O	O
number	O	O
of	O	O
nonzero	O	B-API
values	O	B-API
?	O	O

Something	O	O
like	O	O
`	O	O
eigvals	O	O
,	O	O
eigvecs	O	O
=	O	O
la.eigh	O	B-API
(	O	O
mat	B-API	B-API
)`	O	O
`	O	O
principal	O	O
=	O	O
eigvecs	O	O
[:	O	O
,	O	O
eigvals.argmax()	O	B-API
]`	O	O
`	O	O
if	O	O
(	O	O
principal	O	O
>	O	O
=	O	O
0	O	O
)	O	O
.all()	O	B-API
or	O	O
(	O	O
pricipal	O	O
<=	O	O
0	O	O
)	O	O
.all()	O	B-API
:	O	O
print	O	O
'	O	O
all	O	B-API
the	O	O
same	O	O
'`	O	O
?	O	O

I	O	O
also	O	O
want	O	O
bins	O	O
to	O	O
have	O	O
a	O	O
width	O	O
of	O	O
.5	O	O
so	O	O
that	O	O
I	O	O
can	O	O
have	O	O
a	O	O
bin	O	O
from	O	O
10.5	O	O
to	O	O
11	O	O
or	O	O
24	O	O
to	O	O
24.5	O	O
etc	O	O
...	O	O
because	O	O
otherwise	O	O
,	O	O
python	O	O
outputs	O	O
the	O	O
histogram	O	B-API
with	O	O
the	O	O
bins	O	O
random	O	B-API
and	O	O
undetermined	O	O
.	O	O

Maximum	O	O
is	O	O
always	O	O
bigger	O	O
than	O	O
the	O	O
minimum	O	B-API
(	O	O
more	O	O
to	O	O
the	O	O
right	O	O
on	O	O
a	O	O
1d	O	O
axis	O	B-API
,	O	O
not	O	O
by	O	O
absolute	O	B-API
value	O	O
)	O	O
.	O	O

should	O	O
give	O	O
the	O	O
sum	O	B-API
of	O	O
the	O	O
columns	O	O
.	O	O

Suppose	O	O
,	O	O
You	O	O
wanna	O	O
check	O	O
how	O	O
many	O	O
times	O	O
you	O	O
will	O	O
get	O	B-API
six	O	O
if	O	O
you	O	O
roll	O	B-API
dice	O	O
10	O	O
times	O	O
.	O	O

With	O	O
this	O	O
option	O	O
,	O	O
the	O	O
result	O	O
will	O	O
broadcast	O	B-API
correctly	O	O

Do	O	O
you	O	O
mean	O	B-API
`	O	O
indices	O	B-API
=	O	O
np.where	B-API	B-API
(	O	O
a	O	O
==	O	O
a.max()	O	B-API
)`	O	O
in	O	O
line	O	O
3	O	O
?	O	O

The	O	O
problem	O	O
I	O	O
have	O	O
much	O	O
later	O	O
on	O	O
in	O	O
the	O	O
code	O	O
is	O	O
that	O	O
if	O	O
one	O	O
of	O	O
these	O	O
parameters	O	O
isn't	O	O
in	O	O
the	O	O
ASCII	O	O
file	O	O
it	O	O
throws	O	O
errors	O	O
up	O	O
so	O	O
I	O	O
have	O	O
to	O	O
keep	O	O
adding	O	O
in	O	O
ones	O	B-API
I	O	O
don't	O	O
need	O	O
.	O	O

`	O	O
append	B-API	B-API
`	O	O
adds	O	O
them	O	O
to	O	O
the	O	O
end	O	O
of	O	O
the	O	O
list	O	B-API
,	O	O
which	O	O
is	O	O
exactly	O	O
what	O	O
you	O	O
want	O	O
.	O	O

I	O	O
have	O	O
two	O	O
3dim	O	O
numpy	O	O
matrices	O	O
and	O	O
I	O	O
want	O	O
to	O	O
do	O	O
a	O	O
dot	O	B-API
product	O	B-API
according	O	O
to	O	O
one	O	O
axis	O	B-API
without	O	O
using	O	O
a	O	O
loop	O	O
in	O	O
theano	O	O
.	O	O

you	O	O
have	O	O
at	O	B-API
most	O	O
4	O	O
in	O	O
that	O	O
dimension	O	O
(	O	O
see	O	O
your	O	O
reshape	O	B-API
line	O	O
)	O	O
,	O	O
so	O	O
the	O	O
index	O	B-API
it	O	O
will	O	O
count	O	B-API
are	O	O
0	O	O
and	O	O
2	O	O
(	O	O
1	O	O
and	O	O
3	O	O
are	O	O
skipped	O	O
,	O	O
and	O	O
3	O	O
is	O	O
the	O	O
last	O	B-API
element	O	O
)	O	O
.	O	O

Once	O	O
we	O	O
have	O	O
the	O	O
indices	O	B-API
to	O	O
sort	O	B-API
`	O	O
data	O	B-API
`	O	O
,	O	O
to	O	O
get	O	B-API
a	O	O
sorted	O	O
copy	O	B-API
of	O	O
the	O	O
array	O	B-API
it	O	O
is	O	O
faster	O	O
to	O	O
use	O	B-API
the	O	O
indices	O	B-API
than	O	O
to	O	O
re-sort	O	O
the	O	O
array	O	B-API
:	O	O
#CODE	O	O

I	O	O
hope	O	O
this	O	O
will	O	O
help	O	O
you	O	O
perform	O	O
your	O	O
transpose	O	B-API
and	O	O
column-wise	O	O
operations	O	O

It	O	O
is	O	O
better	O	O
to	O	O
specify	O	O
that	O	O
I'm	O	O
looking	O	O
for	O	O
something	O	O
that	O	O
performs	O	O
the	O	O
log-sum-exp	O	O
trick	O	O
,	O	O
doing	O	O
a	O	O
simply	O	O
succession	O	O
of	O	O
exp	O	B-API
elem-wise	O	O
,	O	O
summing	O	O
the	O	O
rows	O	O
and	O	O
doing	O	O
a	O	O
log	O	B-API
elem-wise	O	O
is	O	O
trivial	O	O
in	O	O
`	O	O
scipy.sparse	O	B-API
`	O	O
.	O	O

Scipy	O	O
uses	O	O
`	O	O
int32	O	O
`	O	O
to	O	O
store	O	O
`	O	O
indptr	O	O
`	O	O
and	O	O
`	O	O
indices	O	B-API
`	O	O
for	O	O
the	O	O
sparse	O	O
formats	O	O
.	O	O

But	O	O
not	O	O
able	O	O
to	O	O
plot	O	B-API
it	O	O
as	O	O
a	O	O
graph	O	O
(	O	O
something	O	O
like	O	O
a	O	O
histogram	O	B-API
)	O	O
...	O	O
that	O	O
is	O	O
the	O	O
problem	O	O
.	O	O

It	O	O
gave	O	O
error	O	O
testing	O	O
doesnot	O	O
have	O	O
attribute	O	O
append	O	B-API
as	O	O
its	O	O
of	O	O
None	O	O
Type	O	O
.	O	O

In	O	O
both	O	O
cases	O	O
,	O	O
you	O	O
can	O	O
access	O	O
individual	O	O
elements	O	O
by	O	O
indices	O	B-API
,	O	O
like	O	O
`	O	O
R	O	O
[	O	O
0	O	O
]`	O	O
(	O	O
which	O	O
would	O	O
give	O	O
you	O	O
a	O	O
specific	O	O
object	O	O
,	O	O
a	O	O
`	O	O
np.void	O	B-API
`	O	O
,	O	O
that	O	O
still	O	O
gives	O	O
you	O	O
the	O	O
possibility	O	O
to	O	O
access	O	O
the	O	O
fields	O	O
separately	O	O
)	O	O
,	O	O
or	O	O
by	O	O
slices	O	O
`	O	O
R	O	O
[	O	O
1	O	O
:	O	O
-1	O	O
]`	O	O
...	O	O

I	O	O
think	O	O
you	O	O
can	O	O
have	O	O
a	O	O
sum	O	B-API
over	O	B-API
a	O	O
sliding	O	O
window	O	O
(	O	O
or	O	O
a	O	O
rolling	O	O
window	O	O
)	O	O
or	O	O
a	O	O
mean	O	B-API
over	O	B-API
a	O	O
sliding	O	O
window	O	O
.	O	O

I	O	O
got	O	O
your	O	O
point	O	O
and	O	O
I	O	O
find	O	B-API
it	O	O
more	O	O
logical	O	O
,	O	O
but	O	O
when	O	O
trying	O	O
the	O	O
code	O	O
you've	O	O
suggested	O	O
to	O	O
get	O	B-API
rid	O	O
of	O	O
the	O	O
second	O	B-API
error	O	O
I	O	O
got	O	O
another	O	O
error	O	O
:	O	O
`	O	O
AttributeError	O	O
:	O	O
flatten	B-API	B-API
`	O	O

`	O	O
dot	B-API	B-API
`	O	O
does	O	O
many	O	O
things	O	O
under	O	O
the	O	O
hood	O	O
,	O	O
it	O	O
is	O	O
apparent	O	O
that	O	O
`	O	O
np.dot	B-API	B-API
(	O	O
A	O	O
,	O	O
x	O	O
)`	O	O
is	O	O
not	O	O
calling	O	O
BLAS	O	O
and	O	O
is	O	O
somehow	O	O
defaulting	O	O
over	O	B-API
to	O	O
numpy's	O	O
internal	O	O
GEMM	O	O
routine	O	O
.	O	O

Below	O	O
is	O	O
some	O	O
code	O	O
which	O	O
uses	O	O
a	O	O
callback	O	O
to	O	O
print	O	O
out	O	O
the	O	O
current	O	O
azimuthal	O	O
and	O	O
elevation	O	O
angles	O	O
,	O	O
as	O	O
well	O	O
as	O	O
append	O	B-API
them	O	O
to	O	O
a	O	O
list	O	B-API
for	O	O
further	O	O
use	O	B-API
later	O	O
.	O	O

It's	O	O
super	O	O
alex	O	O
,	O	O
here	O	O
to	O	O
answer	O	O
NumPy	O	O
questions	O	O
in	O	O
the	O	O
blink	O	O
of	O	O
an	O	O
eye	O	B-API
:)	O	O

Your	O	O
solution	O	O
of	O	O
searching	O	O
the	O	O
eigenvalues	O	O
for	O	O
the	O	O
ones	O	B-API
you	O	O
want	O	O
seems	O	O
plausible	O	O
enough	O	O
.	O	O

If	O	O
d	O	O
is	O	O
larger	O	O
than	O	O
8	O	O
or	O	O
9	O	O
,	O	O
then	O	O
bases	O	O
will	O	O
be	O	O
sufficiently	O	O
long	O	O
that	O	O
you	O	O
probably	O	O
would	O	O
be	O	O
better	O	O
off	O	O
going	O	O
with	O	O
the	O	O
other	O	O
version	O	O
using	O	O
the	O	O
dot	O	B-API
product	O	B-API
.	O	O

I'm	O	O
not	O	O
sure	O	O
which	O	O
indices	O	B-API
i	O	O
need	O	O
to	O	O
change	O	O
to	O	O
achieve	O	O
the	O	O
minimum	O	B-API
and	O	O
not	O	O
the	O	O
maximum	O	B-API
values	O	B-API
.	O	O

The	O	O
dimension	O	O
of	O	O
`	O	O
result	O	O
`	O	O
has	O	O
been	O	O
set	O	B-API
earlier	O	O
to	O	O
the	O	O
correct	O	O
dimension	O	O
,	O	O
so	O	O
can	O	O
check	O	O
it	O	O
,	O	O
but	O	O
it	O	O
would	O	O
be	O	O
nice	O	O
to	O	O
only	O	O
use	O	B-API
the	O	O
length	O	O
of	O	O
`	O	O
indices	O	B-API
`	O	O
to	O	O
determine	O	O
it	O	O
.	O	O

Alternatively	O	O
,	O	O
what	O	O
about	O	O
applying	O	O
the	O	O
same	O	O
function	O	B-API
without	O	O
indices	O	B-API
along	O	O
the	O	O
depth	O	O
axes	O	B-API
?	O	O

Here's	O	O
an	O	O
O	O	O
(	O	O
n	O	O
log	O	B-API
n	O	O
)	O	O
algorithm	O	O
for	O	O
your	O	O
problem	O	O
.	O	O

You	O	O
need	O	O
to	O	O
add	O	B-API
axes	O	B-API
to	O	O
`	O	O
coeffs	O	O
`	O	O
so	O	O
it	O	O
will	O	O
broadcast	O	B-API
in	O	O
the	O	O
dimension	O	O
(	O	O
s	O	O
)	O	O
you	O	O
want	O	O
.	O	O

If	O	O
you	O	O
want	O	O
to	O	O
search	O	O
for	O	O
a	O	O
certain	O	O
rank	O	B-API
on	O	O
B	O	O
randomly	O	O
,	O	O
you	O	O
need	O	O
to	O	O
start	O	O
off	O	O
with	O	O
a	O	O
valid	O	B-API
B	O	O
with	O	O
max	O	B-API
rank	O	B-API
,	O	O
and	O	O
rotate	O	O
a	O	O
random	O	B-API
column	O	O
j	O	O
of	O	O
a	O	O
random	O	B-API
B	O	O
i	O	O
by	O	O
a	O	O
random	O	B-API
amount	O	O
.	O	O

I	O	O
want	O	O
to	O	O
save	O	B-API
some	O	O
histogram	O	B-API
data	O	B-API
in	O	O
a	O	O
csv	O	O
file	O	O
.	O	O

I	O	O
want	O	O
to	O	O
read	O	O
a	O	O
mat	O	B-API
file	O	O
back	O	B-API
in	O	O
python	O	O
but	O	O
I	O	O
have	O	O
trouble	O	O
going	O	O
back	O	B-API
to	O	O
a	O	O
graph	O	O
,	O	O
because	O	O
the	O	O
mat	O	B-API
file	O	O
gives	O	O
a	O	O
numpy.ndarray	B-API	B-API
type	O	O
file	O	O
and	O	O
I	O	O
need	O	O
a	O	O
sparse	O	O
matrix	O	B-API
to	O	O
reconstruct	O	O
my	O	O
graph	O	O
.	O	O

numpy	O	O
makes	O	O
it	O	O
easy	O	O
to	O	O
translate	O	B-API
python	O	O
objects	O	O
into	O	O
numpy	O	O
ndarrays	O	O
,	O	O
and	O	O
will	O	O
even	O	O
pick	O	B-API
an	O	O
appropriate	O	O
resulting	O	O
data	O	B-API
type	O	O
if	O	O
one	O	O
is	O	O
not	O	O
specified	O	O
:	O	O
#CODE	O	O

This	O	O
`	O	O
T	O	B-API
`	O	O
and	O	O
`	O	O
X	O	O
`	O	O
broadcast	O	B-API
together	O	O
just	O	O
fine	O	O
,	O	O
for	O	O
example	O	O
`	O	O
T*X	O	O
`	O	O
works	O	O
.	O	O

I	O	O
have	O	O
a	O	O
numpy	O	O
matrix	O	B-API
A	O	O
and	O	O
I	O	O
need	O	O
a	O	O
function	O	B-API
that	O	O
will	O	O
count	O	B-API
(	O	O
A	O	O
[	O	O
i	O	O
,	O	O
j	O	O
]	O	O
/	O	O
sum	O	B-API
of	O	O
all	O	B-API
elements	O	O
in	O	O
i-th	O	O
column	O	O
)	O	O
-	O	O
A	O	O
[	O	O
i	O	O
,	O	O
j	O	O
]	O	O
/	O	O
sum	O	B-API
of	O	O
all	O	B-API
elements	O	O
in	O	O
j-th	O	O
row	O	O

This	O	O
also	O	O
works	O	O
if	O	O
,	O	O
instead	O	O
of	O	O
a	O	O
single	O	O
index	O	B-API
,	O	O
you	O	O
provide	O	O
an	O	O
array	O	B-API
of	O	O
indices	O	B-API
:	O	O
#CODE	O	O

How	O	O
to	O	O
solve	O	B-API
nonlinear	O	O
equation	O	O
without	O	O
sympy	O	O
(	O	O
max	O	B-API
and	O	O
min	O	B-API
)	O	O
?	O	O

Bivariate	O	O
Legendre	O	O
Polynomial	O	B-API
Fitting	O	O
to	O	O
find	O	B-API
orthogonal	O	O
coefficents	O	O

I	O	O
have	O	O
a	O	O
big	O	O
n-square	O	O
diagonal	O	B-API
matrix	O	B-API
,	O	O
in	O	O
the	O	O
scipy's	O	O
sparse	O	O
DIA	O	O
format	O	B-API

To	O	O
find	O	B-API
the	O	O
most	O	O
frequent	O	O
value	O	O
of	O	O
a	O	O
flat	O	O
array	O	B-API
,	O	O
use	O	B-API
`	O	O
unique	B-API	B-API
`	O	O
,	O	O
`	O	O
bincount	B-API	O
`	O	O
and	O	O
`	O	O
argmax	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

The	O	O
funny	O	O
thing	O	O
is	O	O
in	O	O
the	O	O
above	O	O
function	O	B-API
If	O	O
i	O	O
pass	O	O
an	O	O
extra	O	O
argument	O	O
and	O	O
just	O	O
divide	O	B-API
sum	O	B-API
by	O	O
it	O	O
,	O	O
then	O	O
the	O	O
times	O	O
are	O	O
the	O	O
same	O	O
again	O	O
.	O	O

are	O	O
the	O	O
same	O	O
as	O	O
the	O	O
ones	O	B-API
posted	O	O
in	O	O
the	O	O
examples	O	O
of	O	O
this	O	O
web	O	O
page	O	O
.	O	O

How	O	O
to	O	O
remove	O	B-API
rings	O	O
from	O	O
convolve	O	B-API
healpix	O	O
map	O	B-API
?	O	O

With	O	O
the	O	O
information	O	O
of	O	O
the	O	O
full	O	B-API
stack	O	B-API
trace	O	B-API
report	O	B-API
the	O	O
bug	O	O
to	O	O
the	O	O
ubuntu	O	O
team	O	O
.	O	O

fastest	O	O
way	O	O
to	O	O
get	O	B-API
lookup	O	B-API
table	O	B-API
indices	O	B-API
with	O	O
numpy	O	O

Well	O	O
,	O	O
a	O	O
few	O	O
more	O	O
,	O	O
anyway	O	O
:	O	O
`	O	O
cos	B-API	B-API
`	O	O
,	O	O
`	O	O
pi	B-API	O
`	O	O
,	O	O
`	O	O
diag	B-API	O
`	O	O

I	O	O
implemented	O	O
a	O	O
LOWESS	O	O
smoother	O	O
(	O	O
which	O	O
is	O	O
the	O	O
curve	O	O
you	O	O
see	O	O
)	O	O
with	O	O
a	O	O
tight	O	O
fit	O	O
to	O	O
eliminate	O	O
noise	O	O
,	O	O
since	O	O
the	O	O
real	O	B-API
waveforms	O	O
have	O	O
a	O	O
non-trivial	O	O
noise	O	O
component	O	O
,	O	O
and	O	O
then	O	O
tried	O	O
doing	O	O
a	O	O
rolling	O	O
max	O	B-API
with	O	O
a	O	O
window	O	O
over	O	B-API
the	O	O
data	O	B-API
,	O	O
but	O	O
I	O	O
can't	O	O
get	O	B-API
anything	O	O
solid	O	O
.	O	O

But	O	O
sum	B-API	B-API
function	O	B-API
from	O	O
numpy	O	O
doesn't	O	O
suport	O	O
"	O	O
1:3	O	O
"	O	O

(	O	O
the	O	O
`	O	O
np.nonzero	B-API	B-API
`	O	O
should	O	O
return	O	O
a	O	O
tuple	O	O
with	O	O
one	O	O
element	O	O
,	O	O
an	O	O
array	O	B-API
of	O	O
indices	O	B-API
)	O	O
.	O	O

Can	O	O
the	O	O
"	O	O
small	O	O
values	O	B-API
of	O	O
derivative	O	O
"	O	O
be	O	O
small	O	O
with	O	O
respect	O	O
to	O	O
the	O	O
sin	O	B-API
curve	O	O
?	O	O

6	O	O
columns	O	O
,	O	O
92370574	O	O
rows	O	O
,	O	O
2496502	O	O
locations	O	O
,	O	O
37	O	O
months	O	O
each	O	O
,	O	O
unique	O	B-API
amounts	O	O
for	O	O
each	O	O
value	O	O
.	O	O

Note	O	O
that	O	O
where	O	B-API
possible	O	O
,	O	O
`	O	O
reshape	B-API	B-API
`	O	O
will	O	O
give	O	O
you	O	O
a	O	O
view	O	B-API
of	O	O
the	O	O
array	O	B-API
.	O	O

Here	O	O
you	O	O
append	O	B-API
only	O	O
a	O	O
REFERENCE	O	O
to	O	O
your	O	O
only	O	O
one	O	O
existing	O	O
`	O	O
energy	O	O
`	O	O
array	O	B-API
.	O	O

And	O	O
you	O	O
can	O	O
combine	O	B-API
the	O	O
summation	O	O
and	O	O
multiplication	O	O
into	O	O
a	O	O
dot	O	B-API
product	O	B-API
:	O	O
#CODE	O	O

For	O	O
example	O	O
,	O	O
`	O	O
a	O	O
`	O	O
is	O	O
generated	O	O
from	O	O
`	O	O
a	O	O
=	O	O
z	O	O
[	O	O
z	O	O
!	O	O
=0	O	O
]`	O	O
;	O	O
`	O	O
a	O	O
`	O	O
then	O	O
changes	O	O
through	O	O
some	O	O
processing	O	O
,	O	O
and	O	O
now	O	O
I	O	O
need	O	O
to	O	O
insert	O	B-API
`	O	O
nan	O	O
`	O	O
s	O	O
where	O	B-API
there	O	O
were	O	O
originally	O	O
zeros	O	B-API
.	O	O

I	O	O
frequently	O	O
use	O	B-API
the	O	O
numpy.where	B-API	B-API
function	O	B-API
to	O	O
gather	O	O
a	O	O
tuple	O	O
of	O	O
indices	O	B-API
of	O	O
a	O	O
matrix	O	B-API
having	O	O
some	O	O
property	O	O
.	O	O

I	O	O
suspect	O	O
the	O	O
original	O	O
formula	O	O
was	O	O
right	O	O
but	O	O
you	O	O
didn't	O	O
encode	O	B-API
it	O	O
right	O	O
in	O	O
Python	O	O
.	O	O

This	O	O
gets	O	O
me	O	O
the	O	O
sum	O	B-API
of	O	O
all	O	B-API
red	O	O
combined	O	O
in	O	O
original	O	O
-	O	O
all	O	B-API
red	O	O
combined	O	O
in	O	O
mutated	O	O
.	O	O

`	O	O
p2	O	O
=	O	O
einsum	B-API	O
(	O	O
'	O	O
nk	O	O
,	O	O
nk	O	O
->	O	O
n	O	O
'	O	O
,	O	O
p1	O	O
,	O	O
delta	O	O
)`	O	O
is	O	O
the	O	O
pairwise	O	O
dot	O	B-API
product	O	B-API
of	O	O
the	O	O
rows	O	O
of	O	O
`	O	O
p1	O	O
`	O	O
and	O	O
`	O	O
delta	O	O
`	O	O
.	O	O

I	O	O
did	O	O
the	O	O
reshape	B-API	B-API
,	O	O
just	O	O
so	O	O
that	O	O
both	O	O
arrays	O	O
are	O	O
same	O	O
shape	O	B-API
,	O	O
but	O	O
I	O	O
do	O	O
not	O	O
think	O	O
you	O	O
really	O	O
need	O	O
the	O	O
reshaping	O	O
,	O	O
with	O	O
the	O	O
list	O	B-API
comprehension	O	O
the	O	O
shape	O	B-API
of	O	O
array	O	B-API
you	O	O
get	O	B-API
is	O	O
`	O	O
(	O	O
length	O	O
of	O	O
string	O	O
,	O	O
)`	O	O

Also	O	O
,	O	O
I	O	O
expect	O	O
the	O	O
positions	O	O
of	O	O
the	O	O
zeros	O	B-API
to	O	O
be	O	O
relatively	O	O
sparse	O	O
(	O	O
~1%	O	O
of	O	O
all	O	B-API
bit	O	O
positions	O	O
)	O	O
.	O	O

Slicing	O	O
arrays	O	O
with	O	O
meshgrid	B-API	O
/	O	O
array	O	B-API
indices	O	B-API
in	O	O
Numpy	O	O

(	O	O
An	O	O
nonzero	O	B-API
exit	O	O
status	O	O
usually	O	O
indicates	O	O
an	O	O
error	O	O
on	O	O
Unix	O	O
style	O	B-API
systems	O	O
.	O	O
A	O	O
couple	O	O
programs	O	O
are	O	O
different	O	O
,	O	O
e.g.	O	B-API
,	O	O
`	O	O
diff	B-API	B-API
`	O	O
.	O	O
)	O	O
Try	O	O
examining	O	O
the	O	O
`	O	O
stderr	O	O
`	O	O
produced	O	O
by	O	O
the	O	O
subprocess	O	O
to	O	O
see	O	O
what	O	O
error	O	O
messages	O	O
are	O	O
printed	O	O
there	O	O
.	O	O

To	O	O
achieve	O	O
exactly	O	O
what	O	O
you	O	O
are	O	O
asking	O	O
for	O	O
I	O	O
would	O	O
apply	O	B-API
a	O	O
`	O	O
[	O	O
3x3	O	O
]`	O	O
box-filter	O	O
on	O	O
the	O	O
image	O	B-API
and	O	O
than	O	O
I	O	O
would	O	O
resize	O	B-API
the	O	O
matrix	O	B-API
using	O	O
nearest	O	O
neighbor	O	O
interpolation	O	O
.	O	O

Is	O	O
there	O	O
a	O	O
quick	O	O
way	O	O
to	O	O
reshape	O	B-API
my	O	O
`	O	O
csr_matrix	O	O
`	O	O
without	O	O
copying	O	O
everything	O	O
in	O	O
it	O	O
?	O	O

The	O	O
catch	O	O
is	O	O
that	O	O
I	O	O
need	O	O
to	O	O
keep	O	O
the	O	O
colors	O	B-API
exactly	O	O
the	O	O
way	O	O
they	O	O
are	O	O
(	O	O
background	O	O
:	O	O
I'm	O	O
resizing	O	O
a	O	O
map	O	B-API
where	O	B-API
provinces	O	O
are	O	O
color-coded	O	O
)	O	O
,	O	O
and	O	O
so	O	O
I	O	O
cannot	O	O
just	O	O
perform	O	O
a	O	O
resize	O	B-API
with	O	O
bicubic	O	O
interpolation	O	O
,	O	O
because	O	O
that	O	O
will	O	O
also	O	O
interpolate	O	B-API
the	O	O
pixel	O	O
colors	O	B-API
while	O	O
smoothing	O	O
.	O	O

You	O	O
should	O	O
"	O	O
flatten	O	B-API
"	O	O
the	O	O
array	O	B-API
of	O	O
arrays	O	O
first	O	B-API
.	O	O
unfortunately	O	O
,	O	O
there's	O	O
no	O	O
builtin	O	O
method	O	O
,	O	O
see	O	O
#URL	O	O

then	O	O
concatenate	O	B-API
the	O	O
saved	O	O
objects	O	O
whit	O	O
this	O	O
code	O	O
:	O	O
#CODE	O	O

For	O	O
something	O	O
like	O	O
a	O	O
dot	O	B-API
product	O	B-API
,	O	O
pandas	O	O
`	O	O
DataFrames	O	O
`	O	O
are	O	O
generally	O	O
going	O	O
to	O	O
be	O	O
slower	O	O
than	O	O
a	O	O
numpy	O	O
array	O	B-API
since	O	O
pandas	O	O
is	O	O
doing	O	O
**	O	O
a	O	O
lot	O	O
more	O	O
stuff	O	O
**	O	O
aligning	O	O
labels	O	O
,	O	O
potentially	O	O
dealing	O	O
with	O	O
heterogenous	O	O
types	O	O
,	O	O
and	O	O
so	O	O
on	O	O
.	O	O

I	O	O
want	O	O
to	O	O
pass	O	O
an	O	O
array	O	B-API
of	O	O
indices	O	B-API
and	O	O
column	O	O
names	O	B-API
and	O	O
get	O	B-API
a	O	O
list	O	B-API
of	O	O
objects	O	O
that	O	O
are	O	O
found	O	O
in	O	O
the	O	O
corresponding	O	O
index	O	B-API
and	O	O
column	O	O
name	O	B-API
.	O	O

From	O	O
this	O	O
you	O	O
would	O	O
expect	O	O
the	O	O
total	O	O
sum	O	B-API
to	O	O
be	O	O
`	O	O
100,679,697	O	O
=	O	O
200*	O	O
(	O	O
1,000,000	O	O
-	O	O
499,097	O	O
)	O	O
+	O	O
499,097	O	O
`	O	O

The	O	O
histogram	O	B-API
way	O	O
is	O	O
not	O	O
the	O	O
fastest	O	O
,	O	O
and	O	O
can't	O	O
tell	O	O
the	O	O
difference	O	B-API
between	O	B-API
an	O	O
arbitrarily	O	O
small	O	O
separation	O	O
of	O	O
points	O	O
and	O	O
`	O	O
2	O	O
*	O	O
sqrt	B-API	B-API
(	O	O
2	O	O
)	O	O
*	O	O
b	O	O
`	O	O
(	O	O
where	O	B-API
`	O	O
b	O	O
`	O	O
is	O	O
bin	O	O
width	O	O
)	O	O
.	O	O

}	O	O
for	O	O
n=1	O	O
,	O	O
2	O	O
,	O	O
3	O	O
,	O	O
4	O	O
,	O	O
5	O	O
,	O	O
6	O	O
(	O	O
using	O	O
Sum	B-API	O
(	O	O
c_n	O	O
exp	B-API	B-API
(	O	O
i	O	O
2	O	O
pi	O	O
n	O	O
x	O	O
)	O	O
)	O	O
as	O	O
Fourier	O	O
series	O	O
)	O	O
.	O	O

I	O	O
think	O	O
I	O	O
can	O	O
t	O	O
just	O	O
simple	O	O
sum	O	B-API
the	O	O
"	O	O
seq	O	O
*	O	O
"	O	O
array	O	B-API
,	O	O
because	O	O
instead	O	O
of	O	O
a	O	O
chord	O	O
I	O	O
will	O	O
get	O	B-API
noise	O	O
.	O	O

I	O	O
presume	O	O
you	O	O
want	O	O
to	O	O
transpose	O	B-API
first	O	B-API
:	O	O
#CODE	O	O

Oh	O	O
,	O	O
that's	O	O
interesting	O	O
you	O	O
can	O	O
do	O	O
it	O	O
with	O	O
stack	B-API	B-API
.	O	O

In	O	O
this	O	O
case	O	O
,	O	O
using	O	O
numpy	O	O
outer	B-API	B-API
operations	O	O
allow	O	O
you	O	O
to	O	O
compute	O	O
the	O	O
multiplications	O	O
and	O	O
sums	O	O
at	O	B-API
the	O	O
`	O	O
C	O	O
`	O	O
loop	O	O
speed	O	O
.	O	O

The	O	O
most	O	O
efficient	O	O
way	O	O
is	O	O
likely	O	O
to	O	O
use	O	B-API
'	O	O
np.empty()	B-API	B-API
'	O	O
to	O	O
allocate	O	O
the	O	O
space	O	B-API
/	O	O
memory	O	O
for	O	O
your	O	O
end	O	O
dataset	O	O
and	O	O
then	O	O
load	O	B-API
data	O	B-API
&	O	O
broadcast	O	B-API
within	O	O
that	O	O
using	O	O
slice	O	B-API
indexing	O	O
.	O	O

Ok	O	O
,	O	O
with	O	O
your	O	O
histogram	O	B-API
I	O	O
get	O	B-API
at	O	B-API
least	O	O
the	O	O
total	O	O
number	O	O
of	O	O
each	O	O
pair	O	O
.	O	O

This	O	O
is	O	O
because	O	O
python's	O	O
sum	O	B-API
is	O	O
basically	O	O
summing	O	O
a	O	O
for	O	O
loop	O	O
over	O	B-API
the	O	O
object	O	O
.	O	O

Then	O	O
the	O	O
entire	O	O
shape	O	B-API
changes	O	O
from	O	O
(	O	O
x	O	O
,	O	O
y	O	O
)	O	O
to	O	O
merely	O	O
(	O	O
x	O	O
,	O	O
)	O	O
and	O	O
I	O	O
get	O	B-API
'	O	O
too	O	O
many	O	O
indices	O	B-API
'	O	O
errors	O	O
when	O	O
I	O	O
try	O	O
to	O	O
use	O	B-API
masks	O	O
.	O	O

If	O	O
reps	O	O
has	O	O
length	O	O
d	O	O
,	O	O
the	O	O
result	O	O
will	O	O
have	O	O
dimension	O	O
of	O	O
max	B-API	B-API
(	O	O
d	O	O
,	O	O
A.ndim	O	B-API
)	O	O
.	O	O

I	O	O
want	O	O
to	O	O
do	O	O
this	O	O
by	O	O
dividing	O	O
each	O	O
histogram	O	B-API
by	O	O
its	O	O
maximum	O	B-API
value	O	O
so	O	O
all	O	B-API
the	O	O
distributions	O	O
have	O	O
the	O	O
same	O	O
scale	O	O
.	O	O

An	O	O
obvious	O	O
path	O	B-API
would	O	O
be	O	O
to	O	O
transpose	O	B-API
the	O	O
array	O	B-API
so	O	O
that	O	O
the	O	O
indices	O	B-API
that	O	O
I	O	O
am	O	O
selecting	O	O
would	O	O
come	O	O
up	O	O
first	O	B-API
.	O	O

Now	O	O
,	O	O
for	O	O
mean	O	B-API
calculations	O	O
,	O	O
those	O	O
numeric	O	O
IDs	O	O
could	O	O
be	O	O
used	O	O
as	O	O
`"	O	O
weights	O	O
"`	O	O
for	O	O
binning	O	O
with	O	O
`	O	O
np.bincount	B-API	B-API
`	O	O
,	O	O
giving	O	O
us	O	O
the	O	O
sum	O	B-API
of	O	O
data	O	B-API
elements	O	O
corresponding	O	O
to	O	O
each	O	O
`	O	O
ID	O	O
`	O	O
.	O	O

However	O	O
,	O	O
what	O	O
I	O	O
need	O	O
is	O	O
a	O	O
string	O	O
containing	O	O
all	O	B-API
the	O	O
elements	O	O
in	O	O
the	O	O
list	O	B-API
linked	O	O
by	O	O
'	O	O
;	O	O
'	O	O
,	O	O
not	O	O
the	O	O
list	O	B-API
itself	O	O
,	O	O
so	O	O
it	O	O
seems	O	O
like	O	O
I	O	O
have	O	O
to	O	O
sum	O	B-API
all	O	B-API
the	O	O
elements	O	O
in	O	O
asString	O	O
with	O	O
another	O	O
iteration	O	O
?	O	O

the	O	O
output	O	O
I	O	O
need	O	O
:	O	O
`	O	O
S	O	O
=	O	O
[	O	O
2	O	O
,	O	O
5	O	O
,	O	O
8	O	O
,	O	O
11	O	O
,	O	O
14	O	O
]`	O	O
I	O	O
thought	O	O
something	O	O
like	O	O
:	O	O
`	O	O
S1	O	O
=	O	O
np.array	B-API	B-API
(	O	O
L	O	O
[:	O	O
]	O	O
[	O	O
1	O	O
,	O	O
0	O	O
])`	O	O
should	O	O
work	O	O
but	O	O
whatever	O	O
I	O	O
try	O	O
I	O	O
have	O	O
the	O	O
error	O	O
like	O	O
:	O	O
`	O	O
TypeError	O	O
:	O	O
list	O	B-API
indices	O	B-API
must	O	O
be	O	O
integers	O	O
,	O	O
not	O	O
tuple	O	O
`	O	O
.	O	O

I	O	O
need	O	O
it	O	O
because	O	O
in	O	O
the	O	O
next	O	B-API
part	O	O
I	O	O
will	O	O
sum	O	B-API
up	O	O
this	O	O
large	O	O
np.array	B-API	B-API
with	O	O
some	O	O
delta_array	O	O
that	O	O
has	O	O
the	O	O
same	O	O
shape	O	B-API
.	O	O

Used	O	O
reshape	B-API	B-API
to	O	O
make	O	O
rows	O	O
into	O	O
columns	O	O
.	O	O

I	O	O
understand	O	O
that	O	O
you	O	O
could	O	O
create	O	O
an	O	O
array	O	B-API
of	O	O
zeros	O	B-API
and	O	O
iteratively	O	O
change	O	O
the	O	O
values	O	B-API
in	O	O
each	O	O
column	O	O
,	O	O
but	O	O
I	O	O
also	O	O
understand	O	O
this	O	O
is	O	O
not	O	O
an	O	O
efficient	O	O
method	O	O
.	O	O

I'm	O	O
trying	O	O
to	O	O
implement	O	O
the	O	O
univariate	O	O
gradient	O	B-API
descent	O	O
algorithm	O	O
in	O	O
python	O	O
.	O	O

numpy	O	O
glossary	O	O
says	O	O
the	O	O
sum	O	B-API
along	O	O
axis	O	B-API
argument	O	O
`	O	O
axis=1	O	O
`	O	O
sums	O	O
over	O	B-API
rows	O	O
:	O	O
"	O	O
we	O	O
can	O	O
sum	O	B-API
each	O	O
row	O	O
of	O	O
an	O	O
array	O	B-API
,	O	O
in	O	O
which	O	O
case	O	O
we	O	O
operate	O	O
along	O	O
columns	O	O
,	O	O
or	O	O
axis	O	B-API
1	O	O
"	O	O
.	O	O

It	O	O
also	O	O
prints	O	O
out	O	O
the	O	O
new	O	O
indices	O	B-API
signature	O	O
.	O	O

At	O	O
first	O	B-API
,	O	O
your	O	O
`	O	O
result	O	O
`	O	O
does	O	O
not	O	O
look	O	O
like	O	O
a	O	O
complex	O	O
FFT	O	O
output	O	O

debug	O	O
performance	O	O
diff	O	B-API
of	O	O
Same	O	O
code	O	O
on	O	O
nearly	O	O
same	O	O
cpu	O	B-API
/	O	O
ram	O	O

The	O	O
HTML	O	O
file	O	O
generated	O	O
by	O	O
Cython	O	O
indicates	O	O
that	O	O
the	O	O
bottleneck	O	O
is	O	O
the	O	O
dot	O	B-API
products	O	O
(	O	O
which	O	O
is	O	O
expected	O	O
of	O	O
course	O	O
)	O	O
.	O	O

`	O	O
numpy.unique	B-API	B-API
`	O	O
with	O	O
`	O	O
return_index=True	O	O
`	O	O
will	O	O
give	O	O
you	O	O
a	O	O
list	O	B-API
of	O	O
indices	O	B-API
to	O	O
take	O	B-API
from	O	O
.	O	O

I	O	O
forgot	O	O
exactly	O	O
why	O	O
,	O	O
but	O	O
there	O	O
is	O	O
a	O	O
good	O	O
reason	O	O
why	O	O
you	O	O
calculate	O	O
it	O	O
as	O	O
the	O	O
ratio	O	O
between	O	B-API
these	O	O
two	O	O
averages	O	O
,	O	O
instead	O	O
of	O	O
directly	O	O
averaging	O	O
`	O	O
fft	B-API	B-API
(	O	O
y	O	O
)	O	O
/	O	O
fft	B-API	B-API
(	O	O
x	O	O
)`	O	O
.	O	O

Do	O	O
you	O	O
really	O	O
want	O	O
this	O	O
'	O	O
roll	B-API	B-API
'	O	O
?	O	O

By	O	O
adding	O	O
a	O	O
nonzero	O	B-API
number	O	O
at	O	B-API
the	O	O
end	O	O
of	O	O
the	O	O
array	O	B-API
,	O	O
you	O	O
can	O	O
still	O	O
use	O	B-API
np.nonzero	B-API	B-API
to	O	O
get	O	B-API
your	O	O
desired	O	O
outcome	O	O
.	O	O

which	O	O
simply	O	O
sorts	O	O
the	O	O
terms	O	O
and	O	O
then	O	O
takes	O	O
the	O	O
ones	O	B-API
which	O	O
aren't	O	O
equal	O	B-API
to	O	O
the	O	O
previous	O	O
one	O	O
.	O	O

4	O	O
:	O	O
I	O	O
am	O	O
not	O	O
sure	O	O
about	O	O
the	O	O
indices	O	B-API
,	O	O
by	O	O
writing	O	O
couple	O	O
of	O	O
code	O	O
lines	O	B-API
I	O	O
just	O	O
able	O	O
to	O	O
get	O	B-API
cluster	O	O
indices	O	B-API
based	O	O
on	O	O
fclusterdata	O	O
.	O	O

Matlab	O	O
gives	O	O
me	O	O
a	O	O
norm	O	B-API
=	O	O
2	O	O
for	O	O
your	O	O
matrix	O	B-API
.	O	O

I	O	O
first	O	B-API
generated	O	O
a	O	O
labelled	O	O
array	O	B-API
of	O	O
unique	O	B-API
IDs	O	O
for	O	O
each	O	O
discrete	O	O
region	O	O
,	O	O
calculated	O	O
sizes	O	O
for	O	O
each	O	O
ID	O	O
,	O	O
masked	O	B-API
the	O	O
size	O	B-API
array	O	B-API
to	O	O
focus	O	O
only	O	O
on	O	O
size	O	B-API
==	O	O
1	O	O
blobs	O	O
,	O	O
then	O	O
index	O	B-API
the	O	O
original	O	O
array	O	B-API
and	O	O
set	O	B-API
IDs	O	O
with	O	O
a	O	O
size	O	B-API
==	O	O
1	O	O
to	O	O
0	O	O
:	O	O
#CODE	O	O

absolute	B-API	B-API
(	O	O
a	O	O
-	O	O
b	O	O
)	O	O
=	O	O
(	O	O
atol	O	O
+	O	O
rtol	O	O
*	O	O
absolute	B-API	B-API
(	O	O
b	O	O
))	O	O

Then	O	O
I	O	O
reshape	O	B-API
this	O	O
to	O	O
form	O	O
a	O	O
2D	O	O
numpy	O	O
array	O	B-API
.	O	O

n=5	O	O
(	O	O
min	O	B-API
length	O	O
of	O	O
sequence	O	O
)	O	O

I	O	O
have	O	O
written	O	O
a	O	O
function	O	B-API
which	O	O
contains	O	B-API
nested	O	O
loops	O	O
and	O	O
a	O	O
conditional	O	O
statement	O	O
;	O	O
the	O	O
purpose	O	O
of	O	O
the	O	O
loop	O	O
is	O	O
to	O	O
return	O	O
a	O	O
list	O	B-API
of	O	O
indices	O	B-API
for	O	O
the	O	O
nearest	O	O
elements	O	O
in	O	O
array	O	B-API
x	O	O
when	O	O
compared	O	O
to	O	O
array	O	B-API
y	O	O
.	O	O

I	O	O
also	O	O
want	O	O
to	O	O
color	O	O
the	O	O
1D	O	O
histogram	O	B-API
bars	O	O
according	O	O
to	O	O
the	O	O
same	O	O
normalization	O	O
.	O	O

If	O	O
you	O	O
are	O	O
calling	O	O
it	O	O
with	O	O
an	O	O
empty	O	B-API
matrix	O	B-API
for	O	O
[	O	O
low	O	O
,	O	O
high	O	O
]	O	O
it	O	O
will	O	O
just	O	O
use	O	B-API
whatever	O	O
the	O	O
max	O	B-API
and	O	O
min	O	B-API
values	O	B-API
in	O	O
the	O	O
array	O	B-API
are	O	O
.	O	O

Creating	O	O
a	O	O
class	O	O
deriving	O	O
from	O	O
`	O	O
ndarray	B-API	O
`	O	O
and	O	O
overriding	O	O
indexing	O	O
such	O	O
that	O	O
the	O	O
absolute	O	B-API
indices	O	B-API
are	O	O
used	O	O
.	O	O

One	O	O
solution	O	O
is	O	O
to	O	O
sort	O	B-API
both	O	O
arrays	O	O
(	O	O
adding	O	O
an	O	O
index	O	B-API
column	O	O
so	O	O
that	O	O
the	O	O
sorted	O	O
arrays	O	O
still	O	O
contains	O	B-API
the	O	O
original	O	O
indices	O	B-API
)	O	O
.	O	O

Use	O	O
`	O	O
reshape	B-API	B-API
`	O	O
:	O	O
#CODE	O	O

What's	O	O
wrong	O	O
with	O	O
the	O	O
normal	O	B-API
div	O	B-API
/	O	O
mod	O	B-API
operations	O	O
?	O	O

You	O	O
can	O	O
use	O	B-API
`	O	O
argmin	B-API	B-API
`	O	O
to	O	O
find	O	B-API
the	O	O
False	O	O
values	O	B-API
,	O	O
and	O	O
this	O	O
will	O	O
be	O	O
faster	O	O
and	O	O
take	O	B-API
less	O	B-API
memory	O	O
than	O	O
using	O	O
nonzero	B-API	B-API
,	O	O
but	O	O
this	O	O
is	O	O
linear	O	O
in	O	O
the	O	O
length	O	O
of	O	O
`	O	O
a	O	O
`	O	O
.	O	O

I'd	O	O
like	O	O
it	O	O
to	O	O
be	O	O
like	O	O
8x10^8	O	O
or	O	O
.8x10	O	O
^9	O	O
to	O	O
save	O	B-API
space	O	B-API
instead	O	O
of	O	O
putting	O	O
all	O	B-API
those	O	O
zeros	O	B-API
.	O	O

The	O	O
one	O	O
I	O	O
pointed	O	O
out	O	O
in	O	O
a	O	O
comment	O	O
to	O	O
other	O	O
answer	O	O
as	O	O
to	O	O
encode	O	B-API
the	O	O
binary	O	O
representation	O	O
of	O	O
the	O	O
array	O	B-API
as	O	O
a	O	O
Base64	O	O
text	O	B-API
block	O	O
.	O	O

due	O	O
to	O	O
broadcasting	O	O
,	O	O
you	O	O
don't	O	O
need	O	O
to	O	O
repeat	O	B-API
duplicate	O	O
indices	O	B-API
,	O	O
thus	O	O
:	O	O
#CODE	O	O

Maybe	O	O
`	O	O
flatten()	B-API	O
`	O	O
the	O	O
original	O	O
array	O	B-API
,	O	O
then	O	O
use	O	B-API
your	O	O
1D	O	O
solution	O	O
,	O	O
finally	O	O
calculate	O	O
the	O	O
real	O	B-API
nD	O	O
indices	O	B-API
using	O	O
the	O	O
original	O	O
shape	O	B-API
?	O	O

Note	O	O
that	O	O
the	O	O
diagonal	O	B-API
is	O	O
always	O	O
zero	O	O
since	O	O
`	O	O
mahalanobis	O	O
(	O	O
x	O	O
,	O	O
x	O	O
)`	O	O
equals	O	B-API
zero	O	O
for	O	O

possible	O	O
duplicate	O	O
of	O	O
[	O	O
NumPy	O	O
min	B-API	B-API
/	O	O
max	B-API	B-API
in-place	O	O
assignment	O	O
]	O	O
(	O	O
#URL	O	O
)	O	O

Once	O	O
the	O	O
tree	O	O
structure	O	O
has	O	O
been	O	O
built	O	O
,	O	O
go	O	O
back	O	B-API
and	O	O
collect	O	O
all	O	B-API
the	O	O
branches	O	O
and	O	O
leaves	O	O
into	O	O
the	O	O
array	O	B-API
structure	O	O
and	O	O
by	O	O
definition	O	O
,	O	O
they	O	O
will	O	O
be	O	O
unique	O	B-API
.	O	O

I	O	O
wrote	O	O
the	O	O
following	O	O
code	O	O
but	O	O
the	O	O
output	O	O
only	O	O
contains	O	B-API
the	O	O
ids	O	B-API
(	O	O
single	O	O
column	O	O
)	O	O
.	O	O

Maximum	O	O
is	O	O
always	O	O
bigger	O	O
than	O	O
the	O	O
minimum	O	B-API
(	O	O
more	O	O
to	O	O
the	O	O
right	O	O
on	O	O
a	O	O
1d	O	O
axis	O	B-API
,	O	O
not	O	O
by	O	O
absolute	O	B-API
value	O	O
)	O	O
.	O	O

Note	O	O
that	O	O
`	O	O
unq_count	O	O
`	O	O
doesn't	O	O
count	O	B-API
the	O	O
occurrences	O	O
of	O	O
the	O	O
last	O	B-API
unique	O	B-API
item	O	B-API
,	O	O
because	O	O
that	O	O
is	O	O
not	O	O
needed	O	O
to	O	O
split	O	B-API
the	O	O
index	O	B-API
array	O	B-API
.	O	O

If	O	O
yes	O	O
,	O	O
you	O	O
can	O	O
use	O	B-API
the	O	O
Linux	O	O
terminal	O	O
to	O	O
strip	O	B-API
quotes	O	O
from	O	O
the	O	O
ends	O	O
of	O	O
the	O	O
rows	O	O
quickly	O	O
.	O	O

The	O	O
append	B-API	B-API
method	O	O
for	O	O
a	O	O
numpy	O	O
array	O	B-API
returns	O	O
a	O	O
copy	O	B-API
of	O	O
the	O	O
array	O	B-API
with	O	O
new	O	O
items	O	O
added	O	O
to	O	O
the	O	O
end	O	O
.	O	O

I	O	O
want	O	O
to	O	O
get	O	B-API
the	O	O
norm	B-API	B-API
of	O	O
this	O	O
array	O	B-API
using	O	O
numpy	O	O
.	O	O

The	O	O
only	O	O
problem	O	O
here	O	O
is	O	O
that	O	O
I	O	O
think	O	O
it	O	O
will	O	O
append	O	B-API
directly	O	O
to	O	O
the	O	O
column	O	O
,	O	O
when	O	O
I	O	O
would	O	O
prefer	O	O
it	O	O
to	O	O
append	O	B-API
to	O	O
a	O	O
new	O	O
column	O	O
.	O	O

You	O	O
don't	O	O
need	O	O
to	O	O
import	O	O
string	O	O
,	O	O
and	O	O
you	O	O
don't	O	O
need	O	O
to	O	O
loop	O	O
through	O	O
all	O	B-API
the	O	O
lines	O	B-API
and	O	O
append	O	B-API
text	O	B-API
or	O	O
count	O	B-API
the	O	O
characters	O	O
.	O	O

The	O	O
transpose	O	B-API
of	O	O
the	O	O
transpose	O	B-API
of	O	O
a	O	O
matrix	O	B-API
==	O	O
that	O	O
matrix	O	B-API
,	O	O
or	O	O
,	O	O
[	O	O
A^T	O	O
]	O	O
^T	O	O
==	O	O
A	O	O
.	O	O

Currently	O	O
I	O	O
am	O	O
looping	O	O
through	O	O
the	O	O
arrays	O	O
and	O	O
using	O	O
numpy.dstack	B-API	B-API
to	O	O
stack	O	B-API
the	O	O
1000	O	O
arrays	O	O
into	O	O
a	O	O
rather	O	O
large	O	O
3d	O	O
array	O	B-API
...	O	O
and	O	O
then	O	O
will	O	O
calculate	O	O
the	O	O
mean	O	B-API
across	O	O
the	O	O
3rd	O	O
(	O	O
?	O	O
)	O	O
dimension	O	O
.	O	O

If	O	O
you	O	O
strip	O	B-API
all	O	B-API
these	O	O
out	O	O
and	O	O
just	O	O
call	O	O
lapack	O	O
in	O	O
your	O	O
for	O	O
loop	O	O
(	O	O
since	O	O
you	O	O
already	O	O
know	O	O
the	O	O
dimensions	O	O
of	O	O
your	O	O
matrix	O	B-API
and	O	O
maybe	O	O
know	O	O
that	O	O
it's	O	O
real	O	B-API
,	O	O
not	O	O
complex	O	O
)	O	O
,	O	O
things	O	O
run	O	O
MUCH	O	O
faster	O	O
(	O	O
Note	O	O
that	O	O
I've	O	O
made	O	O
my	O	O
array	O	B-API
larger	O	O
)	O	O
:	O	O
#CODE	O	O

First	O	O
,	O	O
you	O	O
have	O	O
a	O	O
binomial	O	B-API
response	O	O
:	O	O
having	O	O
or	O	O
not	O	O
having	O	O
a	O	O
particular	O	O
behavior	O	O
.	O	O

The	O	O
call	O	O
to	O	O
`	O	O
np.sqrt	B-API	B-API
`	O	O
,	O	O
which	O	O
is	O	O
a	O	O
Python	O	O
function	O	B-API
call	O	O
,	O	O
is	O	O
killing	O	O
your	O	O
performance	O	O
You	O	O
are	O	O
computing	O	O
the	O	O
square	O	B-API
root	O	O
of	O	O
scalar	O	O
floating	O	O
point	O	O
value	O	O
,	O	O
so	O	O
you	O	O
should	O	O
use	O	B-API
the	O	O
`	O	O
sqrt	B-API	B-API
`	O	O
function	O	B-API
from	O	O
the	O	O
C	O	O
math	O	B-API
library	O	B-API
.	O	O

This	O	O
would	O	O
call	O	O
the	O	O
function	O	B-API
`	O	O
np.loadtxt	B-API	B-API
`	O	O
which	O	O
would	O	O
load	O	B-API
the	O	O
file	O	O
`	O	O
GPBUSD1d.txt	O	O
'`	O	O
and	O	O
transpose	O	B-API
(	O	O
"	O	O
unpack	O	O
")	O	O
it	O	O
.	O	O

You	O	O
can't	O	O
change	O	O
the	O	O
typing	O	O
of	O	O
the	O	O
array	O	B-API
in-place	O	O
(	O	O
unless	O	O
I'm	O	O
grossly	O	O
mistaken	O	O
)	O	O
,	O	O
but	O	O
you	O	O
can	O	O
floor	B-API	B-API
.	O	O

Finally	O	O
I	O	O
just	O	O
transpose	O	B-API
the	O	O
dataframe	O	O
to	O	O
get	O	B-API
ids	O	B-API
as	O	O
rows	O	O
and	O	O
categories	O	B-API
as	O	O
columns	O	O
.	O	O

The	O	O
following	O	O
way	O	O
of	O	O
obtaining	O	O
the	O	O
unique	O	B-API
elements	O	O
in	O	O
all	O	B-API
sub-arrays	O	O
is	O	O
very	O	O
fast	O	O
:	O	O
#CODE	O	O

You	O	O
can't	O	O
use	O	B-API
the	O	O
numpy	O	O
reshape	B-API	B-API
for	O	O
a	O	O
simple	O	O
reason	O	O
:	O	O
you	O	O
have	O	O
data	O	B-API
duplicity	O	O
in	O	O
your	O	O
original	O	O
array	O	B-API
(	O	O
time	O	B-API
and	O	O
positions	O	O
)	O	O
and	O	O
not	O	O
in	O	O
the	O	O
result	O	O
you	O	O
want	O	O
.	O	O

So	O	O
it	O	O
does	O	O
not	O	O
make	O	O
much	O	O
sense	O	O
to	O	O
me	O	O
to	O	O
reshape	O	B-API
it	O	O
to	O	O
a	O	O
"	O	O
1d-matrix	O	O
"	O	O
.	O	O

Now	O	O
create	O	O
5-bit	O	O
bitstrings	O	O
from	O	O
each	O	O
integer	O	O
and	O	O
join	O	B-API
them	O	O
together	O	O
:	O	O
#CODE	O	O

It	O	O
would	O	O
probably	O	O
be	O	O
just	O	O
as	O	O
much	O	O
work	O	O
to	O	O
translate	O	B-API
the	O	O
top	O	O
Matlab	O	O
routine	O	O
from	O	O
Maurits	O	O
.	O	O

In	O	O
the	O	O
particular	O	O
case	O	O
of	O	O
your	O	O
example	O	O
,	O	O
where	O	B-API
your	O	O
unique	O	B-API
values	O	B-API
are	O	O
sequential	O	O
integers	O	O
,	O	O
you	O	O
can	O	O
use	O	B-API
`	O	O
find_objects	O	O
`	O	O
directly	O	O
.	O	O

axis=1	O	O
refers	O	O
to	O	O
working	O	O
on	O	O
rows	O	O
in	O	O
this	O	O
2d	O	O
case	O	O
(	O	O
axis=0	O	O
,	O	O
in	O	O
contrast	O	O
,	O	O
would	O	O
be	O	O
getting	O	O
you	O	O
the	O	O
max	B-API	B-API
in	O	O
each	O	O
column	O	O
)	O	O

There	O	O
are	O	O
many	O	O
other	O	O
`	O	O
ufunc	O	O
`	O	O
,	O	O
and	O	O
other	O	O
iteration	O	O
modes	O	O
-	O	O
`	O	O
accumulate	B-API	B-API
`	O	O
,	O	O
`	O	O
reduceat	B-API	O
`	O	O
.	O	O

All	O	O
diagonal	O	B-API
elements	O	O
will	O	O
be	O	O
of	O	O
the	O	O
form	O	O
`	O	O
s_i	O	O
**	O	O
2	O	O
/	O	O
s_i	O	O
**	O	O
2	O	O
==	O	O
1	O	O
`	O	O
.	O	O

@USER	O	O
In	O	O
the	O	O
example	O	O
above	O	O
,	O	O
I	O	O
get	O	B-API
the	O	O
following	O	O
error	O	O
:	O	O
Non-broadcastable	O	O
operand	O	O
with	O	O
shape	O	B-API
(	O	O
100	O	O
)	O	O
doesn't	O	O
match	O	B-API
the	O	O
broadcast	B-API	B-API
shape	O	B-API
(	O	O
100,100	O	O
)	O	O

is	O	O
calculated	O	O
such	O	O
that	O	O
all	O	B-API
but	O	O
the	O	O
diagonal	O	B-API
#CODE	O	O

To	O	O
compute	O	O
the	O	O
number	O	O
of	O	O
unique	O	B-API
elements	O	O
in	O	O
a	O	O
numpy	O	O
array	O	B-API
,	O	O
you	O	O
can	O	O
use	O	B-API
`	O	O
unique	B-API	B-API
(	O	O
x	O	O
)	O	O
.size	O	B-API
`	O	O
or	O	O
`	O	O
len	B-API	B-API
(	O	O
unique	B-API	B-API
(	O	O
x	O	O
))`	O	O
(	O	O
see	O	O
`	O	O
numpy.unique	B-API	B-API
`	O	O
)	O	O
.	O	O

Or	O	O
would	O	O
that	O	O
basically	O	O
require	O	B-API
implementing	O	O
the	O	O
outer	O	B-API
loop	O	O
in	O	O
Cython	O	O
?	O	O

For	O	O
a	O	O
tensor	O	O
it	O	O
is	O	O
not	O	O
clear	O	B-API
how	O	O
to	O	O
define	O	O
an	O	O
inverse	O	B-API
or	O	O
a	O	O
transpose	O	B-API
.	O	O

Second	O	O
,	O	O
you	O	O
are	O	O
doing	O	O
transpose	B-API	B-API
the	O	O
hard	O	O
way	O	O
.	O	O

Where	O	O
does	O	O
log	B-API	B-API
(	O	O
b	O	O
,	O	O
2	O	O
)	O	O
come	O	O
from	O	O
?	O	O

(	O	O
The	O	O
values	O	B-API
in	O	O
the	O	O
corners	O	O
correspond	O	O
to	O	O
the	O	O
diagonal	O	B-API
elements	O	O
.	O	O
)	O	O

I	O	O
tried	O	O
using	O	O
the	O	O
scipy.stat	O	B-API
module	O	O
by	O	O
creating	O	O
my	O	O
numbers	O	O
with	O	O
`	O	O
np.random.normal	B-API	B-API
`	O	O
,	O	O
since	O	O
it	O	O
only	O	O
takes	O	O
data	O	B-API
and	O	O
not	O	O
stat	O	O
values	O	B-API
like	O	O
mean	O	B-API
and	O	O
std	O	B-API
dev	O	O
(	O	O
is	O	O
there	O	O
any	O	B-API
way	O	O
to	O	O
use	O	B-API
these	O	O
values	O	B-API
directly	O	O
)	O	O
.	O	O

The	O	O
asymptotic	O	O
complexity	O	O
of	O	O
both	O	O
of	O	O
the	O	O
`	O	O
matrix_rank	B-API	O
`	O	O
and	O	O
`	O	O
det	B-API	B-API
`	O	O
calls	O	O
are	O	O
therefore	O	O
O	O	O
(	O	O
n^3	O	O
)	O	O
,	O	O
the	O	O
complexity	O	O
of	O	O
LU	O	O
decomposition	O	O
.	O	O

I	O	O
think	O	O
the	O	O
np.std()	B-API	B-API
is	O	O
just	O	O
universal	O	O
std	B-API	B-API
.	O	O

Golub	O	O
and	O	O
Van	O	O
Loan	O	O
also	O	O
provide	O	O
a	O	O
way	O	O
of	O	O
storing	O	O
a	O	O
matrix	O	B-API
in	O	O
diagonal	O	B-API
dominant	O	O
form	O	O
.	O	O

I	O	O
see	O	O
no	O	O
reason	O	O
why	O	O
`	O	O
numpy	O	O
`	O	O
would	O	O
need	O	O
to	O	O
make	O	O
a	O	O
copy	O	B-API
for	O	O
an	O	O
operation	O	O
like	O	O
this	O	O
,	O	O
as	O	O
long	O	O
as	O	O
it	O	O
does	O	O
the	O	O
necessary	O	O
checks	O	O
for	O	O
overlaps	O	O
(	O	O
though	O	O
of	O	O
course	O	O
as	O	O
others	O	O
have	O	O
noted	O	O
,	O	O
`	O	O
resize	B-API	B-API
`	O	O
may	O	O
itself	O	O
have	O	O
to	O	O
allocate	O	O
a	O	O
new	O	O
block	O	O
of	O	O
memory	O	O
)	O	O
.	O	O

I	O	O
found	O	O
another	O	O
stack	O	B-API
question	O	O
about	O	O
this	O	O
here	O	O
,	O	O
but	O	O
I	O	O
am	O	O
not	O	O
entirely	O	O
sure	O	O
how	O	O
it	O	O
was	O	O
resolved	O	O
,	O	O
I'm	O	O
still	O	O
a	O	O
little	O	O
confused	O	O
.	O	O

Maybe	O	O
`	O	O
floor	B-API	B-API
(	O	O
arange	B-API	O
(	O	O
0	O	O
,	O	O
10	O	O
,	O	O
0.1	O	O
))`	O	O
?	O	O

In	O	O
python	O	O
,	O	O
I	O	O
would	O	O
like	O	O
to	O	O
convolve	O	B-API
the	O	O
two	O	O
matrices	O	O
along	O	O
the	O	O
second	O	B-API
axis	O	B-API
only	O	O
.	O	O

`	O	O
view	B-API	B-API
`	O	O
is	O	O
basically	O	O
taking	O	O
your	O	O
two	O	O
coordinates	O	O
as	O	O
a	O	O
single	O	O
variable	O	O
that	O	O
can	O	O
be	O	O
used	O	O
to	O	O
find	O	B-API
the	O	O
unique	O	B-API
coordinates	O	O
.	O	O

Keep	O	O
in	O	O
mind	O	O
that	O	O
machine	O	O
precision	O	O
for	O	O
a	O	O
32-bit	O	O
double	O	O
is	O	O
~	O	O
10^-16	O	O
,	O	O
which	O	O
will	O	O
be	O	O
an	O	O
absolute	O	B-API
limiting	O	O
factor	O	O
.	O	O

Also	O	O
,	O	O
if	O	O
there	O	O
is	O	O
then	O	O
I	O	O
could	O	O
just	O	O
append	O	B-API
to	O	O
the	O	O
b	O	O
and	O	O
c	O	O
arrays	O	O
each	O	O
time	O	B-API
instead	O	O
of	O	O
overwriting	O	O
and	O	O
starting	O	O
from	O	O
scratch	O	O
each	O	O
loop	O	O
.	O	O

Use	O	O
`	O	O
multiprocessing.Process	O	O
(	O	O
target	O	O
=	O	O
somefunc	O	O
,	O	O
args	O	O
=	O	O
(	O	O
sa	O	O
,	O	O
)`	O	O
(	O	O
and	O	O
`	O	O
start	O	O
`	O	O
,	O	O
maybe	O	O
`	O	O
join	B-API	B-API
`)	O	O
to	O	O
call	O	O
`	O	O
somefunc	O	O
`	O	O
in	O	O
a	O	O
separate	O	O
process	O	B-API
,	O	O
passing	O	O
the	O	O
shared	O	O
array	O	B-API
.	O	O

Take	O	O
a	O	O
look	O	O
a	O	O
the	O	O
concatenate	B-API	B-API
function	O	B-API
.	O	O

Unlike	O	O
Joe	O	O
Kington's	O	O
answer	O	O
,	O	O
the	O	O
benefit	O	O
of	O	O
this	O	O
is	O	O
that	O	O
you	O	O
don't	O	O
need	O	O
to	O	O
know	O	O
the	O	O
original	O	O
shape	O	B-API
of	O	O
the	O	O
data	O	B-API
in	O	O
the	O	O
`	O	O
.mat	O	B-API
`	O	O
file	O	O
,	O	O
i.e.	O	B-API
no	O	O
need	O	O
to	O	O
reshape	O	B-API
upon	O	O
reading	O	O
in	O	O
.	O	O

but	O	O
I	O	O
think	O	O
,	O	O
finding	O	O
the	O	O
local	O	O
max	O	B-API
can	O	O
be	O	O
simplified	O	O
to	O	O
:	O	O
#CODE	O	O

@USER	O	O
`	O	O
swapaxes	B-API	O
`	O	O
seemed	O	O
to	O	O
be	O	O
indistinguishable	O	O
from	O	O
`	O	O
transpose	B-API	B-API
(	O	O
0	O	O
,	O	O
2	O	O
,	O	O
1	O	O
)`	O	O
.	O	O

Do	O	O
gradient	B-API	B-API
actually	O	O
compute	O	O
really	O	O
a	O	O
gradient	O	B-API
?	O	O

I	O	O
would	O	O
suggest	O	O
to	O	O
first	O	B-API
program	O	O
it	O	O
with	O	O
`	O	O
np.nditer	B-API	B-API
`	O	O
and	O	O
then	O	O
translate	O	B-API
it	O	O
into	O	O
C	O	O
.	O	O

As	O	O
you	O	O
can	O	O
see	O	O
,	O	O
using	O	O
the	O	O
join	B-API	B-API
function	O	B-API
on	O	O
the	O	O
list	O	B-API
(	O	O
`	O	O
binary_list	O	O
`)	O	O
works	O	O
properly	O	O
,	O	O
but	O	O
on	O	O
the	O	O
equivalent	O	O
numpy	O	O
array	O	B-API
(	O	O
`	O	O
binary_split_array	O	O
`)	O	O
it	O	O
doesn't	O	O
:	O	O
we	O	O
can	O	O
see	O	O
the	O	O
string	O	O
returned	O	O
is	O	O
only	O	O
72	O	O
characters	O	O
long	O	O
instead	O	O
of	O	O
80	O	O
.	O	O

@USER	O	O
.B	O	O
.	O	O
the	O	O
above	O	O
question	O	O
is	O	O
significantly	O	O
different	O	O
from	O	O
mine	O	O
;	O	O
it	O	O
asks	O	O
for	O	O
both	O	O
min	B-API	B-API
and	O	O
max	B-API	B-API
,	O	O
and	O	O
it	O	O
is	O	O
for	O	O
2D	O	O
matrix	O	B-API

This	O	O
will	O	O
join	O	B-API
the	O	O
rows	O	O
and	O	O
write	O	O
them	O	O
to	O	O
a	O	O
new	O	O
csv	O	O
:	O	O
#CODE	O	O

The	O	O
reason	O	O
I	O	O
have	O	O
`	O	O
-det	O	O
(	O	O
mat	O	B-API
)`	O	O
in	O	O
the	O	O
energy	O	O
function	O	B-API
is	O	O
because	O	O
the	O	O
simulated	O	O
annealing	O	O
algorithm	O	O
does	O	O
minimization	O	O
.	O	O

Also	O	O
is	O	O
`	O	O
x	O	O
`	O	O
unique	O	B-API
?	O	O

Pandas	O	O
append	B-API	B-API
filtered	O	O
row	O	O
to	O	O
another	O	O
DataFrame	O	B-API

Again	O	O
,	O	O
the	O	O
code	O	O
notes	O	O
that	O	O
set	O	B-API
of	O	O
combinations	O	O
is	O	O
not	O	O
unique	O	B-API
;	O	O
but	O	O
it	O	O
does	O	O
have	O	O
a	O	O
unique	O	B-API
subset	O	O
,	O	O
namely	O	O
[[	O	O
2	O	O
3	O	O
]	O	O
,	O	O
[	O	O
0	O	O
1	O	O
]]	O	O
,	O	O
which	O	O
as	O	O
you	O	O
just	O	O
revealed	O	O
,	O	O
you	O	O
do	O	O
consider	O	O
a	O	O
valid	O	B-API
combination	O	O
.	O	O

That	O	O
concatenate	B-API	B-API
action	O	O
should	O	O
be	O	O
pretty	O	O
fast	O	O
.	O	O

If	O	O
you	O	O
want	O	O
to	O	O
pass	O	O
in	O	O
the	O	O
transpose	O	B-API
,	O	O
you'll	O	O
need	O	O
to	O	O
set	O	B-API
`	O	O
rowvar	O	O
`	O	O
to	O	O
zero	O	O
.	O	O

You	O	O
can	O	O
override	O	O
this	O	O
behavior	O	O
by	O	O
using	O	O
the	O	O
arguments	O	O
`	O	O
vmin	O	O
`	O	O
and	O	O
`	O	O
vmax	O	O
`	O	O
(	O	O
or	O	O
`	O	O
norm	O	B-API
`)	O	O
of	O	O
`	O	O
imshow	B-API	O
`	O	O
.	O	O

@USER	O	O
,	O	O
`	O	O
cs	O	O
`	O	O
is	O	O
sorted	O	O
and	O	O
`	O	O
searchsorted()	B-API	O
`	O	O
exploits	O	O
that	O	O
to	O	O
do	O	O
a	O	O
binary	O	O
search	O	O
-	O	O
only	O	O
`	O	O
O	O	O
(	O	O
log	B-API	B-API
(	O	O
len	B-API	B-API
(	O	O
weights	O	O
)))`	O	O
comparisons	O	O
are	O	O
needed	O	O
.	O	O

Think	O	O
`	O	O
flatten	B-API	B-API
`	O	O
without	O	O
the	O	O
copy	O	B-API
.	O	O

In	O	O
your	O	O
case	O	O
it	O	O
looks	O	O
like	O	O
the	O	O
weight	O	O
arrays	O	O
will	O	O
have	O	O
the	O	O
same	O	O
dimension	O	O
as	O	O
'	O	O
A	O	O
'	O	O
,	O	O
so	O	O
you	O	O
reshape	O	B-API
them	O	O
accordingly	O	O
and	O	O
multiply	O	B-API
dx	O	O
and	O	O
dy	O	O
by	O	O
their	O	O
individual	O	O
weight	O	O
vectors	O	O
.	O	O

Does	O	O
this	O	O
mean	O	B-API
the	O	O
standard	O	O
error	O	O
of	O	O
the	O	O
gradient	O	B-API
or	O	O
intercept	O	O
?	O	O

Also	O	O
,	O	O
the	O	O
algo	O	O
has	O	O
a	O	O
lot	O	O
of	O	O
matrices	O	O
manipulation	O	O
(	O	O
fft	B-API	B-API
,	O	O
filters	O	O
,	O	O
etc	O	O
.	O	O
)	O	O
,	O	O
so	O	O
using	O	O
numpy	O	O
/	O	O
scipy	O	O
should	O	O
result	O	O
in	O	O
faster	O	O
run	O	O
time	O	B-API
.	O	O

You	O	O
can	O	O
broadcast	O	B-API
that	O	O
into	O	O
an	O	O
array	O	B-API
using	O	O
expressions	O	O
,	O	O
for	O	O
example	O	O
#CODE	O	O

If	O	O
I	O	O
use	O	B-API
the	O	O
above	O	O
test	O	B-API
on	O	O
the	O	O
absolute	O	B-API
values	O	B-API
of	O	O
the	O	O
angles	O	O
to	O	O
be	O	O
tested	O	O
,	O	O
everything	O	O

The	O	O
returned	O	O
gradient	O	B-API
hence	O	O
has	O	O

"	O	O
In	O	O
the	O	O
first	O	B-API
case	O	O
the	O	O
gradient	O	B-API
is	O	O
1	O	O
mV	O	O
/	O	O
ms	O	O
,	O	O
in	O	O
the	O	O
second	O	B-API
case	O	O
it	O	O
is	O	O
50	O	O
mV	O	O
/	O	O
ms	O	O
.	O	O

If	O	O
True	O	O
,	O	O
uses	O	O
the	O	O
old	O	O
behavior	O	O
from	O	O
Numeric	O	O
,	O	O
(	O	O
correlate	B-API	B-API
(	O	O
a	O	O
,	O	O
v	O	O
)	O	O
==	O	O
correlate	B-API	B-API
(	O	O
v	O	O
,	O	O
a	O	O
)	O	O
,	O	O
and	O	O
the	O	O
conjugate	O	B-API
is	O	O
not	O	O
taken	O	O
for	O	O
complex	O	O
arrays	O	O
)	O	O
.	O	O

Why	O	O
don't	O	O
you	O	O
just	O	O
compress	O	B-API
the	O	O
files	O	O
with	O	O
the	O	O
built-in	O	O
`	O	O
gzip	O	O
`	O	O
module	O	O
?	O	O

So	O	O
you	O	O
need	O	O
to	O	O
write	O	O
some	O	O
function	O	B-API
that	O	O
convert	O	B-API
a	O	O
poly	O	B-API
parameters	O	O
array	O	B-API
to	O	O
a	O	O
latex	O	O
string	O	O
,	O	O
here	O	O
is	O	O
an	O	O
example	O	O
:	O	O
#CODE	O	O

In	O	O
your	O	O
example	O	O
,	O	O
the	O	O
square	O	B-API
root	O	O
is	O	O
calculated	O	O
by	O	O
evaluating	O	O
the	O	O
the	O	O
module	O	O
and	O	O
the	O	O
argument	O	O
of	O	O
your	O	O
complex	O	O
number	O	O
(	O	O
essentially	O	O
via	O	O
the	O	O
log	B-API	B-API
function	O	B-API
,	O	O
which	O	O
returns	O	O
log	B-API	B-API
(	O	O
module	O	O
)	O	O
+	O	O
i	O	O
phase	O	O
)	O	O
.	O	O

I	O	O
am	O	O
trying	O	O
to	O	O
run	O	O
hstack	B-API	O
to	O	O
join	O	B-API
a	O	O
column	O	O
of	O	O
integer	O	O
values	O	B-API
to	O	O
a	O	O
list	O	B-API
of	O	O
columns	O	O
created	O	O
by	O	O
a	O	O
TF-IDF	O	O
(	O	O
so	O	O
I	O	O
can	O	O
eventually	O	O
use	O	B-API
all	O	B-API
of	O	O
these	O	O
columns	O	O
/	O	O
features	O	O
in	O	O
a	O	O
classifier	O	O
)	O	O
.	O	O

How	O	O
to	O	O
pass	O	O
these	O	O
`	O	O
norm	O	B-API
`	O	O
and	O	O
`	O	O
cmap	O	O
`	O	O
parameters	O	O
in	O	O
matplotlib	O	O
to	O	O
`	O	O
plt.show	B-API	B-API
`	O	O
or	O	O
`	O	O
imshow()	B-API	O
`	O	O
?	O	O

Forget	O	O
about	O	O
the	O	O
C	O	O
stack	O	B-API
,	O	O
numpy	O	O
objects	O	O
can't	O	O
use	O	B-API
it	O	O
.	O	O

You	O	O
can	O	O
use	O	B-API
the	O	O
append	B-API	B-API
function	O	B-API
as	O	O
he	O	O
has	O	O
defined	O	O
.	O	O

This	O	O
can	O	O
be	O	O
particularly	O	O
tricky	O	O
when	O	O
trying	O	O
to	O	O
append	O	B-API
to	O	O
a	O	O
numpy	O	O
array	O	B-API
quickly	O	O
.	O	O

I	O	O
have	O	O
a	O	O
question	O	O
regarding	O	O
to	O	O
the	O	O
`	O	O
fft	B-API	B-API
`	O	O
and	O	O
`	O	O
ifft	B-API	O
`	O	O
functions	O	O
.	O	O

So	O	O
for	O	O
now	O	O
,	O	O
I	O	O
just	O	O
changed	O	B-API
the	O	O
max	B-API	B-API
(	O	O
z	O	O
)	O	O
to	O	O
a	O	O
number	O	O
that	O	O
I	O	O
know	O	O
is	O	O
the	O	O
max	B-API	B-API
(	O	O
1567	O	O
)	O	O
.	O	O

The	O	O
`	O	O
add	B-API	B-API
`	O	O
operation	O	O
does	O	O
not	O	O
do	O	O
the	O	O
same	O	O
thing	O	O
as	O	O
`	O	O
join	B-API	B-API
`	O	O
.	O	O

You	O	O
don't	O	O
specify	O	O
`	O	O
x	O	O
`	O	O
or	O	O
`	O	O
y	O	O
`	O	O
,	O	O
and	O	O
your	O	O
`	O	O
mat	O	B-API
[:	O	O
,	O	O
i+1	O	O
]`	O	O
indexing	O	O
will	O	O
not	O	O
work	O	O
with	O	O
a	O	O
structured	O	O
array	O	B-API
.	O	O

This	O	O
is	O	O
because	O	O
in	O	O
some	O	O
cases	O	O
it's	O	O
not	O	O
just	O	O
NaNs	O	O
and	O	O
1s	O	O
,	O	O
but	O	O
other	O	O
integers	O	O
,	O	O
which	O	O
gives	O	O
a	O	O
std	O	B-API
>	O	O
0	O	O
.	O	O

You	O	O
could	O	O
check	O	O
whether	O	O
this	O	O
is	O	O
the	O	O
case	O	O
,	O	O
and	O	O
append	O	B-API
to	O	O
your	O	O
sample	O	B-API
in	O	O
a	O	O
loop	O	O
if	O	O
necessary	O	O
.	O	O

The	O	O
above	O	O
code	O	O
works	O	O
,	O	O
but	O	O
would	O	O
be	O	O
better	O	O
to	O	O
append	O	B-API
the	O	O
data_array	O	O
retrieved	O	O
from	O	O
for	O	O
loop	O	O
directly	O	O
into	O	O
the	O	O
numpy	O	O
array	O	B-API
rather	O	O
than	O	O
using	O	O
python	O	O
list	O	B-API
.	O	O

If	O	O
you	O	O
want	O	O
an	O	O
intersection	O	B-API
between	O	B-API
the	O	O
two	O	O
arrays	O	O
you	O	O
can	O	O
loop	O	O
;	O	O
for	O	O
i	O	O
data	O	B-API
:	O	O
and	O	O
get	O	B-API
i	O	O
from	O	O
first	O	B-API
array	O	B-API
,	O	O
and	O	O
i	O	O
from	O	O
second	O	B-API
array.But	O	O
I'm	O	O
not	O	O
sure	O	O
if	O	O
I	O	O
follow	O	O
it	O	O
correctly	O	O
,	O	O
you	O	O
have	O	O
some	O	O
data	O	B-API
which	O	O
has	O	O
0	O	O
occurences	O	O
in	O	O
some	O	O
columns	O	O
of	O	O
your	O	O
array	O	B-API
,	O	O
if	O	O
you	O	O
append	O	B-API
the	O	O
other	O	O
values	O	B-API
to	O	O
a	O	O
new	O	O
array	O	B-API
the	O	O
memory	O	O
of	O	O
where	O	B-API
in	O	O
the	O	O
data	O	B-API
those	O	O
values	O	B-API
came	O	O
from	O	O
is	O	O
already	O	O
automatically	O	O
stored	O	O
.	O	O

(	O	O
2	O	O
)	O	O
Collect	O	O
the	O	O
parts	O	O
of	O	O
the	O	O
SQL	O	O
command	O	O
in	O	O
a	O	O
list	O	B-API
and	O	O
do	O	O
a	O	O
`	O	O
str.join	B-API	B-API
`	O	O
in	O	O
the	O	O
end	O	O
,	O	O
to	O	O
avoid	O	O
allocating	O	O
an	O	O
increasingly	O	O
long	O	O
string	O	O
each	O	O
time	O	B-API
(	O	O
you	O	O
can't	O	O
really	O	O
append	O	B-API
to	O	O
a	O	O
string	O	O
in	O	O
Python	O	O
as	O	O
they	O	O
are	O	O
immutable	O	O
)	O	O
.	O	O

append	O	B-API
C	O	O
:\	O	O
libav\usr\bin\	O	O
to	O	O
the	O	O
'	O	O
Path	O	B-API
'	O	O
environment	O	O
variable	O	O

How	O	O
to	O	O
efficiently	O	O
join	O	B-API
a	O	O
list	O	B-API
of	O	O
values	O	B-API
to	O	O
a	O	O
list	O	B-API
of	O	O
intervals	O	O
?	O	O

The	O	O
alignment	O	O
angles	O	O
may	O	O
be	O	O
unique	O	B-API
,	O	O
a	O	O
discrete	O	O
set	O	B-API
,	O	O
or	O	O
a	O	O
continuum	O	O
as	O	O
below	O	O
.	O	O

Alternatively	O	O
,	O	O
you	O	O
could	O	O
assign	O	B-API
the	O	O
flip	O	O
cards	O	O
their	O	O
own	O	O
unique	O	B-API
IDs	O	O
and	O	O
store	O	O
them	O	O
in	O	O
the	O	O
same	O	O
record	O	B-API
array	O	B-API
as	O	O
the	O	O
regular	O	O
cards	O	O
,	O	O
as	O	O
the	O	O
properties	O	B-API
seem	O	O
to	O	O
have	O	O
the	O	O
same	O	O
names	O	B-API
,	O	O
and	O	O
then	O	O
have	O	O
a	O	O
`	O	O
flip_id	O	O
`	O	O
field	O	B-API
that	O	O
would	O	O
be	O	O
some	O	O
set	O	B-API
value	O	O
such	O	O
as	O	O
`	O	O
0	O	O
`	O	O
or	O	O
`	O	O
None	O	O
`	O	O
for	O	O
cards	O	O
without	O	O
flip	O	O
aspects	O	O
and	O	O
then	O	O
the	O	O
ID	O	O
of	O	O
the	O	O
flip	O	O
card	O	O
for	O	O
those	O	O
cards	O	O
that	O	O
do	O	O
have	O	O
a	O	O
flip	O	O
.	O	O

You	O	O
can	O	O
notice	O	O
that	O	O
there	O	O
is	O	O
gray	O	B-API
strip	O	B-API
on	O	O
top	O	O
and	O	O
on	O	O
the	O	O
left	O	O
...	O	O

Furthermore	O	O
you	O	O
then	O	O
go	O	O
and	O	O
compute	O	O
the	O	O
norm	O	B-API
of	O	O
those	O	O
three	O	O
values	O	B-API
.	O	O

Tables	O	O
have	O	O
an	O	O
append	B-API	B-API
method	O	O
that	O	O
can	O	O
easily	O	O
add	O	B-API
additional	O	O
rows	O	O
.	O	O

@USER	O	O
,	O	O
I	O	O
tested	O	O
the	O	O
append	B-API	B-API
method	O	O
of	O	O
array	O	B-API
by	O	O
measure	O	O
the	O	O
time	O	B-API
it	O	O
cost	O	O
,	O	O
since	O	O
resize	B-API	B-API
the	O	O
array	O	B-API
will	O	O
use	O	B-API
more	O	O
time	O	B-API
.	O	O

I	O	O
think	O	O
you	O	O
need	O	O
to	O	O
use	O	B-API
append	B-API	B-API
function	O	B-API
to	O	O
append	B-API	B-API
new	O	O
array	O	B-API
with	O	O
previous	O	O
array	O	B-API
,	O	O
asarray	B-API	O
function	O	B-API
converts	O	O
input	O	O
to	O	O
array	O	B-API
.	O	O

I	O	O
would	O	O
store	O	O
all	O	B-API
your	O	O
data	O	B-API
in	O	O
a	O	O
python	O	O
list	O	B-API
and	O	O
use	O	B-API
the	O	O
append	B-API	B-API
function	O	B-API
to	O	O
add	O	B-API
new	O	O
measurement	O	O
.	O	O

The	O	O
Series	O	B-API
must	O	O
also	O	O
have	O	O
a	O	O
`	O	O
name	O	B-API
`	O	O
to	O	O
be	O	O
used	O	O
with	O	O
`	O	O
join	B-API	B-API
`	O	O
,	O	O
which	O	O
gets	O	O
pulled	O	O
in	O	O
as	O	O
a	O	O
new	O	O
field	O	B-API
called	O	O
`	O	O
name	O	B-API
`	O	O
.	O	O

NumPy	O	O
by	O	O
itself	O	O
is	O	O
a	O	O
fairly	O	O
low-level	O	O
tool	O	O
,	O	O
and	O	O
will	O	O
be	O	O
very	O	O
much	O	O
similar	O	O
to	O	O
using	O	O
MATLAB	O	O
.	O	O
pandas	O	O
on	O	O
the	O	O
other	O	O
hand	O	O
provides	O	O
rich	O	O
time	O	B-API
series	O	O
functionality	O	O
,	O	O
data	O	B-API
alignment	O	O
,	O	O
NA-friendly	O	O
statistics	O	O
,	O	O
groupby	B-API	O
,	O	O
merge	O	B-API
and	O	O
join	B-API	B-API
methods	O	O
,	O	O
and	O	O
lots	O	O
of	O	O
other	O	O
conveniences	O	O
.	O	O

already	O	O
have	O	O
all	O	B-API
header	O	O
names	O	B-API
listed	O	O
then	O	O
you	O	O
can	O	O
use	O	B-API
"	O	O
join	B-API	B-API
"	O	O
and	O	O

Because	O	O
these	O	O
are	O	O
irregular	O	O
operations	O	O
,	O	O
I	O	O
can't	O	O
use	O	B-API
merge	B-API	B-API
/	O	O
join	B-API	B-API
.	O	O

It	O	O
should	O	O
be	O	O
a	O	O
bit	O	O
quicker	O	O
just	O	O
by	O	O
not	O	O
using	O	O
so	O	O
many	O	O
intermediary	O	O
bitstrings	O	O
-	O	O
it's	O	O
all	O	B-API
done	O	O
in	O	O
the	O	O
join	B-API	B-API
method	O	O
.	O	O

How	O	O
can	O	O
i	O	O
use	O	B-API
the	O	O
unique	B-API	B-API
(	O	O
a	O	O
,	O	O
rows	O	O
)	O	O
from	O	O
MATLab	O	O
at	O	B-API
python	O	O
?	O	O

If	O	O
you	O	O
convert	O	B-API
your	O	O
2D	O	O
coordinates	O	O
into	O	O
`	O	O
target_map	O	O
`	O	O
into	O	O
flat	O	O
indices	O	B-API
into	O	O
it	O	O
using	O	O
`	O	O
np.ravel_multi_index	B-API	B-API
`	O	O
,	O	O
you	O	O
can	O	O
use	O	B-API
`	O	O
np.unique	B-API	B-API
`	O	O
and	O	O
`	O	O
np.bincount	B-API	B-API
`	O	O
to	O	O
speed	O	O
things	O	O
up	O	O
quite	O	O
a	O	O
bit	O	O
:	O	O
#CODE	O	O

To	O	O
get	O	B-API
the	O	O
unobserved	O	O
values	O	B-API
filled	O	B-API
,	O	O
we'll	O	O
use	O	B-API
the	O	O
`	O	O
unstack	B-API	B-API
`	O	O
and	O	O
`	O	O
stack	B-API	B-API
`	O	O
methods	O	O
.	O	O

The	O	O
actual	O	O
RMS	O	O
would	O	O
be	O	O
`	O	O
norm	B-API	B-API
(	O	O
x	O	O
)	O	O
/	O	O
sqrt	B-API	B-API
(	O	O
x.size	O	B-API
)`	O	O
,	O	O
but	O	O
for	O	O
minimization	O	O
the	O	O
constant	O	O
multiplier	O	O
doesn't	O	O
make	O	O
any	O	B-API
difference	O	B-API
.	O	O

The	O	O
above	O	O
entire	O	O
expression	O	O
is	O	O
therefore	O	O
evaluating	O	O
to	O	O
an	O	O
array	O	B-API
of	O	O
truth	O	O
values	O	B-API
,	O	O
rather	O	O
than	O	O
a	O	O
single	O	O
`	O	O
True	O	O
`	O	O
/	O	O
`	O	O
False	O	O
`	O	O
.	O	O

For	O	O
the	O	O
multiprocessing	O	O
:	O	O
You	O	O
can	O	O
distribute	O	O
the	O	O
data	O	B-API
sets	O	O
across	O	O
cores	O	O
,	O	O
do	O	O
`	O	O
partial_fit	O	O
`	O	O
,	O	O
get	O	B-API
the	O	O
weight	O	O
vectors	O	O
,	O	O
average	O	B-API
them	O	O
,	O	O
distribute	O	O
them	O	O
to	O	O
the	O	O
estimators	O	O
,	O	O
do	O	O
partial	O	O
fit	O	O
again	O	O
.	O	O

the	O	O
size	O	B-API
of	O	O
Y	O	O
is	O	O
100e6	O	O
x	O	O
1	O	O

Put	O	O
I	O	O
think	O	O
that	O	O
following	O	O
this	O	O
route	O	O
would	O	O
lead	O	O
to	O	O
an	O	O
inefficient	O	O
solution	O	O
.	O	O

Your	O	O
example	O	O
come	O	O
at	O	B-API
a	O	O
good	O	O
time	O	B-API
for	O	O
me	O	O
,	O	O
so	O	O
I	O	O
now	O	O
have	O	O
something	O	O
concrete	O	O
to	O	O
train	O	O
with	O	O
.	O	O

One	O	O
thing	O	O
I	O	O
find	O	B-API
very	O	O
confortable	O	O
with	O	O
Numpy	O	O
is	O	O
the	O	O
vectorization	O	O
of	O	O
operations	O	O
with	O	O
arrays	O	O
(	O	O
ie	O	O
.	O	O
the	O	O
absence	O	O
of	O	O
any	O	B-API
explicit	O	O
looping	O	O
)	O	O
,	O	O
and	O	O
the	O	O
implicit	O	O
element-by-element	O	O
behavior	O	O
of	O	O
operations	O	O
.	O	O

I	O	O
suggest	O	O
to	O	O
set	O	B-API
it	O	O
to	O	O
some	O	O
reasonable	O	O
upper	O	B-API
limit	O	O
,	O	O
though	O	O
.	O	O

Gonna	O	O
try	O	O
to	O	O
find	O	B-API
another	O	O
solution	O	O
.	O	O

Is	O	O
it	O	O
possible	O	O
to	O	O
construct	O	O
a	O	O
`	O	O
numpy	O	O
`	O	O
matrix	O	B-API
from	O	O
a	O	O
function	O	B-API
?	O	O

I	O	O
have	O	O
2D	O	O
numpy	O	O
array	O	B-API
,	O	O
with	O	O
example	O	O
shape	O	B-API
:	O	O
#CODE	O	O

`	O	O
grid	O	B-API
[	O	O
0	O	O
]`	O	O
can	O	O
be	O	O
used	O	O
as	O	O
a	O	O
proxy	O	O
for	O	O
the	O	O
index	O	B-API
`	O	O
i	O	O
`	O	O
,	O	O
and	O	O

Thank	O	O
you	O	O
Martijn	O	O
:)	O	O
-	O	O
your	O	O
are	O	O
BIG	O	O
help	O	O
,	O	O
and	O	O
just	O	O
one	O	O
thing	O	O
confuses	O	O
me	O	O
,	O	O
how	O	O
do	O	O
I	O	O
tell	O	O
python	O	O
to	O	O
read	O	O
all	O	B-API
CDR	O	O
records	O	O
if	O	O
record	O	B-API
is	O	O
907	O	O
bytes	O	B-API
long	O	O
.	O	O

I	O	O
want	O	O
to	O	O
get	O	B-API
the	O	O
elements	O	O
of	O	O
a	O	O
`	O	O
numpy	O	O
`	O	O
array	O	B-API
using	O	O
an	O	O
index	O	B-API
array	O	B-API
like	O	O
so	O	O
#CODE	O	O

I	O	O
can	O	O
weight	O	O
them	O	O
how	O	O
I	O	O
want	O	O
to	O	O
as	O	O
long	O	O
as	O	O
sum	O	B-API
of	O	O
their	O	O
weights	O	O
adds	O	O
to	O	O
1	O	O
.	O	O

I	O	O
wanted	O	O
to	O	O
try	O	O
to	O	O
duplicate	O	O
those	O	O
performance	O	O
gains	O	O
when	O	O
solving	O	O
the	O	O
distance	O	O
between	O	B-API
two	O	O
equal	O	B-API
sized	O	O
arrays	O	O
.	O	O

Even	O	O
if	O	O
it	O	O
worked	O	O
,	O	O
I	O	O
would	O	O
not	O	O
expect	O	O
any	O	B-API
speed-up	O	O
from	O	O
this	O	O
compared	O	O
to	O	O
an	O	O
ordinary	O	O
loop	O	O
,	O	O
since	O	O
it	O	O
needs	O	O
to	O	O
call	O	O
a	O	O
Python	O	O
function	O	B-API
for	O	O
every	O	O
entry	O	O
.	O	O

@USER	O	O
,	O	O
you're	O	O
right	O	O
,	O	O
if	O	O
you	O	O
have	O	O
to	O	O
convert	O	B-API
everything	O	O
to	O	O
ndarrays	O	O
it's	O	O
often	O	O
not	O	O
worth	O	O
it	O	O
.	O	O

An	O	O
example	O	O
implementation	O	O
without	O	O
recalculating	O	O
the	O	O
distance	O	O
array	O	B-API
would	O	O
be	O	O
this	O	O
:	O	O
#CODE	O	O

I	O	O
need	O	O
to	O	O
return	O	O
all	O	B-API
of	O	O
the	O	O
points	O	O
within	O	O
a	O	O
distance	O	O
of	O	O
X	O	O
units	O	B-API
from	O	O
every	O	O
point	O	O
.	O	O

EDIT	O	O
:	O	O
Actually	O	O
renaming	O	O
my	O	O
package	O	O
does	O	O
not	O	O
fix	O	B-API
it	O	O
.	O	O

2	O	O
)	O	O
look	O	O
at	O	B-API
the	O	O
lengths	O	O
distance	O	O
(	O	O
point	O	O
,	O	O
centre	O	O
,	O	O
metric=	O	O
...	O	O
)	O	O
of	O	O
all	O	B-API
the	O	O
rays	O	O
.	O	O

Sorry	O	O
,	O	O
all	O	B-API
are	O	O
positive	O	O
values	O	B-API
greater	O	B-API
than	O	O
0	O	O
.	O	O

After	O	O
that	O	O
I	O	O
convert	O	B-API
the	O	O
image	O	B-API
to	O	O
BGR	O	O
model	O	O
:	O	O
#CODE	O	O

How	O	O
do	O	O
I	O	O
standardize	O	O
a	O	O
matrix	O	B-API
?	O	O

Speed	O	O
can	O	O
probably	O	O
be	O	O
increased	O	O
by	O	O
ensuring	O	O
that	O	O
the	O	O
record	O	B-API
array	O	B-API
you	O	O
pass	O	O
to	O	O
Cython	O	O
is	O	O
contiguous	O	O
.	O	O

fid	O	O
is	O	O
the	O	O
file	O	O
currently	O	O
being	O	O
looked	O	O
at	O	B-API

I'm	O	O
guessing	O	O
it's	O	O
opening	O	O
TWO	O	O
filehandles	O	O
per	O	O
iteration	O	O
,	O	O
just	O	O
based	O	O
on	O	O
the	O	O
498	O	O
(	O	O
a	O	O
bit	O	O
less	O	B-API
than	O	O
half	O	O
1024	O	O
,	O	O
and	O	O
Python	O	O
would	O	O
have	O	O
some	O	O
files	O	O
open	O	B-API
itself	O	O
(	O	O
maybe	O	O
25-odd	O	O
?	O	O
)	O	O
.	O	O

The	O	O
idea	O	O
is	O	O
to	O	O
count	O	B-API
the	O	O
number	O	O
of	O	O
occurrences	O	O
of	O	O
each	O	O
transition	O	O
,	O	O
and	O	O
use	O	B-API
the	O	O
counts	O	O
in	O	O
a	O	O
vectorized	O	O
update	O	B-API
of	O	O
the	O	O
matrix	O	B-API
.	O	O

I	O	O
kept	O	O
them	O	O
in	O	O
to	O	O
distinguish	O	O
them	O	O
from	O	O
the	O	O
`	O	O
math	O	B-API
`	O	O
ones	O	B-API
,	O	O
which	O	O
won't	O	O
work	O	O
for	O	O
this	O	O
approach	O	O
.	O	O

Powers	O	O
of	O	O
two	O	O
are	O	O
simple	O	O
to	O	O
compute	O	O
,	O	O
but	O	O
mixed	O	O
radix	O	O
sizes	O	O
can	O	O
be	O	O
faster	O	O
and	O	O
use	O	B-API
less	O	B-API
memory	O	O
.	O	O

The	O	O
stars	O	O
/	O	O
dots	O	O
are	O	O
the	O	O
`	O	O
X	O	O
`	O	O
and	O	O
`	O	O
Y	O	O
`	O	O
plotted	O	O
with	O	O
two	O	O
modifications	O	O
,	O	O
I	O	O
removed	O	O
the	O	O
first	O	B-API
position	O	O
and	O	O
added	O	O
a	O	O
false	O	O
one	O	O
to	O	O
make	O	O
this	O	O
a	O	O
full	O	B-API
example	O	O
of	O	O
the	O	O
sought	O	O
algorithm	O	O
.	O	O

Please	O	O
look	O	O
at	O	B-API
my	O	O
EDIT	O	O
2	O	O
,	O	O
where	O	B-API
I	O	O
described	O	O
my	O	O
problem	O	O
with	O	O
input	O	O
data	O	B-API
...	O	O
and	O	O
why	O	O
I	O	O
can't	O	O
get	O	B-API
matrix	O	B-API
..	O	O

pyqt	O	O
:	O	O
Convert	O	O
numpy	O	O
array	O	B-API
to	O	O
QImage	O	O

To	O	O
find	O	B-API
the	O	O
difference	O	B-API
between	O	B-API
your	O	O
data	O	B-API
and	O	O
a	O	O
point	O	O
,	O	O
you'd	O	O
just	O	O
do	O	O
`	O	O
data	O	B-API
-	O	O
point	O	O
`	O	O
.	O	O

Unfortunately	O	O
when	O	O
numpy	O	O
reads	O	O
the	O	O
19-digit	O	O
number	O	O
as	O	O
a	O	O
floating	O	O
point	O	O
number	O	O
,	O	O
there	O	O
is	O	O
not	O	O
enough	O	O
precision	O	O
to	O	O
get	O	B-API
all	O	B-API
the	O	O
significant	O	O
digits	O	O
,	O	O
so	O	O
there	O	O
is	O	O
a	O	O
rounding	O	O
error	O	O
.	O	O

The	O	O
exceptions	O	O
are	O	O
very	O	O
rare	O	O
,	O	O
if	O	O
any	O	B-API
.	O	O

I	O	O
can't	O	O
reproduce	O	O
your	O	O
problem	O	O
on	O	O
Linux	O	O
using	O	O
the	O	O
same	O	O
versions	O	O
of	O	O
numpy	O	O
and	O	O
python	O	O
and	O	O
a	O	O
quickly	O	O
made	O	O
test	O	B-API
file	O	O
(	O	O
with	O	O
dos	O	O
line	O	O
endings	O	O
,	O	O
even	O	O
)	O	O
...	O	O

I	O	O
imagine	O	O
I	O	O
would	O	O
have	O	O
to	O	O
use	O	B-API
the	O	O
uncompiled	O	O
source	O	B-API
provided	O	O
from	O	O
each	O	O
of	O	O
these	O	O
three	O	O
projects	O	O
.	O	O

However	O	O
,	O	O
I	O	O
am	O	O
checking	O	O
optimization	O	O
routine	O	O
result	O	O
,	O	O
and	O	O
sometimes	O	O
power	O	B-API
is	O	O
negative	O	B-API
,	O	O
sometimes	O	O
it	O	O
is	O	O
positive	O	O
.	O	O

What	O	O
about	O	O
array	O	B-API
of	O	O
arrays	O	O
that	O	O
contains	O	B-API
some	O	O
structures	O	O
?	O	O

The	O	O
y	O	O
data	O	B-API
takes	O	O
the	O	O
shape	O	B-API
of	O	O
the	O	O
triangle	O	O
wave	O	O
below	O	O
.	O	O

There	O	O
are	O	O
some	O	O
algorithm	O	O
to	O	O
calculate	O	O
faster	O	O
the	O	O
results	O	O
for	O	O
low	O	O
valued	O	O
matrix	O	B-API
,	O	O
but	O	O
just	O	O
google	O	O
for	O	O
this	O	O
.	O	O

Those	O	O
are	O	O
not	O	O
random	O	B-API
replacements	O	O
by	O	O
any	O	B-API
means	O	O
.	O	O

I	O	O
would	O	O
suggest	O	O
to	O	O
make	O	O
the	O	O
library	O	B-API
use	O	B-API
an	O	O
(	O	O
NumPy-	O	O
)	O	O
array	O	B-API
you	O	O
allocate	O	O
in	O	O
Python	O	O
and	O	O
pass	O	O
on	O	O
to	O	O
the	O	O
library	O	B-API
.	O	O

For	O	O
the	O	O
simple	O	O
case	O	O
of	O	O
"	O	O
remove	O	B-API
column	O	O
3	O	O
"	O	O
,	O	O
`	O	O
delete	O	B-API
`	O	O
makes	O	O
more	O	O
sense	O	O
;	O	O
for	O	O
a	O	O
more	O	O
complicated	O	O
case	O	O
,	O	O
`	O	O
take	O	B-API
`	O	O
probably	O	O
makes	O	O
more	O	O
sense	O	O
.	O	O

I	O	O
have	O	O
an	O	O
array	O	B-API
of	O	O
points	O	O
in	O	O
numpy	O	O
:	O	O
#CODE	O	O

I	O	O
have	O	O
done	O	O
7	O	O
of	O	O
the	O	O
problems	O	O
on	O	O
Project	O	O
Euler	O	O
(	O	O
nothing	O	O
to	O	O
brag	O	O
about	O	O
,	O	O
but	O	O
it	O	O
might	O	O
give	O	O
you	O	O
a	O	O
better	O	O
idea	O	O
of	O	O
where	O	B-API
I	O	O
stand	O	O
in	O	O
skills	O	O
)	O	O
.	O	O

How	O	O
do	O	O
I	O	O
find	O	B-API
the	O	O
length	O	O
(	O	O
or	O	O
dimensions	O	O
,	O	O
size	O	B-API
)	O	O
of	O	O
a	O	O
numpy	O	O
matrix	O	B-API
in	O	O
python	O	O
?	O	O

It's	O	O
longer	O	O
than	O	O
the	O	O
other	O	O
answer	O	O
but	O	O
is	O	O
more	O	O
generic	O	B-API
(	O	O
can	O	O
be	O	O
used	O	O
with	O	O
values	O	B-API
that	O	O
are	O	O
not	O	O
strings	O	O
)	O	O
.	O	O

I	O	O
coded	O	O
my	O	O
own	O	O
routine	O	O
with	O	O
Python	O	O
/	O	O
Numpy	O	O
,	O	O
and	O	O
it	O	O
is	O	O
giving	O	O
me	O	O
a	O	O
little	O	O
bit	O	O
different	O	O
results	O	O
from	O	O
the	O	O
MATLAB	O	O
code	O	O
somebody	O	O
else	O	O
did	O	O
,	O	O
and	O	O
I	O	O
am	O	O
having	O	O
hard	O	O
time	O	B-API
finding	O	O
out	O	O
where	O	B-API
it	O	O
is	O	O
coming	O	O
from	O	O
because	O	O
of	O	O
different	O	O
random	O	B-API
draws	O	O
.	O	O

How	O	O
can	O	O
1,000,000	O	O
4-byte	O	O
ints	O	O
be	O	O
compressed	O	B-API
any	O	B-API
smaller	O	O
?	O	O

If	O	O
this	O	O
number	O	O
is	O	O
less	O	B-API
than	O	O
a	O	O
third	O	O
of	O	O
the	O	O
total	O	O
I'll	O	O
use	O	B-API
my	O	O
answer	O	O
above	O	O
.	O	O

I	O	O
have	O	O
done	O	O
7	O	O
of	O	O
the	O	O
problems	O	O
on	O	O
Project	O	O
Euler	O	O
(	O	O
nothing	O	O
to	O	O
brag	O	O
about	O	O
,	O	O
but	O	O
it	O	O
might	O	O
give	O	O
you	O	O
a	O	O
better	O	O
idea	O	O
of	O	O
where	O	B-API
I	O	O
stand	O	O
in	O	O
skills	O	O
)	O	O
.	O	O

Apologies	O	O
if	O	O
this	O	O
is	O	O
a	O	O
wrongly	O	O
framed	O	O
question	O	O
or	O	O
if	O	O
this	O	O
question	O	O
was	O	O
already	O	O
asked	O	O
earlier	O	O
(	O	O
I	O	O
couldn't	O	O
find	O	B-API
it	O	O
)	O	O

If	O	O
you	O	O
can	O	O
choose	O	B-API
,	O	O
I	O	O
strongly	O	O
recommend	O	O
pandas	O	O
:	O	O
it	O	O
has	O	O
"	O	O
column	O	O
indexing	O	O
"	O	O
built-in	O	O
plus	O	O
a	O	O
lot	O	O
of	O	O
other	O	O
features	O	O
.	O	O

But	O	O
this	O	O
will	O	O
iterate	O	O
through	O	O
the	O	O
entire	O	O
array	O	B-API
and	O	O
allocate	O	O
a	O	O
new	O	O
array	O	B-API
in	O	O
memory	O	O
containing	O	O
the	O	O
all	O	B-API
the	O	O
results	O	O
,	O	O
and	O	O
only	O	O
then	O	O
check	O	O
to	O	O
see	O	O
if	O	O
it	O	O
is	O	O
empty	O	B-API
.	O	O

Since	O	O
some	O	O
askers	O	O
and	O	O
some	O	O
answers	O	O
both	O	O
avoid	O	O
that	O	O
constraint	O	O
,	O	O
I	O	O
encourage	O	O
anyone	O	O
who's	O	O
here	O	O
and	O	O
doesn't	O	O
mind	O	O
having	O	O
PIL	O	O
to	O	O
look	O	O
below	O	O
,	O	O
and	O	O
any	O	B-API
non-PIL	O	O
answers	O	O
(	O	O
new	O	O
or	O	O
old	O	O
)	O	O
to	O	O
mention	O	O
that	O	O
they're	O	O
a	O	O
PIL-is-used	O	O
type	O	O
of	O	O
answer	O	O
,	O	O
to	O	O
distinguish	O	O
themselves	O	O
from	O	O
answers	O	O
meeting	O	O
the	O	O
original	O	O
constraint	O	O
.	O	O

As	O	O
I	O	O
understand	O	O
your	O	O
question	O	O
,	O	O
you	O	O
have	O	O
a	O	O
2D	O	O
array	O	B-API
of	O	O
"	O	O
z	O	O
"	O	O
values	O	B-API
that	O	O
ranges	O	O
from	O	O
some	O	O
xmin	O	O
to	O	O
xmax	O	O
,	O	O
and	O	O
ymin	O	O
to	O	O
ymax	O	O
in	O	O
each	O	O
direction	O	O
.	O	O

The	O	O
covariance	O	O
matrix	O	B-API
of	O	O
a	O	O
dataset	O	O
A	O	O
is	O	O
:	O	O
1	O	O
/(	O	O
N-1	O	O
)	O	O
*	O	O
AA^T	O	O

I	O	O
have	O	O
a	O	O
large	O	O
(	O	O
500k	O	O
by	O	O
500k	O	O
)	O	O
,	O	O
sparse	O	O
matrix	O	B-API
.	O	O

I	O	O
can't	O	O
comment	O	O
on	O	O
a	O	O
numpy	O	O
array	O	B-API
as	O	O
I	O	O
haven't	O	O
used	O	O
one	O	O
before	O	O
,	O	O
but	O	O
for	O	O
using	O	O
a	O	O
list	O	B-API
of	O	O
lists	O	O
Python	O	O
already	O	O
has	O	O
built	O	O
in	O	O
support	O	O
.	O	O

If	O	O
`	O	O
finer_fxy	O	O
`	O	O
is	O	O
stored	O	O
in	O	O
the	O	O
probably-default	O	O
`	O	O
float64	O	O
`	O	O
s	O	O
,	O	O
this	O	O
would	O	O
take	O	B-API
about	O	O
64	O	O
GiB	O	O
of	O	O
memory	O	O
;	O	O
not	O	O
surprising	O	O
that	O	O
you're	O	O
running	O	O
out	O	O
.	O	O

Sebastian's	O	O
solution	O	O
for	O	O
a	O	O
way	O	O
around	O	B-API
the	O	O
integer-values-only	O	O
restriction	O	O
and	O	O
big-values	O	O
problem	O	O
.	O	O

This	O	O
allows	O	O
the	O	O
column	O	O
to	O	O
hold	O	B-API
float	O	O
values	O	B-API
at	O	B-API
first	O	B-API
,	O	O
and	O	O
strings	O	O
later	O	O
.	O	O

Efficient	O	O
slicing	O	O
of	O	O
matrices	O	O
using	O	O
matrix	O	B-API
multiplication	O	O
,	O	O
with	O	O
Python	O	O
,	O	O
NumPy	O	O
,	O	O
SciPy	O	O

Is	O	O
there	O	O
a	O	O
more	O	O
compact	O	O
way	O	O
to	O	O
operate	O	O
on	O	O
array	O	B-API
elements	O	O
,	O	O
without	O	O
having	O	O
to	O	O
use	O	B-API
the	O	O
standard	O	O
for	O	O
loop	O	O
.?	O	O

Please	O	O
look	O	O
at	O	B-API
this	O	O
answer	O	O
:	O	O
#URL	O	O

When	O	O
I	O	O
tried	O	O
this	O	O
,	O	O
I	O	O
got	O	O
sort	O	B-API
of	O	O
similar	O	O
shaped	O	O
"	O	O
tiles	O	O
"	O	O
of	O	O
different	O	O
colors	O	B-API
rather	O	O
than	O	O
3	O	O
Gaussian	O	O
humps	O	O
.	O	O

I	O	O
created	O	O
the	O	O
first	O	B-API
array	O	B-API
like	O	O
this	O	O
:	O	O

(	O	O
Note	O	O
that	O	O
I	O	O
can't	O	O
imagine	O	O
any	O	B-API
reason	O	O
why	O	O
this	O	O
should	O	O
be	O	O
necessary	O	O
.	O	O
)	O	O

SOLUTION	O	O
:	O	O
i	O	O
have	O	O
some	O	O
scattered	O	O
points	O	O
(	O	O
i	O	O
don't	O	O
know	O	O
how	O	O
many	O	O
)	O	O
and	O	O
i	O	O
want	O	O
to	O	O
reduce	O	B-API
it	O	O
to	O	O
a	O	O
8	O	O
meaning	O	O
point	O	O
.	O	O
one	O	O
of	O	O
the	O	O
technique	O	O
i	O	O
can	O	O
use	O	B-API
is	O	O
to	O	O
clusterize	O	O
them	O	O
with	O	O
some	O	O
cluster	O	O
algorithms	O	O
.	O	O

that	O	O
blas	O	O
is	O	O
reference	O	O
blas	O	O
from	O	O
netlib	O	O
-	O	O
the	O	O
slowest	O	O
blas	O	O
around	O	B-API
.	O	O
install	O	O
atlas	O	O
or	O	O
mkl	O	O
instead	O	O
.	O	O

EDIT	O	O
:	O	O
Answer	O	O
updated	O	O
for	O	O
a	O	O
2D	O	O
array	O	B-API
.	O	O

But	O	O
you	O	O
lose	O	O
a	O	O
lot	O	O
of	O	O
NumPy	O	O
power	O	B-API
that	O	O
way	O	O
.	O	O

Because	O	O
I	O	O
view	O	B-API
doesn't	O	O
really	O	O
have	O	O
to	O	O
do	O	O
with	O	O
filtering	O	O
,	O	O
but	O	O
rather	O	O
with	O	O
different	O	O
representation	O	O
of	O	O
the	O	O
same	O	O
data	O	B-API
.	O	O

@USER	O	O
,	O	O
not	O	O
sure	O	O
what	O	O
you	O	O
mean	O	B-API
by	O	O
"	O	O
changing	O	O
original	O	O
values	O	B-API
"	O	O
.	O	O

this	O	O
could	O	O
also	O	O
be	O	O
achieved	O	O
elegantly	O	O
with	O	O
numpy's	O	O
`	O	O
where	O	B-API
`	O	O
function	O	B-API

I	O	O
need	O	O
to	O	O
specify	O	O
datatypes	O	O
for	O	O
all	O	B-API
numerical	O	O
types	O	O
since	O	O
I	O	O
care	O	O
about	O	O
int	O	O
8/	O	O
16	O	O
/	O	O
32	O	O
,	O	O
etc	O	O
,	O	O
but	O	O
I	O	O
would	O	O
like	O	O
to	O	O
benefit	O	O
from	O	O
the	O	O
auto	O	O
string	O	O
length	O	O
detection	O	O
that	O	O
works	O	O
if	O	O
I	O	O
don't	O	O
specify	O	O
datatypes	O	O
.	O	O

In	O	O
the	O	O
following	O	O
trivial	O	O
function	O	B-API
,	O	O
I	O	O
have	O	O
declared	O	O
the	O	O
numpy	O	O
array	O	B-API
argument	O	O
`	O	O
arr	O	O
`	O	O
using	O	O
the	O	O
buffer	O	O
syntax	O	O
.	O	O

I	O	O
remember	O	O
that	O	O
there	O	O
was	O	O
a	O	O
smart	O	O
trick	O	O
about	O	O
turning	O	O
on	O	O
and	O	O
off	O	O
the	O	O
right	O	O
intersections	O	O
of	O	O
rows	O	O
and	O	O
columns	O	O
to	O	O
turn	O	O
off	O	O
one-by-one	O	O
all	O	B-API
the	O	O
lightbulbs	O	O
,	O	O
but	O	O
it	O	O
wont	O	O
come	O	O
back	O	B-API
to	O	O
my	O	O
mind	O	O
...	O	O

However	O	O
this	O	O
code	O	O
is	O	O
to	O	O
slow	O	B-API
in	O	O
the	O	O
current	O	O
version	O	O
,	O	O
and	O	O
I	O	O
am	O	O
wondering	O	O
wheater	O	O
there	O	O
is	O	O
a	O	O
faster	O	O
solution	O	O
.	O	O
thanks	O	O
!	O	O

This	O	O
would	O	O
probably	O	O
be	O	O
the	O	O
most	O	O
efficient	O	O
way	O	O
to	O	O
access	O	O
a	O	O
numpy	O	O
array	O	B-API
stored	O	O
on	O	O
disk	O	O
.	O	O

hmmmmm	O	O
,	O	O
probably	O	O
it	O	O
will	O	O
help	O	O
some	O	O
others	O	O
to	O	O
sort	O	B-API
dictionarys	O	O
or	O	O
to	O	O
prevent	O	O
from	O	O
using	O	O
commands	O	O
like	O	O
sorted	O	O
=	O	O
sorted	O	O
(	O	O
...	O	O
)	O	O
.	O	O

The	O	O
ticket	O	O
simply	O	O
spoke	O	O
of	O	O
random	O	B-API
number	O	O
seeding	O	O
with	O	O
64-bit	O	O
,	O	O
perhaps	O	O
its	O	O
referring	O	O
to	O	O
a	O	O
different	O	O
random	O	B-API
number	O	O
generator	O	O
.	O	O

Not	O	O
really	O	O
elegant	O	O
at	O	B-API
all	O	B-API
but	O	O
you	O	O
can	O	O
get	O	B-API
close	O	B-API
to	O	O
what	O	O
you	O	O
want	O	O
using	O	O
a	O	O
tuple	O	O
to	O	O
store	O	O
pointers	O	O
to	O	O
the	O	O
arrays	O	O
.	O	O

For	O	O
example	O	O
I	O	O
am	O	O
looking	O	O
for	O	O
4.2	O	O
but	O	O
I	O	O
know	O	O
in	O	O
the	O	O
array	O	B-API
there	O	O
is	O	O
no	O	O
4.2	O	O
but	O	O
I	O	O
want	O	O
to	O	O
return	O	O
the	O	O
index	O	B-API
of	O	O
the	O	O
value	O	O
4.1	O	O
instead	O	O
of	O	O
4.4	O	O
.	O	O

Print	O	O
'	O	O
Length	O	O
of	O	O
together	O	O
'	O	O
goes	O	O
just	O	O
before	O	O
the	O	O
matrix	O	B-API
line	O	O
.	O	O

solve	O	B-API
a	O	O
nonlinear	O	O
equation	O	O
at	O	B-API
several	O	O
intermediate	O	O
points	O	O
of	O	O
a	O	O
calculation	O	O
,	O	O
not	O	O
just	O	O
as	O	O
the	O	O
final	O	O
result	O	O
.	O	O

Find	O	O
where	O	B-API
they're	O	O
located	O	O
at	O	B-API
(	O	O
assumes	O	O
the	O	O
data	O	B-API
is	O	O
sorted	O	O
!!	O	O
):	O	O
#CODE	O	O

You	O	O
need	O	O
Python	O	O
to	O	O
keep	O	O
track	O	O
of	O	O
your	O	O
vector	O	O
so	O	O
that	O	O
it	O	O
can	O	O
be	O	O
deleted	O	O
*	O	O
after	O	O
*	O	O
the	O	O
numpy	O	O
array	O	B-API
.	O	O

I	O	O
find	O	B-API
that	O	O
I	O	O
have	O	O
to	O	O
first	O	B-API
build	O	O
a	O	O
list	O	B-API
and	O	O
then	O	O
cast	O	O
it	O	O
(	O	O
using	O	O
"	O	O
array	O	B-API
")	O	O
to	O	O
an	O	O
array	O	B-API
.	O	O

I	O	O
have	O	O
an	O	O
numpy	O	O
one	O	O
dimensional	O	O
array	O	B-API
c	O	O
that	O	O
is	O	O
supposed	O	O
to	O	O
be	O	O
filled	O	B-API
with	O	O
the	O	O
contents	O	O
of	O	O

but	O	O
the	O	O
issue	O	O
now	O	O
,	O	O
when	O	O
I	O	O
am	O	O
trying	O	O
to	O	O
save	O	B-API
the	O	O
name	O	B-API
of	O	O
the	O	O
file	O	O
as	O	O
well	O	O
in	O	O
the	O	O
csv	O	O
file	O	O
like	O	O
this	O	O
:	O	O
#CODE	O	O

After	O	O
you	O	O
do	O	O
this	O	O
no	O	O
matter	O	O
where	O	B-API
the	O	O
template	O	O
object	O	O
is	O	O
in	O	O
a	O	O
calculation	O	O
.	O	O

So	O	O
the	O	O
easiest	O	O
thing	O	O
to	O	O
do	O	O
would	O	O
be	O	O
to	O	O
take	O	B-API
a	O	O
sample	O	B-API
of	O	O
say	O	O
,	O	O
1000	O	O
points	O	O
,	O	O
from	O	O
your	O	O
data	O	B-API
:	O	O
#CODE	O	O

Your	O	O
array	O	B-API
consists	O	O
of	O	O
:	O	O
#CODE	O	O

The	O	O
final	O	O
DF	O	O
should	O	O
have	O	O
as	O	O
many	O	O
columns	O	O
as	O	O
all	O	B-API
the	O	O
df	O	O
columns	O	O
added	O	O
together	O	O
,	O	O
so	O	O
it	O	O
grow	O	B-API
additively	O	O
and	O	O
not	O	O
be	O	O
combinatorial	O	O
.	O	O

I'm	O	O
sorting	O	O
the	O	O
cells	O	O
of	O	O
the	O	O
matrix	O	B-API
by	O	O
the	O	O
float	O	O
value	O	O
,	O	O
producing	O	O
a	O	O
list	O	B-API
of	O	O
`	O	O
(	O	O
row	O	O
,	O	O
col	O	O
,	O	O
value	O	O
)`	O	O
tuples	O	O
.	O	O

Is	O	O
it	O	O
essential	O	O
that	O	O
you	O	O
need	O	O
a	O	O
numpy	O	O
array	O	B-API
?	O	O

Mh	O	O
.	O	O
but	O	O
look	O	O
at	O	B-API
this	O	O
:	O	O

All	O	O
variables	O	O
are	O	O
dependent	O	O
on	O	O
each	O	O
other	O	O
and	O	O
I	O	O
am	O	O
only	O	O
looking	O	O
for	O	O
local	O	O
minima	O	O
from	O	O
the	O	O
initial	O	O
guess	O	O
.	O	O

The	O	O
basic	O	O
idea	O	O
is	O	O
to	O	O
simply	O	O
run	O	O
all	O	B-API
the	O	O
usual	O	O
steps	O	O
of	O	O
a	O	O
root	O	O
finder	O	O
in	O	O
parallel	O	O
on	O	O
a	O	O
vector	O	O
of	O	O
variables	O	O
,	O	O
using	O	O
a	O	O
function	O	B-API
that	O	O
can	O	O
be	O	O
evaluated	O	O
on	O	O
a	O	O
vector	O	O
of	O	O
variables	O	O
and	O	O
equivalent	O	O
vector	O	O
(	O	O
s	O	O
)	O	O
of	O	O
parameters	O	O
that	O	O
define	O	O
the	O	O
individual	O	O
component	O	O
functions	O	O
.	O	O

Hence	O	O
,	O	O
with	O	O
NetworkX	O	O
,	O	O
you	O	O
can	O	O
put	O	B-API
in	O	O
an	O	O
adjacency	O	O
matrix	O	B-API
and	O	O
find	O	B-API
out	O	O
which	O	O
authors	O	O
are	O	O
clustered	O	O
together	O	O
.	O	O

The	O	O
issue	O	O
your	O	O
having	O	O
more	O	O
likely	O	O
is	O	O
a	O	O
python	O	O
mmap	O	O
issue	O	O
,	O	O
since	O	O
python	O	O
mmaps	O	O
handle	O	O
all	O	B-API
the	O	O
memory	O	O
mapping	O	O
and	O	O
file	O	O
closing	O	O
for	O	O
numpy	O	O
memmaps	O	O
.	O	O

So	O	O
far	O	O
,	O	O
I'm	O	O
sticking	O	O
with	O	O
C++	O	O
-	O	O
on	O	O
my	O	O
tests	O	O
,	O	O
at	O	B-API
least	O	O
2	O	O
orders	O	O
of	O	O
magnitude	O	O
faster	O	O
!	O	O

Sorting	O	O
ends	O	O
up	O	O
being	O	O
the	O	O
slowest	O	O
step	O	B-API
but	O	O
it's	O	O
still	O	O
faster	O	O
if	O	O
m	O	O
is	O	O
large	O	O
because	O	O
the	O	O
n*log	O	O
(	O	O
n	O	O
)	O	O
sort	O	B-API
is	O	O
faster	O	O
than	O	O
(	O	O
n*m	O	O
)	O	O
.	O	O

Basically	O	O
,	O	O
I	O	O
am	O	O
getting	O	O
a	O	O
memory	O	O
error	O	O
in	O	O
python	O	O
when	O	O
trying	O	O
to	O	O
perform	O	O
an	O	O
algebraic	O	O
operation	O	O
on	O	O
a	O	O
numpy	O	O
matrix	O	B-API
.	O	O

Surely	O	O
there	O	O
must	O	O
be	O	O
a	O	O
way	O	O
to	O	O
populate	O	O
a	O	O
boost	O	O
::	O	O
python	O	O
::	O	O
numeric	O	O
::	O	O
array	O	B-API
with	O	O
data	O	B-API
from	O	O
a	O	O
simple	O	O
std	O	B-API
::	O	O
vector	O	O
without	O	O
having	O	O
to	O	O
get	O	B-API
some	O	O
3rd	O	O
party	O	O
library	O	B-API
.	O	O

Here	O	O
again	O	O
a	O	O
if	O	O
statement	O	O
could	O	O
do	O	O
,	O	O
but	O	O
I	O	O
am	O	O
wondering	O	O
if	O	O
there	O	O
is	O	O
a	O	O
workarouns	O	O
and	O	O
a	O	O
Python	O	O
library	O	B-API
where	O	B-API
negative	O	B-API
exposant	O	O
is	O	O
allowed	O	O
.	O	O

The	O	O
key	O	O
point	O	O
here	O	O
is	O	O
that	O	O
Tabular	O	O
and	O	O
NumPy	O	O
set	O	B-API
certain	O	O
standards	O	O
for	O	O
what	O	O
counts	O	O
as	O	O
"	O	O
fast	O	O
"	O	O
or	O	O
"	O	O
slow	O	B-API
"	O	O
--	O	O
and	O	O
then	O	O
,	O	O
force	O	O
you	O	O
to	O	O
be	O	O
explicit	O	O
about	O	O
operations	O	O
that	O	O
are	O	O
going	O	O
to	O	O
be	O	O
slow	O	B-API
.	O	O

Asume	O	O
that	O	O
your	O	O
numpy	O	O
module	O	O
is	O	O
located	O	O
at	O	B-API
/	O	O
Users	O	O
/	O	O
Me	O	O
/	O	O
python	O	O
/	O	O
modules	O	O
directory	O	O
.	O	O

I	O	O
am	O	O
not	O	O
responsible	O	O
from	O	O
any	O	B-API
brain	O	O
damage	O	O
resulting	O	O
from	O	O
attempting	O	O
to	O	O
understand	O	O
this	O	O
code	O	O
.	O	O

There	O	O
a	O	O
plenty	O	O
of	O	O
places	O	O
where	O	B-API
you're	O	O
inadvertently	O	O
creating	O	O
additional	O	O
temporary	O	O
arrays	O	O
,	O	O
but	O	O
they're	O	O
mostly	O	O
irrelevant	O	O
,	O	O
as	O	O
they're	O	O
overwhelmed	O	O
by	O	O
what	O	O
goes	O	O
on	O	O
during	O	O
the	O	O
call	O	O
to	O	O
`	O	O
select	O	B-API
`	O	O
.	O	O

The	O	O
fact	O	O
that	O	O
you	O	O
are	O	O
using	O	O
`	O	O
object	O	O
`	O	O
arrays	O	O
(	O	O
not	O	O
very	O	O
common	O	O
and	O	O
not	O	O
very	O	O
memory-efficient	O	O
)	O	O
presents	O	O
a	O	O
particular	O	O
problem	O	O
when	O	O
trying	O	O
to	O	O
determine	O	O
the	O	O
index	O	B-API
of	O	O
non-None	O	O
array	O	B-API
items	O	O
.	O	O

where	O	B-API
things	O	O
improve	O	O
as	O	O
the	O	O
number	O	O
of	O	O
bits	O	O
increases	O	O
.	O	O

Really	O	O
,	O	O
4D	O	O
arrays	O	O
are	O	O
just	O	O
1D	O	O
arrays	O	O
in	O	O
memory	O	O
anyway	O	O
(	O	O
Unless	O	O
you	O	O
really	O	O
have	O	O
view	O	B-API
objects	O	O
,	O	O
but	O	O
it	O	O
should	O	O
still	O	O
work	O	O
with	O	O
those	O	O
as	O	O
well	O	O
)	O	O

I'll	O	O
add	O	B-API
comments	O	O
to	O	O
explain	O	O
things	O	O
in	O	O
a	O	O
bit	O	O
.	O	O

I	O	O
was	O	O
assuming	O	O
that	O	O
the	O	O
rgb	O	O
and	O	O
ycc	O	O
matrices	O	O
were	O	O
just	O	O
a	O	O
matrix	O	B-API
that	O	O
had	O	O
as	O	O
many	O	O
rows	O	O
as	O	O
pixels	O	O
and	O	O
a	O	O
column	O	O
per	O	O
colour	O	O
component	O	O
.	O	O

For	O	O
example	O	O
,	O	O
suppose	O	O
`	O	O
a	O	O
=	O	O
ones	O	B-API
((	O	O
3	O	O
,	O	O
3	O	O
))`	O	O
.	O	O

Therefore	O	O
,	O	O
n	O	O
and	O	O
m	O	O
correspond	O	O
to	O	O
indices	O	B-API
in	O	O
the	O	O
array	O	B-API
,	O	O
but	O	O
I'm	O	O
not	O	O
sure	O	O
how	O	O
?	O	O

Update	O	O
:	O	O
As	O	O
mentioned	O	O
in	O	O
my	O	O
comment	O	O
below	O	O
,	O	O
I	O	O
should	O	O
have	O	O
stated	O	O
that	O	O
I'm	O	O
trying	O	O
to	O	O
do	O	O
this	O	O
on	O	O
2D	O	O
arrays	O	O
,	O	O
and	O	O
therefore	O	O
get	O	B-API
a	O	O
set	O	B-API
of	O	O
2D	O	O
indices	O	B-API
back	O	B-API
.	O	O

Need	O	O
to	O	O
add	O	B-API
a	O	O
check	O	O
for	O	O
that	O	O
,	O	O
but	O	O
otherwise	O	O
thanks	O	O
!	O	O

I	O	O
think	O	O
you	O	O
just	O	O
want	O	O
`	O	O
label	O	O
==	O	O
num	O	O
`	O	O
where	O	B-API
`	O	O
num	O	O
`	O	O
is	O	O
the	O	O
number	O	O
of	O	O
the	O	O
object	O	O
in	O	O
`	O	O
label	O	O
`	O	O
(	O	O
the	O	O
labeled	O	O
array	O	B-API
)	O	O
.	O	O

My	O	O
question	O	O
is	O	O
how	O	O
can	O	O
I	O	O
go	O	O
thru	O	O
the	O	O
array	O	B-API
to	O	O
access	O	O
the	O	O
object	O	O
in	O	O
the	O	O
array	O	B-API
?	O	O

The	O	O
matrix	O	B-API
in	O	O
the	O	O
example	O	O
above	O	O
is	O	O
singular	O	O
(	O	O
determinant	O	O
~	O	O
0	O	O
)	O	O
.	O	O

See	O	O
the	O	O
note	O	O
at	O	B-API
#URL	O	O

would	O	O
turn	O	O
into	O	O
either	O	O
this	O	O
array	O	B-API
:	O	O
#CODE	O	O

Note	O	O
that	O	O
this	O	O
is	O	O
a	O	O
bit	O	O
more	O	O
sophisticated	O	O
than	O	O
the	O	O
simple	O	O
do-it-yourself	O	O
convolve-method	O	O
,	O	O
since	O	O
it	O	O
tries	O	O
to	O	O
handle	O	O
the	O	O
problems	O	O
at	O	B-API
the	O	O
beginning	O	O
and	O	O
the	O	O
end	O	O
of	O	O
the	O	O
data	O	B-API
by	O	O
reflecting	O	O
it	O	O
(	O	O
which	O	O
may	O	O
or	O	O
may	O	O
not	O	O
work	O	O
in	O	O
your	O	O
case	O	O
...	O	O
)	O	O
.	O	O

Usually	O	O
,	O	O
in	O	O
numpy	O	O
,	O	O
you	O	O
keep	O	O
the	O	O
string	O	O
data	O	B-API
in	O	O
a	O	O
separate	O	O
array	O	B-API
.	O	O

Any	O	O
idea	O	O
what	O	O
might	O	O
be	O	O
happening	O	O
?	O	O

but	O	O
the	O	O
size	O	B-API
is	O	O
wrong	O	O
because	O	O
i've	O	O
assigned	O	O
1000	O	O
as	O	O
the	O	O
period	O	O
size	O	B-API
.	O	O

This	O	O
may	O	O
not	O	O
be	O	O
perfectly	O	O
pythonic	O	O
(	O	O
perhaps	O	O
someone	O	O
can	O	O
think	O	O
of	O	O
a	O	O
nicer	O	O
implementation	O	O
using	O	O
generators	O	O
or	O	O
itertools	O	O
?	O	O
)	O	O
but	O	O
it	O	O
is	O	O
hard	O	O
to	O	O
imagine	O	O
any	O	B-API
method	O	O
that	O	O
relies	O	O
on	O	O
searching	O	O
one	O	O
point	O	O
at	O	B-API
a	O	O
time	O	B-API
beating	O	O
this	O	O
in	O	O
speed	O	O
.	O	O

Thanks	O	O
,	O	O
your	O	O
post	O	O
helped	O	O
me	O	O
solve	O	B-API
this	O	O
problem	O	O
.	O	O

Now	O	O
imagine	O	O
that	O	O
the	O	O
next	O	B-API
time	O	B-API
step	O	B-API
some	O	O
values	O	B-API
change	O	O
,	O	O
so	O	O
should	O	O
this	O	O
picture	O	O
.	O	O

Since	O	O
get_probability	O	O
is	O	O
a	O	O
function	O	B-API
,	O	O
so	O	O
what	O	O
value	O	O
is	O	O
being	O	O
passed	O	O
to	O	O
count	O	B-API
parameter	O	O
here	O	O
???	O	O

taking	O	O
the	O	O
sum	O	B-API
for	O	O
each	O	O
column	O	O
.	O	O

You	O	O
should	O	O
be	O	O
able	O	O
to	O	O
just	O	O
load	O	B-API
the	O	O
entire	O	O
thing	O	O
into	O	O
memory	O	O
on	O	O
a	O	O
modern	O	O
machine	O	O
.	O	O

What	O	O
I	O	O
want	O	O
to	O	O
do	O	O
is	O	O
to	O	O
calculate	O	O
the	O	O
geographic	O	O
distances	O	O
between	O	B-API
rows	O	O
(	O	O
with	O	O
the	O	O
special	O	O
condition	O	O
that	O	O
the	O	O
first	O	B-API
element	O	O
is	O	O
always	O	O
zero	O	O
,	O	O
at	O	B-API
the	O	O
starting	O	O
point	O	O
)	O	O
.	O	O

We	O	O
can	O	O
simply	O	O
use	O	B-API
the	O	O
leastsq	O	O
function	O	B-API
to	O	O
find	O	B-API
the	O	O
best	O	O
coefficients	O	O
.	O	O

If	O	O
the	O	O
list	O	B-API
of	O	O
python	O	O
objects	O	O
doesn't	O	O
grow	O	B-API
at	O	B-API
all	O	B-API
from	O	O
frame	O	O
to	O	O
frame	O	O
,	O	O
the	O	O
leak	O	O
is	O	O
probably	O	O
in	O	O
the	O	O
C	O	O
code	O	O
or	O	O
the	O	O
python-to-C	O	O
link	O	O

Any	O	O
and	O	O
all	O	B-API
advice	O	O
is	O	O
greatly	O	O
appreciated	O	O
.	O	O

Numpy	O	O
:	O	O
Is	O	O
there	O	O
an	O	O
array	O	B-API
size	O	B-API
limit	O	O
?	O	O

Then	O	O
do	O	O
this	O	O
after	O	O
each	O	O
calculation	O	O
:	O	O
for	O	O
i	O	O
in	O	O
range	O	O
(	O	O
len	O	B-API
(	O	O
array	O	B-API
)):	O	O
array	O	B-API
[	O	O
i	O	O
]	O	O
[	O	O
i	O	O
]=	O	O
0	O	O

I	O	O
know	O	O
the	O	O
random	O	B-API
functions	O	O
and	O	O
numbers	O	O
seem	O	O
odd	O	O
,	O	O
but	O	O
conceptually	O	O
this	O	O
still	O	O
should	O	O
work	O	O
,	O	O
as	O	O
it	O	O
worked	O	O
when	O	O
both	O	O
were	O	O
set	O	B-API
to	O	O
variables	O	O
individually	O	O
.	O	O

@USER	O	O
are	O	O
your	O	O
numbers	O	O
in	O	O
the	O	O
range	O	O
of	O	O
-128	O	O
to	O	O
127	O	O
before	O	O
you	O	O
convert	O	B-API
them	O	O
to	O	O
8b	O	O
it	O	O
?	O	O

In	O	O
the	O	O
future	O	O
,	O	O
how	O	O
should	O	O
I	O	O
go	O	O
about	O	O
trying	O	O
to	O	O
find	O	B-API
routines	O	O
like	O	O
this	O	O
?	O	O

At	O	O
20,000	O	O
elements	O	O
,	O	O
your	O	O
method	O	O
is	O	O
about	O	O
25%	O	O
faster	O	O
.	O	O

I'll	O	O
fix	O	B-API
it	O	O
just	O	O
for	O	O
you	O	O
:P	O	O

Then	O	O
I	O	O
convert	O	B-API
it	O	O
to	O	O
a	O	O
numpy	O	O
array	O	B-API
:	O	O
#CODE	O	O

Just	O	O
throwing	O	O
in	O	O
my	O	O
two	O	O
cents	O	O
you	O	O
could	O	O
do	O	O
this	O	O
pretty	O	O
simply	O	O
using	O	O
list	O	B-API
comprehension	O	O
if	O	O
it's	O	O
always	O	O
a	O	O
2d	O	O
array	O	B-API
like	O	O
that	O	O
#CODE	O	O

While	O	O
its	O	O
expected	O	O
value	O	O
here	O	O
is	O	O
zero	O	O
,	O	O
the	O	O
particular	O	O
realizations	O	O
will	O	O
fluctuate	O	O
around	O	B-API
that	O	O
expected	O	O
value	O	O
.	O	O

Then	O	O
if	O	O
each	O	O
item	O	B-API
is	O	O
weighted	O	O
with	O	O
weight	O	O
w_i	O	O
,	O	O
the	O	O
"	O	O
summed	O	O
histogram	O	B-API
"	O	O
would	O	O
have	O	O
weight	O	O
sum	O	B-API
(	O	O
i	O	O
in	O	O
items	O	O
)	O	O
w_i	O	O
D_ij	O	O
.	O	O

This	O	O
approach	O	O
will	O	O
take	O	B-API
an	O	O
overhead	O	O
because	O	O
of	O	O
crating	O	O
a	O	O
new	O	O
array	O	B-API
in	O	O
memory	O	O
.	O	O

"	O	O
Eric's	O	O
suggestion	O	O
for	O	O
revising	O	O
this	O	O
question	O	O
is	O	O
a	O	O
good	O	O
start	O	O
,	O	O
but	O	O
I	O	O
think	O	O
the	O	O
question	O	O
"	O	O
Given	O	O
a	O	O
Cartesian	O	O
plane	O	O
,	O	O
how	O	O
to	O	O
discretize	O	O
it	O	O
in	O	O
a	O	O
matrix	O	B-API
form	O	O
?	O	O

it	O	O
is	O	O
the	O	O
same	O	O
as	O	O
long	O	O
as	O	O
you	O	O
ignore	O	B-API
precision	O	O
issue	O	O
-	O	O
which	O	O
matters	O	O
quite	O	O
often	O	O
when	O	O
you	O	O
start	O	O
taking	O	O
exponential	O	B-API
of	O	O
numbers	O	O
.	O	O

Google	O	O
Protocol	O	O
Buffers	O	O
support	O	O
self-describing	O	O
too	O	O
,	O	O
are	O	O
pretty	O	O
fast	O	O
(	O	O
but	O	O
Python	O	O
support	O	O
is	O	O
poor	O	O
at	O	B-API
present	O	O
time	O	B-API
,	O	O
slow	O	B-API
and	O	O
buggy	O	O
)	O	O
.	O	O

Not	O	O
all	O	B-API
people	O	O
can	O	O
install	O	O
NumPy	O	O
(	O	O
or	O	O
even	O	O
Python	O	O
:D	O	O
)	O	O
as	O	O
many	O	O
Blender	O	O
users	O	O
are	O	O
just	O	O
artists	O	O
.	O	O

All	O	O
possible	O	O
solutions	O	O
are	O	O
mentioned	O	O
in	O	O
the	O	O
comments	O	O
.	O	O

I've	O	O
also	O	O
refined	O	O
your	O	O
approach	O	O
to	O	O
allow	O	O
zooming	O	O
in	O	O
over	O	B-API
a	O	O
section	O	O
of	O	O
the	O	O
data	O	B-API
and	O	O
to	O	O
produce	O	O
better	O	O
results	O	O
at	O	B-API
the	O	O
borders	O	O
.	O	O

I	O	O
need	O	O
to	O	O
specify	O	O
datatypes	O	O
for	O	O
all	O	B-API
numerical	O	O
types	O	O
since	O	O
I	O	O
care	O	O
about	O	O
int	O	O
8/	O	O
16	O	O
/	O	O
32	O	O
,	O	O
etc	O	O
,	O	O
but	O	O
I	O	O
would	O	O
like	O	O
to	O	O
benefit	O	O
from	O	O
the	O	O
auto	O	O
string	O	O
length	O	O
detection	O	O
that	O	O
works	O	O
if	O	O
I	O	O
don't	O	O
specify	O	O
datatypes	O	O
.	O	O

I	O	O
would	O	O
appreciate	O	O
any	O	B-API
assistance	O	O
you	O	O
can	O	O
offer	O	O
.	O	O

Let's	O	O
say	O	O
for	O	O
example	O	O
I	O	O
have	O	O
a	O	O
matrix	O	B-API
X	O	O
which	O	O
is	O	O
my	O	O
input	O	O
.	O	O

@USER	O	O
-	O	O
By	O	O
the	O	O
way	O	O
,	O	O
indexing	O	O
returns	O	O
a	O	O
view	O	B-API
(	O	O
essentially	O	O
a	O	O
pointer	O	O
)	O	O
into	O	O
the	O	O
array	O	B-API
.	O	O

Note	O	O
that	O	O
`	O	O
view	O	B-API
`	O	O
holds	O	O
the	O	O
same	O	O
data	O	B-API
as	O	O
the	O	O
original	O	O
array	O	B-API
!	O	O

EDIT	O	O
:	O	O
What	O	O
sort	O	B-API
of	O	O
sequence	O	O
is	O	O
it	O	O
you're	O	O
making	O	O
?	O	O

The	O	O
relative	O	O
error	O	O
is	O	O
less	O	B-API
than	O	O
2	O	O
-24	O	O
,	O	O
which	O	O
is	O	O
1	O	O
/	O	O
2	O	O
ULP	O	O
divided	O	O
by	O	O
the	O	O
smallest	O	O
the	O	O
value	O	O
could	O	O
be	O	O
(	O	O
the	O	O
smallest	O	O
value	O	O
in	O	O
the	O	O
interval	O	O
for	O	O
a	O	O
particular	O	O
ULP	O	O
,	O	O
so	O	O
the	O	O
power	O	B-API
of	O	O
two	O	O
that	O	O
bounds	O	O
it	O	O
)	O	O
.	O	O

This	O	O
is	O	O
called	O	O
matrix	O	B-API
transposition	O	O
.	O	O

@USER	O	O
The	O	O
solutions	O	O
there	O	O
all	O	B-API
make	O	O
use	O	B-API
of	O	O
the	O	O
fact	O	O
that	O	O
only	O	O
a	O	O
3x3	O	O
sliding	O	O
window	O	O
is	O	O
needed	O	O
,	O	O
but	O	O
I	O	O
need	O	O
something	O	O
that	O	O
works	O	O
for	O	O
all	O	B-API
sizes	O	O
of	O	O
templates	O	O
.	O	O

(	O	O
0008	O	O
,	O	O
103e	O	O
)	O	O
Series	O	B-API
Description	O	O
LO	O	O
:	O	O
'	O	O
Screen	O	O
Save	O	O
'	O	O

@USER	O	O
khanSever	O	O
20k	O	O
wouldn't	O	O
be	O	O
a	O	O
problem	O	O
for	O	O
modern	O	O
computers	O	O
,	O	O
if	O	O
you	O	O
are	O	O
really	O	O
thresholded	O	O
by	O	O
speed	O	O
in	O	O
this	O	O
kind	O	O
of	O	O
computation	O	O
,	O	O
I	O	O
would	O	O
say	O	O
that	O	O
you	O	O
shouldn't	O	O
have	O	O
had	O	O
an	O	O
inhomogenous	O	O
data	O	B-API
array	O	B-API
to	O	O
begin	O	O
with	O	O
.	O	O

@USER	O	O
Eweiwi	O	O
:	O	O
Did	O	O
you	O	O
find	O	B-API
my	O	O
answer	O	O
anyway	O	O
useful	O	O
?	O	O

You	O	O
can	O	O
now	O	O
compute	O	O
the	O	O
function	O	B-API
`	O	O
f	O	B-API
(	O	O
x	O	O
)`	O	O
at	O	B-API
any	O	B-API
point	O	O
`	O	O
x	O	O
`	O	O
.	O	O

BTW	O	O
:	O	O
this	O	O
is	O	O
a	O	O
neat	O	O
workaround	O	O
,	O	O
but	O	O
if	O	O
it	O	O
were	O	O
possible	O	O
to	O	O
use	O	B-API
the	O	O
`	O	O
in	O	O
`	O	O
operator	O	O
would	O	O
have	O	O
preferred	O	O
,	O	O
as	O	O
in	O	O
my	O	O
"	O	O
real	O	B-API
case	O	O
"	O	O
I	O	O
have	O	O
a	O	O
pool	O	O
of	O	O
roughly	O	O
10	O	O
values	O	B-API
,	O	O
non	O	O
only	O	O
`	O	O
(	O	O
6	O	O
,	O	O
8)	O	O
`	O	O
.	O	O

In	O	O
this	O	O
example	O	O
I	O	O
want	O	O
to	O	O
return	O	O
an	O	O
array	O	B-API
of	O	O
[	O	O
202	O	O
203	O	O
206	O	O
210	O	O
]	O	O

So	O	O
f	O	B-API
(	O	O
x	O	O
,	O	O
y	O	O
)	O	O
=	O	O
0	O	O

I	O	O
present	O	O
below	O	O
a	O	O
sample	O	B-API
silhouette	O	O
implementation	O	O
in	O	O
both	O	O
MATLAB	O	O
and	O	O
Python	O	O
/	O	O
Numpy	O	O
(	O	O
keep	O	O
in	O	O
mind	O	O
that	O	O
I	O	O
am	O	O
more	O	O
fluent	O	O
in	O	O
MATLAB	O	O
):	O	O

Python	O	O
import	O	O
Column	O	O
Data	O	O
from	O	O
MySQL	O	O
as	O	O
Array	O	O

This	O	O
is	O	O
just	O	O
the	O	O
partial	O	O
count	O	B-API
due	O	O
to	O	O
the	O	O
34	O	O
1-chips	O	O
.	O	O

I	O	O
want	O	O
to	O	O
know	O	O
how	O	O
I	O	O
should	O	O
index	O	B-API
/	O	O
access	O	O
some	O	O
data	O	B-API
programmatically	O	O
in	O	O
python	O	O
.	O	O

There	O	O
is	O	O
a	O	O
short	O	O
comment	O	O
at	O	B-API
the	O	O
end	O	O
of	O	O
the	O	O
introduction	O	O
to	O	O
SciPy	O	O
documentation	O	O
:	O	O

What	O	O
about	O	O
the	O	O
maximum	O	B-API
value	O	O
in	O	O
the	O	O
array	O	B-API
?	O	O

If	O	O
you	O	O
use	O	B-API
a	O	O
list	O	B-API
of	O	O
`	O	O
True	O	O
/	O	O
False	O	O
`	O	O
,	O	O
NumPy	O	O
will	O	O
interpret	O	O
that	O	O
as	O	O
a	O	O
list	O	B-API
of	O	O
`	O	O
1	O	O
/	O	O
0	O	O
`	O	O
as	O	O
integers	O	O
,	O	O
that	O	O
is	O	O
,	O	O
indices	O	B-API
,	O	O
meaning	O	O
that	O	O
you	O	O
'	O	O
either	O	O
get	O	B-API
the	O	O
second	O	B-API
or	O	O
first	O	B-API
element	O	O
of	O	O
your	O	O
array	O	B-API
.	O	O

But	O	O
it's	O	O
still	O	O
an	O	O
array	O	B-API
and	O	O
there	O	O
is	O	O
no	O	O
difference	O	B-API
in	O	O
asymptotic	O	O
complexity	O	O
.	O	O

Here's	O	O
one	O	O
way	O	O
(	O	O
same	O	O
matrix	O	B-API
as	O	O
before	O	O
):	O	O
#CODE	O	O

assume	O	O
i	O	O
have	O	O
100	O	O
points	O	O
whose	O	O
coordinates	O	O
are	O	O
random	O	B-API
,	O	O

If	O	O
you	O	O
just	O	O
want	O	O
the	O	O
first	O	B-API
one	O	O
,	O	O
use	O	B-API
next	O	B-API
with	O	O
the	O	O
list	O	B-API
comprehension	O	O
as	O	O
a	O	O
generator	O	O
expression	O	O
.	O	O

So	O	O
I	O	O
am	O	O
able	O	O
to	O	O
plot	O	B-API
what	O	O
I	O	O
want	O	O
onto	O	O
my	O	O
matrix	O	B-API

By	O	O
X3D	O	O
,	O	O
are	O	O
you	O	O
referring	O	O
to	O	O
the	O	O
x3d	O	O
standard	O	O
for	O	O
3d	O	O
content	O	O
,	O	O
as	O	O
at	O	B-API
#URL	O	O
If	O	O
so	O	O
,	O	O
I	O	O
would	O	O
very	O	O
much	O	O
like	O	O
to	O	O
learn	O	O
more	O	O
of	O	O
what	O	O
you	O	O
are	O	O
doing	O	O
--	O	O
thanks	O	O

Would	O	O
it	O	O
be	O	O
prohibitvely	O	O
wasteful	O	O
to	O	O
save	O	B-API
them	O	O
with	O	O
a	O	O
fixed	O	O
width	O	O
?	O	O

BSD-licensed	O	O
Python	O	O
source	O	B-API
code	O	O
for	O	O
surface	O	O
fits	O	O
can	O	O
be	O	O
found	O	O
at	O	B-API

...	O	O
which	O	O
returned	O	O
`	O	O
True	O	O
`	O	O
on	O	O
each	O	O
value	O	O
of	O	O
the	O	O
array	O	B-API
.	O	O

I	O	O
have	O	O
two	O	O
ordered	O	B-API
numpy	O	O
arrays	O	O
and	O	O
I	O	O
want	O	O
to	O	O
interleave	O	O
them	O	O
so	O	O
that	O	O
I	O	O
take	O	B-API
one	O	O
item	O	B-API
from	O	O
the	O	O
first	O	B-API
array	O	B-API
,	O	O
then	O	O
another	O	O
from	O	O
the	O	O
second	O	B-API
,	O	O
then	O	O
back	O	B-API
to	O	O
the	O	O
first	O	B-API
-	O	O
taking	O	O
the	O	O
next	O	B-API
item	O	B-API
that	O	O
is	O	O
larger	O	O
than	O	O
the	O	O
one	O	O
I	O	O
just	O	O
took	O	O
from	O	O
the	O	O
second	O	B-API
and	O	O
so	O	O
on	O	O
.	O	O

Did	O	O
you	O	O
look	O	O
at	O	B-API
the	O	O
link	O	O
in	O	O
my	O	O
answer	O	O
to	O	O
the	O	O
SciPy	O	O
page	O	O
on	O	O
Performance	O	O
Python	O	O
.	O	O

If	O	O
you	O	O
want	O	O
the	O	O
column	O	O
indices	O	B-API
instead	O	O
of	O	O
the	O	O
resulting	O	O
square	O	B-API
matrix	O	B-API
,	O	O
just	O	O
replace	O	B-API
`	O	O
return	O	O
B	O	O
`	O	O
with	O	O
`	O	O
return	O	O
colset	O	O
`	O	O
.	O	O

At	O	O
the	O	O
end	O	O
of	O	O
it	O	O
all	O	B-API
:	O	O
#CODE	O	O

Is	O	O
there	O	O
no	O	O
equivalent	O	O
function	O	B-API
that	O	O
gets	O	O
the	O	O
index	O	B-API
of	O	O
the	O	O
last	O	B-API
occurrence	O	O
?	O	O

I	O	O
want	O	O
to	O	O
get	O	B-API
a	O	O
cartesian	O	O
product	O	B-API
of	O	O
a	O	O
[:	O	O
:	O	O
i	O	O
]	O	O
and	O	O
b	O	O
[:	O	O
:	O	O
j	O	O
]	O	O
from	O	O
c	O	O
.	O	O

python	O	O
/	O	O
numpy	O	O
:	O	O
how	O	O
to	O	O
get	O	B-API
2D	O	O
array	O	B-API
column	O	O
length	O	O
?	O	O

Your	O	O
example	O	O
works	O	O
for	O	O
me	O	O
if	O	O
I	O	O
sample	O	B-API
around	O	B-API
2**6	O	O
points	O	O
.	O	O

NumPy's	O	O
main	O	B-API
object	O	O
is	O	O
the	O	O
homogeneous	O	O
multidimensional	O	O
array	O	B-API
.	O	O

Pythonic	O	O
way	O	O
to	O	O
import	O	O
data	O	B-API
from	O	O
multiple	O	O
files	O	O
into	O	O
an	O	O
array	O	B-API

The	O	O
only	O	O
thing	O	O
I	O	O
was	O	O
going	O	O
to	O	O
add	O	B-API
was	O	O
this	O	O
:	O	O
#URL	O	O
Indicated	O	O
that	O	O
this	O	O
is	O	O
not	O	O
likely	O	O
to	O	O
change	O	O
.	O	O

i	O	O
have	O	O
a	O	O
numpy	O	O
array	O	B-API
like	O	O
the	O	O
following	O	O
#CODE	O	O

I	O	O
want	O	O
to	O	O
write	O	O
a	O	O
Boost-Python	O	O
program	O	O
to	O	O
take	O	B-API
a	O	O
symbolic	O	O
python	O	O
function	O	B-API
from	O	O
user	O	O
and	O	O
evaluate	O	B-API
its	O	O
derivative	O	O
in	O	O
my	O	O
program	O	O
.	O	O

Is	O	O
there	O	O
a	O	O
way	O	O
around	O	B-API
this	O	O
?	O	O

Not	O	O
sure	O	O
if	O	O
I	O	O
explained	O	O
this	O	O
all	O	B-API
really	O	O
well	O	O
,	O	O
but	O	O
just	O	O
print	O	O
out	O	O
a_strided	O	O
and	O	O
you'll	O	O
see	O	O
what	O	O
the	O	O
result	O	O
is	O	O
and	O	O
how	O	O
easy	O	O
this	O	O
makes	O	O
the	O	O
operation	O	O
.	O	O

But	O	O
when	O	O
I	O	O
start	O	O
calling	O	O
columns	O	O
by	O	O
their	O	O
field	O	B-API
names	O	B-API
,	O	O
screwy	O	O
things	O	O
happen	O	O
.	O	O

all	O	B-API
I	O	O
get	O	B-API
is	O	O
very	O	O
high	O	O
or	O	O
inf	O	O
numbers	O	O
.	O	O

If	O	O
you're	O	O
iterating	O	O
through	O	O
,	O	O
and	O	O
applying	O	O
the	O	O
function	O	B-API
to	O	O
_each_	O	O
item	O	B-API
,	O	O
then	O	O
,	O	O
yeah	O	O
,	O	O
the	O	O
numpy	O	O
functions	O	O
will	O	O
be	O	O
slower	O	O
.	O	O

Slicing	O	O
does	O	O
not	O	O
copy	O	B-API
the	O	O
array	O	B-API
into	O	O
new	O	O
memory	O	O
(	O	O
unlike	O	O
delete	O	B-API
)	O	O
.	O	O

And	O	O
here's	O	O
the	O	O
filled	O	B-API
version	O	O
:	O	O
#CODE	O	O

This	O	O
is	O	O
a	O	O
little	O	O
bit	O	O
annoying	O	O
to	O	O
do	O	O
,	O	O
but	O	O
at	O	B-API
least	O	O
you	O	O
can	O	O
remove	O	B-API
that	O	O
annoying	O	O
`	O	O
==	O	O
`	O	O
easily	O	O
,	O	O
using	O	O
sorting	O	O
(	O	O
and	O	O
thats	O	O
probably	O	O
your	O	O
speed	O	O
killer	O	O
)	O	O
.	O	O

I	O	O
still	O	O
haven't	O	O
found	O	O
an	O	O
entirely	O	O
satisfactory	O	O
solution	O	O
,	O	O
but	O	O
nevertheless	O	O
there	O	O
is	O	O
something	O	O
one	O	O
can	O	O
do	O	O
to	O	O
obtain	O	O
the	O	O
pointer	O	O
with	O	O
a	O	O
lot	O	O
less	O	B-API
overhead	O	O
in	O	O
CPython	O	O
.	O	O

I	O	O
also	O	O
tried	O	O
using	O	O
NumPy	O	O
masked	O	B-API
arrays	O	O
,	O	O
with	O	O
NaN	O	O
fill_value	O	O
,	O	O
which	O	O
also	O	O
did	O	O
not	O	O
work	O	O
.	O	O

cartesian	O	O
(	O	O
split	O	B-API
(	O	O
a	O	O
,	O	O
3	O	O
))`	O	O
.	O	O

I	O	O
did	O	O
a	O	O
little	O	O
further	O	O
experimenting	O	O
and	O	O
found	O	O
a	O	O
numpy	O	O
specific	O	O
way	O	O
to	O	O
solve	O	B-API
this	O	O
:	O	O
#CODE	O	O

When	O	O
you	O	O
need	O	O
to	O	O
deal	O	O
with	O	O
exponential	O	B-API
,	O	O
you	O	O
quickly	O	O
go	O	O
into	O	O
under	O	O
/	O	O
over	O	B-API
flow	O	O
since	O	O
the	O	O
function	O	B-API
grows	O	O
so	O	O
quickly	O	O
.	O	O

Long	O	O
story	O	O
short	O	O
,	O	O
not	O	O
only	O	O
does	O	O
tabular	O	O
not	O	O
act	O	O
like	O	O
a	O	O
spreadsheet	O	O
out	O	O
of	O	O
the	O	O
box	O	B-API
,	O	O
I	O	O
can't	O	O
find	O	B-API
a	O	O
way	O	O
to	O	O
make	O	O
it	O	O
work	O	O
.	O	O

What	O	O
do	O	O
you	O	O
mean	O	B-API
"	O	O
two	O	O
significant	O	O
figures	O	O
"	O	O
?	O	O

We	O	O
put	O	B-API
it	O	O
in	O	O
a	O	O
list	O	B-API
and	O	O
double	O	O
it	O	O
.	O	O

For	O	O
example	O	O
for	O	O
value	O	O
255	O	O
the	O	O
coordinates	O	O
of	O	O
the	O	O
box	O	B-API
around	O	B-API
the	O	O
value	O	O
255	O	O
will	O	O
be	O	O
upper	O	B-API
left	O	O
(	O	O
0	O	O
,	O	O
0	O	O
)	O	O
and	O	O
lower	O	B-API
right	O	O
(	O	O
4	O	O
,	O	O
6	O	O
)	O	O
.	O	O

Like	O	O
in	O	O
a	O	O
java	O	O
program	O	O
,	O	O
you	O	O
can	O	O
choose	O	B-API
to	O	O
start	O	O
it	O	O
up	O	O
with	O	O
,	O	O
say	O	O
,	O	O
5GB	O	O
of	O	O
memory	O	O
.	O	O

However	O	O
,	O	O
due	O	O
to	O	O
the	O	O
way	O	O
the	O	O
data	O	B-API
points	O	O
lie	O	O
it	O	O
does	O	O
not	O	O
give	O	O
me	O	O
a	O	O
y-axis	O	O
interception	O	O
at	O	B-API
0	O	O
.	O	O

I'd	O	O
like	O	O
to	O	O
sort	O	B-API
it	O	O
such	O	O
that	O	O
my	O	O
points	O	O
are	O	O
ordered	O	B-API
by	O	O
x-coordinate	O	O
,	O	O
and	O	O
then	O	O
by	O	O
y	O	O
in	O	O
cases	O	O
where	O	B-API
the	O	O
x	O	O
coordinate	O	O
is	O	O
the	O	O
same	O	O
.	O	O

Of	O	O
course	O	O
this	O	O
will	O	O
slow	O	B-API
the	O	O
program	O	O
down	O	O
,	O	O
but	O	O
at	O	B-API
least	O	O
it'll	O	O
finish	O	B-API
.	O	O

Im	O	O
writing	O	O
it	O	O
here	O	O
because	O	O
i	O	O
cant	O	O
put	O	B-API
image	O	B-API
in	O	O
comment	O	O
.	O	O

In	O	O
looking	O	O
at	O	B-API
`	O	O
fill	O	B-API
`	O	O
,	O	O
I	O	O
saw	O	O
that	O	O
`	O	O
repeat	O	B-API
`	O	O
suits	O	O
my	O	O
needs	O	O
even	O	O
better	O	O
.	O	O

Note	O	O
that	O	O
an	O	O
array's	O	O
base	O	B-API
will	O	O
be	O	O
another	O	O
array	O	B-API
,	O	O
even	O	O
if	O	O
it	O	O
is	O	O
a	O	O
subset	O	O
:	O	O
#CODE	O	O

If	O	O
you	O	O
have	O	O
float	O	O
data	O	B-API
,	O	O
or	O	O
data	O	B-API
spread	O	O
over	O	B-API
a	O	O
huge	O	O
range	O	O
you	O	O
can	O	O
convert	O	B-API
it	O	O
to	O	O
integers	O	O
by	O	O
doing	O	O
:	O	O
#CODE	O	O

@USER	O	O
,	O	O
plaes	O	O
recommend	O	O
using	O	O
a	O	O
generator	O	O
(	O	O
parenthesis	O	O
)	O	O
instead	O	O
of	O	O
a	O	O
list	O	B-API
(	O	O
brackets	O	O
)	O	O
in	O	O
order	O	B-API
to	O	O
save	O	B-API
memory	O	O
and	O	O
gain	O	O
speed	O	O
when	O	O
managing	O	O
high	O	O
amounts	O	O
of	O	O
data	O	B-API
.	O	O

I	O	O
want	O	O
to	O	O
divide	O	B-API
this	O	O
array	O	B-API
into	O	O
3	O	O
blocks	O	B-API
of	O	O
size	O	B-API
2x4	O	O
,	O	O
and	O	O
then	O	O
find	O	B-API
the	O	O
mean	O	B-API
of	O	O
all	O	B-API
three	O	O
blocks	O	B-API
(	O	O
so	O	O
that	O	O
the	O	O
shape	O	B-API
of	O	O
the	O	O
mean	O	B-API
is	O	O
2x4	O	O
.	O	O

(	O	O
Have	O	O
a	O	O
look	O	O
at	O	B-API
the	O	O
comments	O	O
above	O	O
the	O	O
code	O	O
for	O	O
that	O	O
portion	O	O
.	O	O
)	O	O

That	O	O
is	O	O
because	O	O
`	O	O
fsolve	O	O
`	O	O
thinks	O	O
it	O	O
is	O	O
looking	O	O
for	O	O
an	O	O
array	O	B-API
of	O	O
length	O	O
17	O	O
that	O	O
solves	O	O
`	O	O
p	O	O
`	O	O
.	O	O

When	O	O
there's	O	O
a	O	O
choice	O	B-API
between	O	B-API
working	O	O
with	O	O
NumPy	O	O
array	O	B-API
and	O	O
numeric	O	O
lists	O	O
,	O	O
the	O	O
former	O	O
are	O	O
typically	O	O
faster	O	O
.	O	O

Wait	O	O
...	O	O
why	O	O
do	O	O
you	O	O
need	O	O
the	O	O
negative	O	B-API
?	O	O

But	O	O
if	O	O
a	O	O
dense	O	O
3d	O	O
array	O	B-API
representation	O	O
isn't	O	O
that	O	O
much	O	O
bigger	O	O
,	O	O
storing	O	O
it	O	O
as	O	O
a	O	O
chuncked	O	O
and	O	O
compressed	O	B-API
hdf5	O	O
array	O	B-API
is	O	O
probably	O	O
the	O	O
way	O	O
to	O	O
go	O	O
.	O	O

Index	O	B-API
datetime	O	O
in	O	O
numpy	O	O
array	O	B-API

Is	O	O
there	O	O
an	O	O
"	O	O
expandable	O	O
"	O	O
matrix	O	B-API
data	O	B-API
structure	O	O
available	O	B-API
in	O	O
a	O	O
well	O	O
tested	O	O
module	O	O
?	O	O

You	O	O
can	O	O
make	O	O
this	O	O
one-liner	O	O
reusable	O	O
if	O	O
you	O	O
are	O	O
going	O	O
to	O	O
repeat	O	B-API
it	O	O
a	O	O
lot	O	O
:	O	O
#CODE	O	O

Here's	O	O
my	O	O
array	O	B-API
(	O	O
rather	O	O
,	O	O
a	O	O
method	O	O
of	O	O
generating	O	O
representative	O	O
test	O	B-API
arrays	O	O
):	O	O
#CODE	O	O

We	O	O
need	O	O
more	O	O
information	O	O
on	O	O
your	O	O
array	O	B-API
.	O	O

@USER	O	O
:	O	O
If	O	O
the	O	O
code	O	O
all	O	B-API
F77	O	O
,	O	O
why	O	O
is	O	O
the	O	O
question	O	O
tagged	O	O
Python	O	O
?	O	O

It	O	O
does	O	O
that	O	O
without	O	O
densifying	O	O
the	O	O
matrix	O	B-API
right	O	O
?	O	O

To	O	O
speed	O	O
up	O	O
the	O	O
program	O	O
,	O	O
I	O	O
want	O	O
to	O	O
pass	O	O
the	O	O
index	O	B-API
through	O	O
a	O	O
subroutine	O	O
,	O	O
but	O	O
I	O	O
cannot	O	O
pass	O	O
`	O	O
[	O	O
index	O	B-API
[	O	O
0	O	O
]	O	O
,	O	O
:	O	O
,	O	O
index	O	B-API
[	O	O
1	O	O
]	O	O
,	O	O
index	O	B-API
[	O	O
2	O	O
]]`	O	O
through	O	O
a	O	O
subroutine	O	O
because	O	O
I	O	O
cannot	O	O
pass	O	O
the	O	O
colon	O	O
'	O	O
:	O	O
'	O	O
.	O	O

Any	O	O
thoughts	O	O
on	O	O
what	O	O
I'm	O	O
doing	O	O
wrong	O	O
?	O	O

This	O	O
will	O	O
be	O	O
far	O	O
,	O	O
far	O	O
faster	O	O
than	O	O
constantly	O	O
reallocating	O	O
the	O	O
array	O	B-API
inside	O	O
the	O	O
loop	O	O
.	O	O

How	O	O
can	O	O
I	O	O
get	O	B-API
a	O	O
new	O	O
array	O	B-API
containing	O	O
the	O	O
values	O	B-API
of	O	O
specific	O	O
attributes	O	O
of	O	O
those	O	O
objects	O	O
?	O	O

Seriously	O	O
,	O	O
at	O	B-API
least	O	O
leave	O	O
a	O	O
note	O	O
,	O	O
but	O	O
given	O	O
the	O	O
"	O	O
complexity	O	O
"	O	O
of	O	O
your	O	O
actual	O	O
request	O	O
I'd	O	O
say	O	O
that	O	O
you'll	O	O
have	O	O
better	O	O
chances	O	O
with	O	O
a	O	O
new	O	O
question	O	O
.	O	O

and	O	O
find	O	B-API
the	O	O
roots	O	B-API
with	O	O
numpy	O	O
:	O	O
#CODE	O	O

I	O	O
need	O	O
to	O	O
create	O	O
a	O	O
numpy	O	O
array	O	B-API
of	O	O
N	O	O
elements	O	O
,	O	O
but	O	O
I	O	O
want	O	O
to	O	O
access	O	O
the	O	O

I	O	O
have	O	O
allocated	O	O
a	O	O
chunk	O	O
of	O	O
double	O	O
in	O	O
a	O	O
C	O	O
library	O	B-API
and	O	O
I	O	O
would	O	O
like	O	O
to	O	O
create	O	O
a	O	O
numpy	O	O
1D	O	O
array	O	B-API
based	O	O
on	O	O
that	O	O
data	O	B-API
;	O	O
ideally	O	O
I	O	O
would	O	O
like	O	O
two	O	O
versions	O	O
one	O	O
which	O	O
only	O	O
wraps	O	O
the	O	O
c_ptr	O	O
readonly	O	O
-	O	O
letting	O	O
the	O	O
C	O	O
layer	O	O
retain	O	O
ownership	O	O
of	O	O
the	O	O
data	O	B-API
,	O	O
and	O	O
one	O	O
which	O	O
copies	O	O
the	O	O
data	O	B-API
.	O	O

The	O	O
code	O	O
included	O	O
in	O	O
pypy	O	O
is	O	O
a	O	O
new	O	O
array	O	B-API
class	O	O
which	O	O
tries	O	O
to	O	O
be	O	O
compatible	O	O
with	O	O
numpy	O	O
,	O	O
IOW	O	O
,	O	O
it	O	O
is	O	O
a	O	O
reimplementation	O	O
from	O	O
scratch	O	O
,	O	O
without	O	O
many	O	O
features	O	O
from	O	O
numpy	O	O
.	O	O

Like	O	O
I	O	O
say	O	O
,	O	O
I'm	O	O
honestly	O	O
struggling	O	O
,	O	O
any	O	B-API
help	O	O
would	O	O
be	O	O
much	O	O
appreciated	O	O
.	O	O

with	O	O
array	O	B-API
.	O	O

I'm	O	O
not	O	O
sure	O	O
that	O	O
I	O	O
understand	O	O
the	O	O
difference	O	B-API
between	O	B-API
copying	O	O
the	O	O
matrix	O	B-API
(	O	O
example	O	O
1	O	O
)	O	O
and	O	O
copying	O	O
the	O	O
data	O	B-API
(	O	O
example	O	O
2	O	O
)	O	O
.	O	O

Does	O	O
anybody	O	O
know	O	O
of	O	O
a	O	O
(	O	O
common	O	O
case	O	O
)	O	O
faster-than-linear	O	O
way	O	O
to	O	O
find	O	B-API
the	O	O
endpoints	O	O
of	O	O
a	O	O
boolean	O	O
property	O	O
of	O	O
an	O	O
array	O	B-API
.	O	O

Any	O	O
unrecognized	O	O
type	O	O
will	O	O
work	O	O
this	O	O
way	O	O
,	O	O
so	O	O
you	O	O
might	O	O
want	O	O
to	O	O
use	O	B-API
`	O	O
myclass	O	O
`	O	O
instead	O	O
of	O	O
`	O	O
object	O	O
`	O	O
.	O	O

Iterate	O	O
over	O	B-API
vectors	O	O
in	O	O
a	O	O
multidimensional	O	O
numpy	O	O
array	O	B-API

This	O	O
way	O	O
you	O	O
can	O	O
load	O	B-API
a	O	O
large	O	O
dataset	O	O
from	O	O
a	O	O
textfile	O	O
memory-efficiently	O	O
while	O	O
retaining	O	O
all	O	B-API
the	O	O
convenient	O	O
parsing	O	O
features	O	O
of	O	O
the	O	O
two	O	O
functions	O	O
.	O	O

you	O	O
may	O	O
win	O	O
few	O	O
cycles	O	O
if	O	O
you	O	O
multiply	O	B-API
by	O	O
inverse	O	B-API
instead	O	O
of	O	O
dividing	O	O
in	O	O
floating-point	O	O
performance	O	O
.	O	O

Without	O	O
knowing	O	O
the	O	O
size	O	B-API
or	O	O
quantity	O	O
of	O	O
the	O	O
images	O	O
or	O	O
the	O	O
application	O	O
of	O	O
the	O	O
algorithm	O	O
(	O	O
computer	O	O
vision	O	O
?	O	O
)	O	O
,	O	O
I	O	O
can't	O	O
say	O	O
how	O	O
big	O	O
a	O	O
deal	O	O
that	O	O
kind	O	O
of	O	O
speedup	O	O
is	O	O
.	O	O

Is	O	O
there	O	O
an	O	O
easy	O	O
way	O	O
to	O	O
sort	O	B-API
these	O	O
eigenvalues	O	O
(	O	O
and	O	O
associated	O	O
vectors	O	O
)	O	O
in	O	O
order	O	B-API
?	O	O

You	O	O
can	O	O
pass	O	O
a	O	O
numpy	O	O
array	O	B-API
or	O	O
matrix	O	B-API
as	O	O
an	O	O
argument	O	O
when	O	O
initializing	O	O
a	O	O
sparse	O	O
matrix	O	B-API
.	O	O

(	O	O
For	O	O
most	O	O
common	O	O
applications	O	O
of	O	O
quadratic	O	O
forms	O	O
q	O	O
A	O	O
,	O	O
the	O	O
matrix	O	B-API
A	O	O
is	O	O
symmetric	O	O
,	O	O
or	O	O
even	O	O
symmetric	O	O
positive	O	O
definite	O	O
,	O	O
so	O	O
feel	O	O
free	O	O
to	O	O
assume	O	O
that	O	O
either	O	O
one	O	O
of	O	O
these	O	O
is	O	O
the	O	O
case	O	O
,	O	O
if	O	O
it	O	O
matters	O	O
for	O	O
your	O	O
answer	O	O
.	O	O
)	O	O

I	O	O
think	O	O
you	O	O
might	O	O
find	O	B-API
the	O	O
`	O	O
flat	O	O
`	O	O
method	O	O
useful	O	O
.	O	O

Now	O	O
that	O	O
we	O	O
have	O	O
both	O	O
the	O	O
starting	O	O
and	O	O
ending	O	O
values	O	B-API
,	O	O
we	O	O
can	O	O
use	O	B-API
the	O	O
indices	O	B-API
function	O	B-API
from	O	O
this	O	O
question	O	O
to	O	O
get	O	B-API
an	O	O
array	O	B-API
of	O	O
selector	O	O
indices	O	B-API
:	O	O
#CODE	O	O

10	O	O
(	O	O
i	O	O
?	O	O
1	O	O
)	O	O
K	O	O
,	O	O
where	O	B-API
K	O	O
=	O	O
k	O	O
/	O	O
(	O	O
n	O	O
?	O	O
1	O	O
)	O	O
.	O	O

This	O	O
identifies	O	O
which	O	O
rows	O	O
have	O	O
any	O	B-API
element	O	O
which	O	O
are	O	O
True	O	O
#CODE	O	O

Broadcasting	O	O
is	O	O
a	O	O
more	O	O
general	O	O
way	O	O
to	O	O
fill	O	B-API
an	O	O
array	O	B-API
and	O	O
I	O	O
would	O	O
guess	O	O
is	O	O
slower	O	O
or	O	O
equal	O	B-API
to	O	O
the	O	O
very	O	O
narrow	O	O
use	O	B-API
case	O	O
of	O	O
`	O	O
fill	O	B-API
`	O	O
.	O	O

By	O	O
"	O	O
not	O	O
replicating	O	O
data	O	B-API
"	O	O
I	O	O
am	O	O
assuming	O	O
you	O	O
mean	O	B-API
"	O	O
not	O	O
allocating	O	O
more	O	O
memory	O	O
"	O	O
.	O	O

Can	O	O
you	O	O
post	O	O
all	O	B-API
/	O	O
more	O	O
of	O	O
the	O	O
data	O	B-API
?	O	O

The	O	O
scoring	O	O
matrix	O	B-API
would	O	O
be	O	O
trivial	O	O
,	O	O
as	O	O
the	O	O
"	O	O
distance	O	O
"	O	O
between	O	B-API
two	O	O
numbers	O	O
is	O	O
just	O	O
their	O	O
difference	O	B-API
.	O	O

Contours	O	O
around	O	B-API
scipy	O	O
labeled	O	O
regions	O	O
in	O	O
a	O	O
2D	O	O
grid	O	B-API

Why	O	O
doesn't	O	O
the	O	O
shape	O	B-API
of	O	O
my	O	O
numpy	O	O
array	O	B-API
change	O	O
?	O	O

Mind	O	O
also	O	O
the	O	O
indexing	O	O
starts	O	O
at	O	B-API
`	O	O
0	O	O
`	O	O

I	O	O
have	O	O
a	O	O
vague	O	O
feeling	O	O
that	O	O
I	O	O
might	O	O
have	O	O
seen	O	O
a	O	O
question	O	O
addressing	O	O
this	O	O
problem	O	O
,	O	O
but	O	O
I	O	O
can't	O	O
find	O	B-API
it	O	O
now	O	O
.	O	O

If	O	O
you	O	O
know	O	O
which	O	O
rows	O	O
are	O	O
to	O	O
be	O	O
deleted	O	O
,	O	O
just	O	O
extract	O	B-API
the	O	O
other	O	O
rows	O	O
(	O	O
you	O	O
need	O	O
)	O	O
and	O	O
create	O	O
a	O	O
new	O	O
array	O	B-API
.	O	O

If	O	O
there	O	O
is	O	O
any	O	B-API
other	O	O
way	O	O
I	O	O
guess	O	O
I	O	O
have	O	O
to	O	O
do	O	O
that	O	O
.	O	O

I	O	O
have	O	O
a	O	O
matrix	O	B-API
,	O	O
say	O	O
#CODE	O	O

You	O	O
might	O	O
find	O	B-API
out	O	O
the	O	O
distribution	O	O
information	O	O
using	O	O
`	O	O
cat	O	B-API
/	O	O
etc	O	O
/	O	O
*-release	O	O
`	O	O
;)	O	O

I	O	O
was	O	O
wondering	O	O
if	O	O
anyone	O	O
found	O	O
a	O	O
good	O	O
workaround	O	O
,	O	O
as	O	O
my	O	O
real-world	O	O
problem	O	O
of	O	O
iterating	O	O
over	O	B-API
the	O	O
Cartesian-product	O	O
of	O	O
the	O	O
rows	O	O
in	O	O
very	O	O
large	O	O
arrays	O	O
is	O	O
so	O	O
slow	O	B-API
it's	O	O
impeding	O	O
progress	O	O
.	O	O

I	O	O
have	O	O
an	O	O
array	O	B-API
of	O	O
x	O	O
,	O	O
y	O	O
,	O	O
z	O	O
distances	O	O
and	O	O
I	O	O
need	O	O
to	O	O
find	O	B-API
the	O	O
differences	O	O
between	O	B-API
each	O	O
vector	O	O
from	O	O
one	O	O
another	O	O
.	O	O

The	O	O
code	O	O
above	O	O
finds	O	O
parts	O	O
where	O	B-API
there	O	O
are	O	O
at	O	B-API
least	O	O
MIN_SILENCE	O	O
consecutive	O	O
elements	O	O
smaller	O	O
than	O	O
SILENCE_THRESHOLD	O	O
.	O	O

The	O	O
list	O	B-API
of	O	O
indices	O	B-API
will	O	O
always	O	O
be	O	O
ascending	O	O
,	O	O
never	O	O
have	O	O
duplicates	O	O
,	O	O
but	O	O
may	O	O
have	O	O
gaps	O	O
like	O	O
the	O	O
example	O	O
.	O	O

Any	O	O
ideas	O	O
?	O	O

sum	O	B-API
function	O	B-API
in	O	O
python	O	O

All	O	O
globals	O	O
hold	O	B-API
either	O	O
values	O	B-API
referenced	O	O
by	O	O
those	O	O
tuples	O	O
or	O	O
are	O	O
lists	O	O
of	O	O
tuples	O	O
.	O	O

You	O	O
can	O	O
pass	O	O
a	O	O
list	O	B-API
or	O	O
an	O	O
array	O	B-API
as	O	O
indexes	O	O
to	O	O
any	O	B-API
np	O	O
array	O	B-API
.	O	O

The	O	O
array	O	B-API
I'm	O	O
using	O	O
is	O	O
quite	O	O
large	O	O
(	O	O
3500x3500	O	O
)	O	O
,	O	O
so	O	O
I'm	O	O
wondering	O	O
where	O	B-API
the	O	O
best	O	O
place	O	B-API
to	O	O
load	O	B-API
it	O	O
is	O	O
for	O	O
repeated	O	O
use	O	B-API
.	O	O

Basically	O	O
,	O	O
it	O	O
comes	O	O
down	O	O
to	O	O
checking	O	O
before	O	O
you	O	O
add	O	B-API
.	O	O

I	O	O
have	O	O
a	O	O
simple	O	O
function	O	B-API
called	O	O
get_gradient	O	O
which	O	O
takes	O	O
a	O	O
numpy	O	O
array	O	B-API
of	O	O
[[	O	O
x	O	O
,	O	O
y	O	O
,	O	O
Vx	O	O
,	O	O
Vy	O	O
]]	O	O
and	O	O
returns	O	O
(	O	O
should	O	O
return	O	O
)	O	O
an	O	O
array	O	B-API
of	O	O
[[	O	O
Vx	O	O
,	O	O
Vy	O	O
,	O	O
Ax	O	O
,	O	O
Ay	O	O
]]	O	O
.	O	O

I	O	O
found	O	O
this	O	O
post	O	O
:	O	O
Python	O	O
:	O	O
finding	O	O
an	O	O
element	O	O
in	O	O
an	O	O
array	O	B-API

So	O	O
,	O	O
are	O	O
VBOs	O	O
simply	O	O
not	O	O
meant	O	O
to	O	O
be	O	O
that	O	O
big	O	O
(	O	O
I	O	O
somehow	O	O
doubt	O	O
that	O	O
VBOs	O	O
could	O	O
only	O	O
have	O	O
around	O	B-API
17k	O	O
triangles	O	O
each	O	O
)	O	O
?	O	O

`	O	O
flags	O	B-API
`	O	O
parameter	O	O
leads	O	O
to	O	O
`	O	O
TypeError	O	O
`	O	O
if	O	O
input	O	O
array	O	B-API
is	O	O
not	O	O
contiguous	O	O
.	O	O

I	O	O
then	O	O
have	O	O
a	O	O
2nd	O	O
array	O	B-API
similar	O	O
to	O	O
#CODE	O	O

Convert	O	O
a	O	O
list	O	B-API
of	O	O
2D	O	O
numpy	O	O
arrays	O	O
to	O	O
one	O	O
3D	O	O
numpy	O	O
array	O	B-API
?	O	O

I'm	O	O
currently	O	O
a	O	O
grad	O	O
student	O	O
at	O	B-API
Harvard	O	O
and	O	O
a	O	O
good	O	O
friend	O	O
of	O	O
mine	O	O
went	O	O
there	O	O
(	O	O
he	O	O
would	O	O
have	O	O
graduated	O	O
two	O	O
or	O	O
three	O	O
years	O	O
ago	O	O
,	O	O
as	O	O
he	O	O
is	O	O
currently	O	O
a	O	O
second-year	O	O
grad	O	O
student	O	O
here	O	O
at	O	B-API
Harvard	O	O
with	O	O
me	O	O
)	O	O
.	O	O

I'm	O	O
not	O	O
clear	O	B-API
on	O	O
how	O	O
you	O	O
are	O	O
wanting	O	O
to	O	O
plot	O	B-API
it	O	O
,	O	O
but	O	O
it	O	O
sound	O	O
like	O	O
you'll	O	O
need	O	O
to	O	O
select	O	B-API
some	O	O
values	O	B-API
of	O	O
a	O	O
column	O	O
.	O	O

The	O	O
issue	O	O
I	O	O
am	O	O
running	O	O
in	O	O
to	O	O
is	O	O
that	O	O
the	O	O
array	O	B-API
can	O	O
be	O	O
larger	O	O
than	O	O
3gb	O	O
in	O	O
size	O	B-API
(	O	O
these	O	O
are	O	O
huge	O	O
images	O	O
)	O	O
and	O	O
I	O	O
need	O	O
to	O	O
segment	O	O
them	O	O
prior	O	O
to	O	O
ingesting	O	O
them	O	O
.	O	O

The	O	O
latter	O	O
might	O	O
be	O	O
faster	O	O
because	O	O
it	O	O
doesn't	O	O
produce	O	O
the	O	O
intermediate	O	O
`	O	O
x**2	O	O
`	O	O
array	O	B-API
.	O	O

Any	O	O
suggestions	O	O
?	O	O

"	O	O
A	O	O
copy	O	B-API
of	O	O
arr	O	O
with	O	O
the	O	O
elements	O	O
specified	O	O
by	O	O
obj	O	O
removed	O	O
.	O	O

is	O	O
not	O	O
it	O	O
another	O	O
copy	O	B-API
?	O	O

NOTE	O	O
:	O	O
the	O	O
row	O	O
has	O	O
"	O	O
:	O	O
"	O	O
,	O	O
but	O	O
the	O	O
"	O	O
:	O	O
"	O	O
does	O	O
mean	O	B-API
the	O	O
dict	O	O
'	O	O
:	O	O
'	O	O
.	O	O

If	O	O
,	O	O
for	O	O
some	O	O
reason	O	O
,	O	O
I	O	O
would	O	O
only	O	O
save	O	B-API
one	O	O
dictionary	O	O
then	O	O
every	O	O
script	O	O
loading	O	O
this	O	O
file	O	O
with	O	O
pickle	O	O
would	O	O
mess	O	O
up	O	O
the	O	O
order	O	B-API
of	O	O
the	O	O
stored	O	O
variables	O	O
.	O	O

You	O	O
might	O	O
also	O	O
want	O	O
to	O	O
take	O	B-API
a	O	O
look	O	O
at	O	B-API
Anvil	O	O
,	O	O
announcement	O	O
here	O	O
.	O	O

The	O	O
other	O	O
way	O	O
that	O	O
I	O	O
know	O	O
is	O	O
to	O	O
convert	O	B-API
Y	O	O
to	O	O
list	O	B-API
iteratively	O	O
.	O	O

This	O	O
is	O	O
especially	O	O
helpful	O	O
since	O	O
it	O	O
includes	O	O
the	O	O
import	O	O
commands	O	O
and	O	O
info	O	B-API
on	O	O
how	O	O
to	O	O
write	O	O
to	O	O
file	O	O
.	O	O

But	O	O
actually	O	O
I	O	O
am	O	O
not	O	O
so	O	O
sure	O	O
that	O	O
from	O	O
where	O	B-API
you	O	O
are	O	O
now	O	O
,	O	O
using	O	O
sparse	O	O
matrices	O	O
will	O	O
gain	O	O
you	O	O
any	O	B-API
speed-up	O	O
.	O	O

Upon	O	O
deeper	O	O
examination	O	O
of	O	O
the	O	O
relationship	O	O
between	O	B-API
the	O	O
python	O	O
printout	O	O
and	O	O
the	O	O
structure	O	O
of	O	O
my	O	O
underlying	O	O
data	O	B-API
,	O	O
I	O	O
see	O	O
that	O	O
the	O	O
python	O	O
print	O	O
command	O	O
is	O	O
saying	O	O
that	O	O
there	O	O
are	O	O
two	O	O
empty	O	B-API
columns	O	O
at	O	B-API
the	O	O
end	O	O
of	O	O
the	O	O
array	O	B-API
.	O	O

How	O	O
to	O	O
convert	O	B-API
a	O	O
simple	O	O
list	O	B-API
of	O	O
lists	O	O
into	O	O
a	O	O
numppy	O	O
array	O	B-API
?	O	O

Django	O	O
has	O	O
a	O	O
library	O	B-API
for	O	O
encapsulating	O	O
all	O	B-API
the	O	O
database	O	O
work	O	O
into	O	O
Python	O	O
classes	O	O
,	O	O
so	O	O
you	O	O
don't	O	O
have	O	O
to	O	O
mess	O	O
with	O	O
raw	O	O
SQL	O	O
until	O	O
you	O	O
have	O	O
to	O	O
do	O	O
something	O	O
really	O	O
clever	O	O
.	O	O

So	O	O
I	O	O
got	O	O
numpy	O	O
,	O	O
scipy	O	O
,	O	O
IPython	O	O
,	O	O
and	O	O
matplotlib	O	O
working	O	O
(	O	O
I	O	O
can	O	O
import	O	O
all	O	B-API
four	O	O
with	O	O
"	O	O
import	O	O
_	O	O
)"	O	O
.	O	O

@USER	O	O
`	O	O
new	O	O
type	O	O
not	O	O
compatible	O	O
with	O	O
array	O	B-API
.	O	O

Is	O	O
there	O	O
any	O	B-API
way	O	O
to	O	O
do	O	O
this	O	O
in	O	O
Python	O	O
?	O	O

Then	O	O
you	O	O
can	O	O
choose	O	B-API
many	O	O
methods	O	O
to	O	O
visualize	O	O
it	O	O
.	O	O

Numpy	O	O
Array	O	O
to	O	O
base64	O	O
and	O	O
back	O	B-API
to	O	O
Numpy	O	O
Array	O	O
-	O	O
Python	O	O

In	O	O
each	O	O
iteration	O	O
of	O	O
Gibbs	O	O
sampling	O	O
,	O	O
we	O	O
remove	O	B-API
one	O	O
(	O	O
current	O	O
)	O	O
word	O	O
,	O	O
sample	O	B-API
a	O	O
new	O	O
topic	O	O
for	O	O
that	O	O
word	O	O
according	O	O
to	O	O
a	O	O
posterior	O	O
conditional	O	O
probability	O	O
distribution	O	O
inferred	O	O
from	O	O
the	O	O
LDA	O	O
model	O	O
,	O	O
and	O	O
update	O	B-API
word-topic	O	O
counts	O	O
,	O	O
as	O	O
follows	O	O
:	O	O
#CODE	O	O

I	O	O
am	O	O
getting	O	O
weird	O	O
errors	O	O
when	O	O
I	O	O
try	O	O
to	O	O
convert	O	B-API
a	O	O
black	O	O
and	O	O
white	O	O
PIL	O	O
image	O	B-API
to	O	O
a	O	O
numpy	O	O
array	O	B-API
.	O	O

Numpy	O	O
arrays	O	O
have	O	O
a	O	O
`	O	O
copy	O	B-API
`	O	O
method	O	O
which	O	O
you	O	O
can	O	O
use	O	B-API
for	O	O
just	O	O
this	O	O
purpose	O	O
.	O	O

Actually	O	O
I	O	O
could	O	O
not	O	O
test	O	B-API
with	O	O
big	O	O
K	O	O
,	O	O
d	O	O
and	O	O
N	O	O
as	O	O
I	O	O
was	O	O
going	O	O
out	O	O
of	O	O
memory	O	O
.	O	O

With	O	O
all	O	B-API
of	O	O
these	O	O
options	O	O
you	O	O
have	O	O
to	O	O
pay	O	O
a	O	O
JNA	O	O
tax	O	O
...	O	O
all	O	B-API
of	O	O
your	O	O
data	O	B-API
has	O	O
to	O	O
be	O	O
copied	O	O
before	O	O
it	O	O
can	O	O
be	O	O
processed	O	O
.	O	O

Useless	O	O
because	O	O
it	O	O
ignores	O	O
the	O	O
"	O	O
cross	O	B-API
platform	O	O
issues	O	O
,	O	O
proprietary	O	O
tool	O	O
chains	O	O
,	O	O
certification	O	O
gates	O	O
,	O	O
licensed	O	O
technologies	O	O
,	O	O
and	O	O
stringent	O	O
performance	O	O
requirements	O	O
on	O	O
top	O	O
of	O	O
the	O	O
issues	O	O
with	O	O
legacy	O	O
codebases	O	O
and	O	O
workforce	O	O
availability	O	O
"	O	O
(	O	O
John	O	O
Carmack	O	O
)	O	O
that	O	O
op	O	O
is	O	O
probably	O	O
facing	O	O
.	O	O

And	O	O
that	O	O
the	O	O
values	O	B-API
of	O	O
all	O	B-API
(	O	O
x	O	O
,	O	O
y	O	O
)	O	O
pairs	O	O
are	O	O
given	O	O
.	O	O

Is	O	O
is	O	O
possible	O	O
to	O	O
have	O	O
a	O	O
3-D	O	O
record	O	B-API
array	O	B-API
in	O	O
numpy	O	O
?	O	O

However	O	O
,	O	O
the	O	O
evidence	O	O
suggests	O	O
that	O	O
you've	O	O
encountered	O	O
an	O	O
issue	O	O
of	O	O
this	O	O
sort	O	B-API
.	O	O

There's	O	O
_way_	O	O
less	O	B-API
overhead	O	O
this	O	O
way	O	O
.	O	O

I'm	O	O
having	O	O
trouble	O	O
figuring	O	O
out	O	O
what	O	O
kind	O	O
of	O	O
test	O	B-API
I	O	O
need	O	O
here	O	O
,	O	O
and	O	O
the	O	O
best	O	O
numpy	O	O
/	O	O
scipy	O	O
/	O	O
R	O	O
function	O	B-API
to	O	O
use	O	B-API
for	O	O
these	O	O
kinds	O	O
of	O	O
issues	O	O
.	O	O

I	O	O
have	O	O
see	O	O
people	O	O
using	O	O
dictionaries	O	O
,	O	O
but	O	O
the	O	O
arrays	O	O
are	O	O
large	O	O
and	O	O
filled	O	B-API
with	O	O
both	O	O
positive	O	O
and	O	O
negative	O	B-API
floats	O	O
.	O	O

How	O	O
can	O	O
I	O	O
speed	O	O
up	O	O
iteration	O	O
through	O	O
this	O	O
transformed	O	B-API
numpy	O	O
array	O	B-API
?	O	O

This	O	O
is	O	O
may	O	O
not	O	O
be	O	O
the	O	O
best	O	O
way	O	O
to	O	O
solve	O	B-API
this	O	O
but	O	O
have	O	O
a	O	O
look	O	O
at	O	B-API
the	O	O
following	O	O
...	O	O

All	O	O
in	O	O
all	O	B-API
,	O	O
I	O	O
would	O	O
go	O	O
with	O	O
the	O	O
#CODE	O	O

This	O	O
is	O	O
not	O	O
a	O	O
matter	O	O
of	O	O
style	O	B-API
.	O	O
without	O	O
the	O	O
list	O	B-API
(	O	O
_	O	O
)	O	O
it	O	O
does	O	O
not	O	O
even	O	O
work	O	O
at	O	B-API
last	O	B-API
for	O	O
the	O	O
case	O	O
i	O	O
have	O	O
that	O	O
y	O	O
is	O	O
an	O	O
array	O	B-API
itself	O	O

(	O	O
at	O	B-API
least	O	O
it	O	O
gives	O	O
me	O	O
an	O	O
error	O	O
stating	O	O
that	O	O
the	O	O
'	O	O
as	O	O
'	O	O
is	O	O
reserved	O	O
in	O	O
python	O	O
2.6	O	O
)	O	O
Am	O	O
I	O	O
correct	O	O
?	O	O

Did	O	O
you	O	O
try	O	O
looking	O	O
at	O	B-API
numpy	O	O
for	O	O
matlab	O	O
users	O	O
manuals	O	O
,	O	O
like	O	O
:	O	O
#URL	O	O

I	O	O
would	O	O
not	O	O
try	O	O
to	O	O
process	O	B-API
`	O	O
arr	O	O
`	O	O
in	O	O
place	O	B-API
-	O	O
it	O	O
seems	O	O
that	O	O
a	O	O
new	O	O
array	O	B-API
is	O	O
created	O	O
under	O	O
the	O	O
hood	O	O
in	O	O
most	O	O
cases	O	O
anyway	O	O
.	O	O

Now	O	O
you	O	O
must	O	O
initialize	O	O
each	O	O
element	O	O
of	O	O
the	O	O
numpy	O	O
array	O	B-API
to	O	O
be	O	O
an	O	O
1-d	O	O
numpy	O	O
array	O	B-API
:	O	O
#CODE	O	O

The	O	O
easiest	O	O
way	O	O
around	O	B-API
this	O	O
is	O	O
to	O	O
just	O	O
use	O	B-API
a	O	O
numpy	O	O
array	O	B-API
,	O	O
instead	O	O
of	O	O
a	O	O
numpy	O	O
matrix	O	B-API
:	O	O
#CODE	O	O

I	O	O
am	O	O
trying	O	O
to	O	O
create	O	O
an	O	O
affinity	O	O
matrix	O	B-API
for	O	O
an	O	O
image	O	B-API
.	O	O

to	O	O
handle	O	O
the	O	O
error	O	O
cases	O	O
and	O	O
the	O	O
return	O	O
value	O	O
,	O	O
they	O	O
are	O	O
not	O	O
related	O	O
to	O	O
the	O	O
array	O	B-API
assignment	O	O
.	O	O

Saving	O	O
a	O	O
Numpy	O	O
array	O	B-API
as	O	O
an	O	O
image	O	B-API
(	O	O
instructions	O	O
)	O	O

Using	O	O
this	O	O
,	O	O
I	O	O
know	O	O
I	O	O
am	O	O
calculating	O	O
r-squared	O	O
correctly	O	O
for	O	O
linear	O	O
best-fit	O	O
(	O	O
degree	O	B-API
equals	O	B-API
1	O	O
)	O	O
.	O	O

No	O	O
expert	O	O
on	O	O
the	O	O
topic	O	O
,	O	O
but	O	O
this	O	O
is	O	O
some	O	O
kind	O	O
of	O	O
adjency	O	O
matrix	O	B-API
(	O	O
#URL	O	O
)	O	O
.	O	O

about	O	O
15	O	O
times	O	O
faster	O	O
using	O	O
broadcast	O	B-API

Arrays	O	O
to	O	O
Matrix	O	O
numpy	O	O

but	O	O
it	O	O
appears	O	O
to	O	O
only	O	O
take	O	B-API
square	O	B-API
matrices	O	O
.	O	O

Any	O	O
idea	O	O
how	O	O
that	O	O
can	O	O
be	O	O
done	O	O
?	O	O

In	O	O
your	O	O
code	O	O
,	O	O
`	O	O
a	O	O
[	O	O
condition	O	O
]	O	O
[	O	O
index	O	B-API
]`	O	O
returns	O	O
the	O	O
value	O	O
in	O	O
a	O	O
,	O	O
but	O	O
I	O	O
want	O	O
the	O	O
INDEX	O	O
in	O	O
a	O	O
,	O	O
so	O	O
that	O	O
`	O	O
a	O	O
[	O	O
INDEX	O	O
]	O	O
=	O	O
a	O	O
[	O	O
condition	O	O
]	O	O
[	O	O
index	O	B-API
]`	O	O
.	O	O

Any	O	O
database	O	O
that	O	O
can	O	O
create	O	O
an	O	O
index	O	B-API
will	O	O
provide	O	O
relatively	O	O
fast	O	O
look-ups	O	O
(	O	O
depending	O	O
on	O	O
how	O	O
many	O	O
millions	O	O
of	O	O
records	O	O
you're	O	O
storing	O	O
)	O	O
.	O	O

Actually	O	O
,	O	O
the	O	O
best	O	O
way	O	O
to	O	O
manage	O	O
packages	O	O
on	O	O
OS	O	O
X	O	O
is	O	O
[	O	O
Homebrew	O	O
]	O	O
(	O	O
#URL	O	O
)	O	O
(	O	O
not	O	O
Fink	O	O
or	O	O
MacPorts	O	O
:))	O	O
-	O	O
which	O	O
unfortunately	O	O
lists	O	O
neither	O	O
NumPy	O	O
now	O	O
SciPy	O	O
at	O	B-API
the	O	O
current	O	O
time	O	B-API
.	O	O

I	O	O
would	O	O
like	O	O
to	O	O
keep	O	O
`	O	O
xcoords	O	O
`	O	O
a	O	O
numpy	O	O
array	O	B-API
if	O	O
possible	O	O
.	O	O
what	O	O
do	O	O
you	O	O
mean	O	B-API
'	O	O
adding	O	O
them	O	O
to	O	O
the	O	O
object	O	O
before	O	O
it	O	O
is	O	O
returned	O	O
'	O	O
?	O	O

But	O	O
I	O	O
just	O	O
need	O	O
to	O	O
sort	O	B-API
out	O	O
which	O	O
points	O	O
to	O	O
send	O	O
for	O	O
a	O	O
complete	O	O
graph	O	O
.	O	O

how	O	O
do	O	O
I	O	O
calculate	O	O
that	O	O
an	O	O
array	O	B-API
of	O	O
python	O	O
numpy	O	O
or	O	O
me	O	O
of	O	O
all	O	B-API
the	O	O
calculate	O	O
decimals	O	O
and	O	O
not	O	O
skip	O	O
like	O	O
.	O	O

It	O	O
will	O	O
support	O	O
it	O	O
on	O	O
the	O	O
next	O	B-API
release	O	B-API
.	O	O

Python	O	O
lists	O	O
are	O	O
defined	O	O
with	O	O
square	O	B-API
brackets	O	O
,	O	O
and	O	O
we	O	O
want	O	O
to	O	O
generate	O	O
a	O	O
list	O	B-API
of	O	O
lists	O	O
(	O	O
where	O	B-API
each	O	O
piece	O	O
contains	O	B-API
one	O	O
of	O	O
your	O	O
defined	O	O
segments	O	O
)	O	O
.	O	O

The	O	O
biggest	O	O
gotcha	O	O
for	O	O
me	O	O
was	O	O
that	O	O
almost	O	O
every	O	O
standard	O	O
operator	O	O
is	O	O
overloaded	O	O
to	O	O
distribute	O	O
across	O	O
the	O	O
array	O	B-API
.	O	O

I	O	O
want	O	O
to	O	O
combine	O	B-API
the	O	O
two	O	O
into	O	O
a	O	O
mutli-dimensional	O	O
numpy	O	O
array	O	B-API
.	O	O

where	O	B-API
`	O	O
nlooks	O	O
`	O	O
and	O	O
`	O	O
dfactor	O	O
`	O	O
are	O	O
scalars	O	O
and	O	O
`	O	O
Ic	O	O
`	O	O
is	O	O
the	O	O
unfiltered	O	O
array	O	B-API
.	O	O

In	O	O
a	O	O
10x5x5	O	O
matrix	O	B-API
with	O	O
`	O	O
x	O	O
[	O	O
0	O	O
,	O	O
:	O	O
,	O	O
:]	O	O
=	O	O
0	O	O
`	O	O
I	O	O
would	O	O
expect	O	O
a	O	O
result	O	O
of	O	O
:	O	O
#CODE	O	O

For	O	O
example	O	O
:	O	O
I	O	O
have	O	O
a	O	O
=	O	O
array	O	B-API
([	O	O
123	O	O
,	O	O
412	O	O
,	O	O
444	O	O
])	O	O

While	O	O
it	O	O
often	O	O
results	O	O
in	O	O
a	O	O
massive	O	O
speedup	O	O
to	O	O
eliminate	O	O
for	O	O
loops	O	O
and	O	O
take	O	B-API
advantage	O	O
of	O	O
numpy	O	O
built-ins	O	O
/	O	O
vectorization	O	O
.	O	O

If	O	O
I	O	O
understand	O	O
correctly	O	O
you	O	O
have	O	O
a	O	O
three	O	O
dimensional	O	O
array	O	B-API
,	O	O
something	O	O
like	O	O
:	O	O
#CODE	O	O

@USER	O	O
:	O	O
where	O	B-API
is	O	O
a	O	O
new	O	O
array	O	B-API
created	O	O
?	O	O

array	O	B-API
([	O	O
41	O	O
,	O	O
32	O	O
,	O	O
41	O	O
,	O	O
33	O	O
,	O	O
42	O	O
,	O	O
32	O	O
,	O	O
42	O	O
,	O	O
33	O	O
])	O	O

Any	O	O
idea	O	O
when	O	O
it	O	O
will	O	O
be	O	O
ready	O	O
?	O	O

I	O	O
see	O	O
you've	O	O
taken	O	O
care	O	O
of	O	O
my	O	O
edge	O	O
issues	O	O
,	O	O
although	O	O
your	O	O
filter	O	B-API
size	O	B-API
is	O	O
hardcoded	O	O
;)	O	O
.	O	O

If	O	O
you	O	O
open	O	B-API
idle	O	O
and	O	O
type	O	O
`	O	O
import	O	O
matplotlib	O	O
`	O	O
it	O	O
shouldn't	O	O
return	O	O
an	O	O
error	O	O

No	O	O
expert	O	O
on	O	O
the	O	O
topic	O	O
,	O	O
but	O	O
this	O	O
is	O	O
some	O	O
kind	O	O
of	O	O
adjency	O	O
matrix	O	B-API
(	O	O
#URL	O	O
)	O	O
.	O	O

Edit	O	O
:	O	O
If	O	O
it's	O	O
a	O	O
floating	O	O
point	O	O
issue	O	O
,	O	O
what	O	O
sort	O	B-API
of	O	O
floating	O	O
point	O	O
error	O	O
mistakes	O	O
a	O	O
number	O	O
much	O	O
less	O	B-API
than	O	O
1	O	O
as	O	O
one	O	O
around	O	B-API
8	O	O
?	O	O

The	O	O
question	O	O
was	O	O
about	O	O
how	O	O
to	O	O
slice	O	B-API
if	O	O
the	O	O
rank	O	B-API
is	O	O
not	O	O
known	O	O
at	O	B-API
the	O	O
time	O	B-API
I	O	O
write	O	O
the	O	O
code	O	O
.	O	O

I	O	O
think	O	O
a	O	O
typical	O	O
method	O	O
is	O	O
to	O	O
always	O	O
double	O	O
the	O	O
size	O	B-API
,	O	O
when	O	O
you	O	O
really	O	O
don't	O	O
know	O	O
how	O	O
large	O	O
things	O	O
will	O	O
be	O	O
.	O	O

This	O	O
script	O	O
is	O	O
mainly	O	O
intended	O	O
to	O	O
demonstrate	O	O
building	O	O
an	O	O
independent	O	O
python	O	O
in	O	O
your	O	O
home	O	B-API
directory	O	O
,	O	O
and	O	O
assumes	O	O
the	O	O
system	O	O
you're	O	O
building	O	O
on	O	O
has	O	O
the	O	O
proper	O	O
dependencies	O	O
already	O	O
installed	O	O
,	O	O
but	O	O
it	O	O
at	O	B-API
least	O	O
points	O	O
you	O	O
in	O	O
the	O	O
right	O	O
direction	O	O
.	O	O

and	O	O
use	O	B-API
the	O	O
information	O	O
on	O	O
the	O	O
size	O	B-API
inclued	O	O
in	O	O
the	O	O
filename	O	O
to	O	O
restore	O	O
the	O	O
initial	O	O
shape	O	B-API

Hmm	O	O
I	O	O
added	O	O
for	O	O
first	O	B-API
example	O	O
,	O	O
did	O	O
you	O	O
know	O	O
how	O	O
to	O	O
copy	O	B-API
from	O	O
IDE	O	O
exactly	O	O
with	O	O
commas	O	O
and	O	O
everything	O	O
..?	O	O

@USER	O	O
:	O	O
Your	O	O
answer	O	O
will	O	O
give	O	O
false	O	O
positives	O	O
in	O	O
the	O	O
event	O	O
that	O	O
one	O	O
or	O	O
more	O	O
(	O	O
but	O	O
not	O	O
all	O	B-API
)	O	O
of	O	O
the	O	O
elements	O	O
in	O	O
B	O	O
matches	O	O
with	O	O
one	O	O
of	O	O
the	O	O
rows	O	O
in	O	O
A	O	O
.	O	O

I	O	O
would	O	O
like	O	O
to	O	O
average	O	B-API
the	O	O
2	O	O
different	O	O
arrays	O	O
contained	O	O
within	O	O
`	O	O
record	O	B-API
`	O	O
.	O	O

I	O	O
need	O	O
to	O	O
constrained	O	O
minimization	O	O
of	O	O
some	O	O
data	O	B-API
(	O	O
ie	O	O
so	O	O
that	O	O
I	O	O
get	O	B-API
the	O	O
minimum	O	B-API
value	O	O
within	O	O
a	O	O
certain	O	O
range	O	O
)	O	O
.	O	O

In	O	O
this	O	O
case	O	O
,	O	O
I	O	O
would	O	O
like	O	O
to	O	O
return	O	O
the	O	O
index	O	B-API
2	O	O
(	O	O
2nd	O	O
row	O	O
)	O	O
.	O	O

a	O	O
32	O	O
bits	O	O
process	O	B-API
can	O	O
only	O	O
access	O	O
around	O	B-API
4	O	O
GB	O	O
of	O	O
memory	O	O
.	O	O

How	O	O
do	O	O
I	O	O
find	O	B-API
out	O	O
,	O	O
if	O	O
the	O	O
numpy	O	O
BLAS	O	O
libraries	O	O
are	O	O
availalbe	O	O
as	O	O
dynamically-loadable	O	O
?	O	O

(	O	O
they	O	O
are	O	O
at	O	B-API
same	O	O
scale	O	O
)	O	O

Now	O	O
simply	O	O
create	O	O
a	O	O
new	O	O
array	O	B-API
and	O	O
multiply	O	B-API
:	O	O
#CODE	O	O

Take	O	O
a	O	O
look	O	O
at	O	B-API
this	O	O
Project	O	O
Euler	O	O
problem	O	O
:	O	O
#URL	O	O

Python	O	O
:	O	O
how	O	O
to	O	O
store	O	O
a	O	O
numpy	O	O
multidimensional	O	O
array	O	B-API
in	O	O
PyTables	O	O
?	O	O

How	O	O
can	O	O
i	O	O
load	O	B-API
all	O	B-API
24	O	O
joblib	O	O
files	O	O
in	O	O
one	O	O
program	O	O
without	O	O
any	O	B-API
errors	O	O
?	O	O

Where	O	O
I'm	O	O
stuck	O	O
is	O	O
what	O	O
the	O	O
wrapper	O	O
code	O	O
should	O	O
then	O	O
look	O	O
like	O	O
to	O	O
pass	O	O
a	O	O
MxN	O	O
numpy	O	O
array	O	B-API
to	O	O
the	O	O
**	O	O
coords1	O	O
and	O	O
**	O	O
coords2	O	O
arguments	O	O
.	O	O

I	O	O
have	O	O
created	O	O
a	O	O
numpy	O	O
2d	O	O
array	O	B-API
of	O	O
type	O	O
string	O	O
called	O	O
'	O	O
minutes_array	O	O
'	O	O
with	O	O
the	O	O
first	O	B-API
column	O	O
as	O	O
unix	O	O
timestamps	O	O
rounded	O	O
to	O	O
the	O	O
nearest	O	O
minute	O	B-API
covering	O	O
every	O	O
minute	O	B-API
from	O	O
the	O	O
start	O	O
of	O	O
the	O	O
sensor	O	O
timeseries	O	O
to	O	O
the	O	O
end	O	O
with	O	O
three	O	O
empty	O	B-API
columns	O	O
to	O	O
be	O	O
filled	O	B-API
with	O	O
data	O	B-API
from	O	O
each	O	O
of	O	O
the	O	O
3	O	O
sensors	O	O
where	O	B-API
available	O	B-API
.	O	O

Which	O	O
can	O	O
be	O	O
done	O	O
in	O	O
O	O	O
(	O	O
n	O	O
)	O	O
,	O	O
but	O	O
your	O	O
answer	O	O
requires	O	O
O	O	O
(	O	O
mn	O	O
)	O	O
,	O	O
where	O	B-API
m	O	O
is	O	O
size	O	B-API
of	O	O
window	O	O
.	O	O

Somehow	O	O
I	O	O
always	O	O
thought	O	O
you	O	O
can	O	O
load	O	B-API
the	O	O
shared	O	O
library	O	B-API
compiled	O	O
with	O	O
any	O	B-API
compiler	O	O
.	O	O

`	O	O
array	O	B-API
=[	O	O
'	O	O
NaN	O	O
'	O	O
,	O	O
'	O	O
20	O	O
'	O	O
,	O	O
'	O	O
383.333	O	O
'	O	O
,	O	O
'	O	O
NaN	O	O
'	O	O
,	O	O
'	O	O
NaN	O	O
'	O	O
,	O	O
'	O	O
NaN	O	O
'	O	O
,	O	O
'	O	O
5	O	O
'	O	O
,	O	O
'	O	O
100	O	O
'	O	O
,	O	O
'	O	O
129	O	O
'	O	O
,	O	O
'	O	O
122.5	O	O
'	O	O
,	O	O
'	O	O
NaN	O	O
'	O	O
,	O	O
'	O	O
NaN	O	O
']`	O	O

array	O	B-API
,	O	O
and	O	O
then	O	O
use	O	B-API
`	O	O
view	O	B-API
`	O	O
to	O	O
turn	O	O
it	O	O
into	O	O
a	O	O
structured	O	O
array	O	B-API
,	O	O
and	O	O
then	O	O
use	O	B-API

and	O	O
so	O	O
all	O	B-API
we	O	O
need	O	O
to	O	O
do	O	O
is	O	O
:	O	O
#CODE	O	O

Any	O	O
clue	O	O
to	O	O
why	O	O
this	O	O
is	O	O
happening	O	O
?	O	O

I	O	O
think	O	O
the	O	O
definition	O	O
used	O	O
in	O	O
the	O	O
field	O	B-API
of	O	O
statistics	O	O
is	O	O
the	O	O
value	O	O
in	O	O
the	O	O
middle	O	O
of	O	O
your	O	O
data	O	B-API
array	O	B-API
after	O	O
it	O	O
has	O	O
been	O	O
sorted	O	O
.	O	O

Dense	O	O
covariance	O	O
matrices	O	O
of	O	O
that	O	O
size	O	B-API
suggest	O	O
operations	O	O
that	O	O
run	O	O
forever	O	O
!	O	O

In	O	O
this	O	O
case	O	O
,	O	O
I'd	O	O
like	O	O
it	O	O
to	O	O
return	O	O
a	O	O
density	O	O
that's	O	O
essentially	O	O
peaked	O	O
completely	O	O
at	O	B-API
a	O	O
difference	O	B-API
of	O	O
0	O	O
,	O	O
with	O	O
no	O	O
mass	O	O
everywhere	O	O
else	O	O
.	O	O

If	O	O
the	O	O
array	O	B-API
is	O	O
doubles	O	O
(	O	O
remember	O	O
python	O	O
floats	O	O
are	O	O
C	O	O
doubles	O	O
by	O	O
default	O	O
)	O	O
then	O	O
you	O	O
have	O	O
to	O	O
think	O	O
a	O	O
bit	O	O
harder	O	O
as	O	O
==	O	O
is	O	O
not	O	O
really	O	O
safe	O	O
or	O	O
what	O	O
you	O	O
want	O	O
for	O	O
floating	O	O
point	O	O
values	O	B-API
.	O	O

They	O	O
all	O	B-API
have	O	O
their	O	O
strengths	O	O
and	O	O
weaknesses	O	O
.	O	O

numpy	O	O
array	O	B-API
of	O	O
chars	O	O
to	O	O
string	O	O

matrix	O	B-API
rank	O	B-API
:	O	O
#CODE	O	O

This	O	O
slows	O	O
down	O	O
for	O	O
large	O	O
sigma	O	O
,	O	O
at	O	B-API
which	O	O
point	O	O
using	O	O
FFT-based	O	O
smoothing	O	O
might	O	O
be	O	O
faster	O	O
.	O	O

What	O	O
is	O	O
the	O	O
fastest	O	O
way	O	O
to	O	O
iterate	O	O
through	O	O
all	O	B-API
one	O	O
dimensional	O	O
sub-arrays	O	O
of	O	O
an	O	O
n	O	O
dimensional	O	O
array	O	B-API
in	O	O
python	O	O
.	O	O

This	O	O
works	O	O
,	O	O
but	O	O
it's	O	O
really	O	O
slow	O	B-API
.	O	O

If	O	O
I	O	O
create	O	O
a	O	O
simple	O	O
array	O	B-API
like	O	O
this	O	O
in	O	O
Python	O	O
I'm	O	O
able	O	O
to	O	O
read	O	O
the	O	O
values	O	B-API
in	O	O
the	O	O
C	O	O
code	O	O
:	O	O

In	O	O
an	O	O
ideal	O	O
world	O	O
,	O	O
the	O	O
function	O	B-API
or	O	O
class	O	O
would	O	O
support	O	O
overlap	O	O
between	O	B-API
the	O	O
divisions	O	O
in	O	O
the	O	O
input	O	O
matrix	O	B-API
too	O	O
.	O	O

My	O	O
problem	O	O
is	O	O
different	O	O
because	O	O
I	O	O
need	O	O
to	O	O
find	O	B-API
**	O	O
all	O	B-API
**	O	O
the	O	O
roots	O	B-API
of	O	O
my	O	O
function	O	B-API
,	O	O
on	O	O
a	O	O
given	O	O
interval	O	O
.	O	O

How	O	O
can	O	O
I	O	O
create	O	O
a	O	O
PyArrayObject	O	O
from	O	O
this	O	O
structure	O	O
,	O	O
specially	O	O
how	O	O
I	O	O
can	O	O
create	O	O
a	O	O
numpy	O	O
array	O	B-API
that	O	O
hold	O	B-API
3	O	O
object	O	O
(	O	O
off	O	O
course	O	O
3	O	O
is	O	O
an	O	O
example	O	O
here	O	O
)	O	O
(	O	O
each	O	O
of	O	O
them	O	O
is	O	O
an	O	O
array	O	B-API
)	O	O

x	O	O
:	O	O
a	O	O
numpy	O	O
2d	O	O
array	O	B-API

Thanks	O	O
for	O	O
the	O	O
info	O	B-API
.	O	O

How	O	O
would	O	O
you	O	O
avoid	O	O
the	O	O
loop	O	O
in	O	O
the	O	O
case	O	O
that	O	O
all	O	B-API
entries	O	O
in	O	O
`	O	O
repl	O	O
`	O	O
are	O	O
the	O	O
same	O	O
?	O	O

Pulling	O	O
data	O	B-API
from	O	O
a	O	O
numpy	O	O
array	O	B-API

There's	O	O
no	O	O
effective	O	O
difference	O	B-API
(	O	O
they	O	O
both	O	O
return	O	O
views	O	O
into	O	O
the	O	O
original	O	O
array	O	B-API
)	O	O
.	O	O

Thanks	O	O
for	O	O
all	O	B-API
the	O	O
tips	O	O
!	O	O

remove	O	B-API
zero	O	O
lines	O	B-API
2-D	O	O
numpy	O	O
array	O	B-API

Instead	O	O
of	O	O
using	O	O
`	O	O
PyInt_AsLong	O	O
`	O	O
,	O	O
use	O	B-API
the	O	O
`	O	O
PyArray_*	O	O
`	O	O
functions	O	O
provided	O	O
by	O	O
Numpy's	O	O
C	O	O
API	O	O
to	O	O
access	O	O
the	O	O
data	O	B-API
;	O	O
in	O	O
particular	O	O
,	O	O
see	O	O
section	O	O
Array	O	O
API	O	O
.	O	O

Well	O	O
,	O	O
I	O	O
tried	O	O
dividing	O	O
by	O	O
the	O	O
largest	O	O
place	O	B-API
value	O	O
.	O	O

All	O	O
of	O	O
those	O	O
numpys	O	O
are	O	O
linked	O	O
to	O	O
the	O	O
system	O	O
Accelerate	O	O
framework	O	O
:	O	O
#CODE	O	O

and	O	O
I	O	O
wish	O	O
to	O	O
create	O	O
a	O	O
third	O	O
array	O	B-API
with	O	O
each	O	O
element	O	O
from	O	O
`	O	O
b	O	O
`	O	O
appearing	O	O
`	O	O
a	O	O
`	O	O
times	O	O
in	O	O
the	O	O
new	O	O
array	O	B-API
,	O	O
as	O	O
:	O	O
#CODE	O	O

I	O	O
can	O	O
imagine	O	O
a	O	O
number	O	O
of	O	O
approaches	O	O
to	O	O
storing	O	O
both	O	O
of	O	O
these	O	O
data	O	B-API
formats	O	O
,	O	O
ranging	O	O
from	O	O
storing	O	O
the	O	O
metadata	O	O
with	O	O
the	O	O
`	O	O
AttributeSet	O	O
`	O	O
class	O	O
for	O	O
each	O	O
`	O	O
Array	O	O
`	O	O
/	O	O
`	O	O
CArray	O	O
`	O	O
to	O	O
using	O	O
a	O	O
`	O	O
Table	O	O
`	O	O
for	O	O
all	O	B-API
of	O	O
the	O	O
metadata	O	O
.	O	O

I	O	O
want	O	O
to	O	O
calculate	O	O
the	O	O
average	O	B-API
of	O	O
four	O	O
neighbors	O	O
in	O	O
a	O	O
huge	O	O
array	O	B-API
.	O	O

Suppress	O	O
Scientific	O	O
Notation	O	O
in	O	O
Numpy	O	O
When	O	O
Creating	O	O
Array	O	O
From	O	O
Nested	O	O
List	O	B-API

I	O	O
want	O	O
to	O	O
find	O	B-API
the	O	O
vector	O	O
x	O	O
'	O	O
such	O	O
that	O	O
Ax	O	O
'	O	O
is	O	O
as	O	O
close	O	B-API
as	O	O
possible	O	O
to	O	O

And	O	O
the	O	O
dataset	O	O
in	O	O
question	O	O
is	O	O
beyond	O	O
doubt	O	O
particular	O	O
:	O	O
There	O	O
certainly	O	O
is	O	O
an	O	O
upper	O	B-API
bound	O	O
and	O	O
a	O	O
precision	O	O
.	O	O

Only	O	O
integers	O	O
can	O	O
be	O	O
used	O	O
as	O	O
array	O	B-API
or	O	O
matrix	O	B-API
indices	O	B-API
.	O	O

I	O	O
can't	O	O
find	O	B-API
it	O	O
online	O	O
anywhere	O	O
.	O	O

I	O	O
will	O	O
try	O	O
your	O	O
code	O	O
,	O	O
but	O	O
I	O	O
am	O	O
also	O	O
going	O	O
to	O	O
try	O	O
writing	O	O
a	O	O
simple	O	O
C	O	O
extension	O	O
to	O	O
simply	O	O
do	O	O
the	O	O
reading	O	O
,	O	O
math	O	B-API
,	O	O
and	O	O
drawing	O	O
all	O	B-API
in	O	O
one	O	O
place	O	B-API
.	O	O

Are	O	O
there	O	O
any	O	B-API
good	O	O
greedy	O	O
implementations	O	O
to	O	O
solve	O	B-API
this	O	O
or	O	O
am	O	O
I	O	O
on	O	O
my	O	O
own	O	O
to	O	O
implement	O	O
this	O	O
?	O	O

The	O	O
problem	O	O
is	O	O
that	O	O
for	O	O
the	O	O
array	O	B-API
input	O	O
,	O	O
SWIG	O	O
complains	O	O
that	O	O
there	O	O
is	O	O
no	O	O
typemap	O	O
.	O	O

Is	O	O
`	O	O
column_array_to_add	O	O
`	O	O
another	O	O
2D	O	O
array	O	B-API
,	O	O
or	O	O
is	O	O
it	O	O
a	O	O
1D	O	O
column	O	O
array	O	B-API
,	O	O
as	O	O
the	O	O
name	O	B-API
implies	O	O
?	O	O

the	O	O
sum	O	B-API
of	O	O
a	O	O
triple-product	O	O
(	O	O
element-wise	O	O
)	O	O
.	O	O

I	O	O
ran	O	O
a	O	O
simple	O	O
speed	O	O
test	O	B-API
comparing	O	O
numpy	O	O
and	O	O
python	O	O
list	O	B-API
comprehension	O	O
,	O	O
and	O	O
apparently	O	O
list	O	B-API
comprehension	O	O
was	O	O
faster	O	O
.	O	O

That	O	O
is	O	O
why	O	O
your	O	O
sample	O	B-API
loop	O	O
has	O	O
been	O	O
collapsed	O	O
to	O	O
read	O	O
in	O	O
the	O	O
full	O	B-API
sample	O	B-API
for	O	O
the	O	O
receiver	O	O
and	O	O
channel	O	O
in	O	O
one	O	O
large	O	O
read	O	O
.	O	O

Something	O	O
like	O	O
the	O	O
following	O	O
iterator	O	O
should	O	O
get	O	B-API
around	O	B-API
both	O	O
of	O	O
these	O	O
problems	O	O
:	O	O
#CODE	O	O

I	O	O
appreciate	O	O
any	O	B-API
input	O	O
on	O	O
this	O	O
...	O	O

Do	O	O
you	O	O
really	O	O
need	O	O
to	O	O
find	O	B-API
such	O	O
a	O	O
weird	O	O
thing	O	O
?	O	O

Any	O	O
particular	O	O
reason	O	O
you	O	O
don't	O	O
want	O	O
to	O	O
use	O	B-API
a	O	O
straightforward	O	O
approach	O	O
?	O	O

The	O	O
advantage	O	O
of	O	O
numpy	O	O
is	O	O
the	O	O
support	O	O
of	O	O
slicing	O	O
at	O	B-API
different	O	O
levels	O	O
.	O	O

An	O	O
implementation	O	O
,	O	O
however	O	O
,	O	O
is	O	O
not	O	O
really	O	O
open	O	B-API
to	O	O
interpretation	O	O
.	O	O

Python	O	O
numpy	O	O
masked	O	B-API
array	O	B-API
initialization	O	O

You	O	O
can	O	O
further	O	O
optimize	O	O
by	O	O
exploiting	O	O
array-order	O	O
alignment	O	O
to	O	O
reduce	O	B-API
excess	O	O
memory	O	O
consumption	O	O
caused	O	O
by	O	O
copying	O	O
the	O	O
original	O	O
arrays	O	O
.	O	O

For	O	O
example	O	O
,	O	O
any	O	B-API
vector	O	O
(	O	O
of	O	O
the	O	O
appropriate	O	O
dimension	O	O
)	O	O
can	O	O
be	O	O
an	O	O
eigenvector	O	O
of	O	O
the	O	O
identity	O	B-API
matrix	O	B-API
.	O	O

The	O	O
normal	O	B-API
64-bit	O	O
double-precision	O	O
floating	O	O
point	O	O
has	O	O
least	O	O
positive	O	O
normal	O	B-API
value	O	O
2.2E-308	O	O
;	O	O
storing	O	O
logs	O	O
gives	O	O
you	O	O
an	O	O
effective	O	O
least	O	O
positive	O	O
normal	O	B-API
1E-	O	O
(	O	O
1.7E308	O	O
)	O	O
.	O	O

index	O	B-API
set	O	B-API
for	O	O
each	O	O
position	O	O
in	O	O
the	O	O
index	O	B-API
arrays	O	O
.	O	O

I	O	O
am	O	O
wondering	O	O
if	O	O
reassigning	O	O
temp	O	O
[	O	O
]	O	O
to	O	O
a	O	O
1-element	O	O
shorter	O	O
vector	O	O
each	O	O
time	O	B-API
is	O	O
slow	O	B-API
,	O	O
would	O	O
it	O	O
be	O	O
faster	O	O
to	O	O
pre-allocate	O	O
a	O	O
96-3	O	O
length	O	O
list	O	B-API
of	O	O
vectors	O	O
of	O	O
length	O	O
96	O	O
,	O	O
95	O	O
,	O	O
94	O	O
...	O	O
to	O	O
3	O	O
?	O	O

What	O	O
would	O	O
we	O	O
do	O	O
,	O	O
if	O	O
we	O	O
wanted	O	O
to	O	O
change	O	O
values	O	B-API
at	O	B-API
indexes	O	O
which	O	O
are	O	O
multiple	O	O
of	O	O
given	O	O
n	O	O
,	O	O
like	O	O
a	O	O
[	O	O
2	O	O
]	O	O
,	O	O
a	O	O
[	O	O
4	O	O
]	O	O
,	O	O
a	O	O
[	O	O
6	O	O
]	O	O
,	O	O
a	O	O
[8	O	O
]	O	O
.....	O	O
for	O	O
n=2	O	O
?	O	O

Thanks	O	O
for	O	O
all	O	B-API
the	O	O
python	O	O
guidance	O	O
!	O	O

I'm	O	O
not	O	O
really	O	O
pro	O	O
Matlab	O	O
,	O	O
but	O	O
surely	O	O
Stata	O	O
can't	O	O
be	O	O
so	O	O
bad	O	O
as	O	O
to	O	O
require	O	B-API
`	O	O
adoedit	O	O
`	O	O
just	O	O
to	O	O
know	O	O
what	O	O
algorithm	O	O
it	O	O
is	O	O
using	O	O
?	O	O

This	O	O
can	O	O
be	O	O
found	O	O
relatively	O	O
easily	O	O
by	O	O
just	O	O
looking	O	O
at	O	B-API
points	O	O
where	O	B-API
the	O	O
potential	O	O
exceeds	O	O
a	O	O
certain	O	O
threshold	O	O
.	O	O

Negative	O	O
indices	O	B-API
are	O	O
interpreted	O	O
as	O	O
counting	O	O
from	O	O
the	O	O
end	O	O
of	O	O
the	O	O
array	O	B-API

I	O	O
was	O	O
using	O	O
unsigned	O	O
int	O	O
indices	O	B-API
to	O	O
speed	O	O
up	O	O
access	O	O
according	O	O
to	O	O
:	O	O
#URL	O	O

I've	O	O
tried	O	O
to	O	O
vectorise	O	O
it	O	O
using	O	O
numpy	O	O
but	O	O
I'm	O	O
not	O	O
really	O	O
sure	O	O
how	O	O
to	O	O
do	O	O
it	O	O
given	O	O
that	O	O
the	O	O
matrix	O	B-API
/	O	O
2D	O	O
array	O	B-API
gets	O	O
changed	O	B-API
on	O	O
each	O	O
iteration	O	O
.	O	O

Numpy	O	O
slicing	O	O
x	O	O
,	O	O
y	O	O
,	O	O
z	O	O
array	O	B-API
for	O	O
variable	O	O
z	O	O

I	O	O
would	O	O
like	O	O
to	O	O
convert	O	B-API
(	O	O
a	O	O
more	O	O
complicated	O	O
form	O	O
of	O	O
)	O	O
the	O	O
follwing	O	O
Matlab	O	O
code	O	O
#CODE	O	O

I	O	O
have	O	O
a	O	O
NumPy	O	O
array	O	B-API
'	O	O
boolarr	O	O
'	O	O
of	O	O
boolean	O	O
type	O	O
.	O	O

If	O	O
you	O	O
have	O	O
only	O	O
integers	O	O
that	O	O
are	O	O
between	O	B-API
0	O	O
and	O	O
n	O	O
(	O	O
if	O	O
not	O	O
its	O	O
no	O	O
problem	O	O
to	O	O
generalize	O	O
to	O	O
any	O	B-API
integer	O	O
range	O	O
unless	O	O
its	O	O
very	O	O
sparse	O	O
)	O	O
,	O	O
the	O	O
most	O	O
efficient	O	O
way	O	O
is	O	O
the	O	O
use	O	B-API
of	O	O
take	O	B-API
/	O	O
fancy	O	O
indexing	O	O
:	O	O
#CODE	O	O

Instead	O	O
of	O	O
2D	O	O
coordinates	O	O
,	O	O
I	O	O
use	O	B-API
index	O	B-API
for	O	O
every	O	O
elements	O	O
in	O	O
the	O	O
matrix	O	B-API
.	O	O

I	O	O
already	O	O
tried	O	O
converting	O	O
the	O	O
cols	O	O
to	O	O
int	O	O
but	O	O
that	O	O
didn't	O	O
solve	O	B-API
it	O	O
.	O	O

Although	O	O
I'm	O	O
sure	O	O
there	O	O
are	O	O
methods	O	O
for	O	O
applying	O	O
RK	O	O
to	O	O
an	O	O
equation	O	O
such	O	O
as	O	O
this	O	O
,	O	O
I	O	O
didn't	O	O
find	O	B-API
any	O	B-API
evidence	O	O
of	O	O
them	O	O
in	O	O
_Numerical	O	O
Recipes_	O	O
,	O	O
which	O	O
I	O	O
think	O	O
qualifies	O	O
that	O	O
topic	O	O
as	O	O
relatively	O	O
obscure	O	O
;-)	O	O

When	O	O
facing	O	O
a	O	O
big	O	O
computation	O	O
,	O	O
it	O	O
will	O	O
run	O	O
tests	O	O
using	O	O
several	O	O
implementations	O	O
to	O	O
find	O	B-API
out	O	O
which	O	O
is	O	O
the	O	O
fastest	O	O
one	O	O
on	O	O
our	O	O
computer	O	O
at	O	B-API
this	O	O
moment	O	O
.	O	O

Use	O	O
an	O	O
array	O	B-API
of	O	O
floating	O	O
point	O	O
numbers	O	O
instead	O	O
.	O	O

`	O	O
numpy	O	O
`	O	O
slicing	O	O
operations	O	O
probably	O	O
involve	O	O
`	O	O
for	O	O
`	O	O
loops	O	O
at	O	B-API
some	O	O
level	O	O
,	O	O
but	O	O
they're	O	O
implemented	O	O
in	O	O
c	O	O
,	O	O
and	O	O
provide	O	O
a	O	O
linear	O	O
time	O	B-API
solution	O	O
for	O	O
this	O	O
.	O	O

I	O	O
have	O	O
one	O	O
question	O	O
:	O	O
Is	O	O
there	O	O
only	O	O
one	O	O
way	O	O
to	O	O
do	O	O
addition	O	O
of	O	O
two	O	O
matrix	O	B-API
?	O	O

@USER	O	O
It	O	O
is	O	O
now	O	O
supported	O	O
,	O	O
at	O	B-API
least	O	O
in	O	O
my	O	O
version	O	O
(	O	O
1.7.1	O	O
)	O	O
.	O	O

I	O	O
know	O	O
I	O	O
could	O	O
start	O	O
a	O	O
number	O	O
of	O	O
times	O	O
at	O	B-API
random	O	B-API
locations	O	O
but	O	O
I'm	O	O
not	O	O
able	O	O
to	O	O
do	O	O
that	O	O
with	O	O
what	O	O
I	O	O
am	O	O
currently	O	O
working	O	O
on	O	O
and	O	O
have	O	O
to	O	O
use	O	B-API
on	O	O
of	O	O
these	O	O
minimisers	O	O
out	O	O
of	O	O
the	O	O
box	O	B-API
.	O	O

For	O	O
small	O	O
displacements	O	O
of	O	O
around	O	B-API
4-5	O	O
pixels	O	O
,	O	O
the	O	O
direction	O	O
of	O	O
vector	O	O
calculated	O	O
seems	O	O
to	O	O
be	O	O
fine	O	O
,	O	O
but	O	O
the	O	O
magnitude	O	O
of	O	O
the	O	O
vector	O	O
is	O	O
too	O	O
small	O	O
(	O	O
that's	O	O
why	O	O
I	O	O
had	O	O
to	O	O
multiply	O	B-API
u	O	O
,	O	O
v	O	O
by	O	O
3	O	O
before	O	O
plotting	O	B-API
them	O	O
)	O	O
.	O	O

However	O	O
,	O	O
I	O	O
will	O	O
need	O	O
to	O	O
access	O	O
all	O	B-API
waveforms	O	O
at	O	B-API
some	O	O
point	O	O
.	O	O

I've	O	O
find	O	B-API
this	O	O
:	O	O
#URL	O	O
but	O	O
when	O	O
I	O	O
try	O	O
to	O	O
install	O	O
this	O	O
I	O	O
get	O	B-API
an	O	O
error	O	O
:	O	O
#CODE	O	O

yes	O	O
,	O	O
I	O	O
can	O	O
assume	O	O
either	O	O
that	O	O
I	O	O
have	O	O
g	O	O
explicitly	O	O
or	O	O
that	O	O
I	O	O
can	O	O
sample	O	B-API
x	O	O
according	O	O
to	O	O
g	O	O
.	O	O

`	O	O
example	O	O
`	O	O
is	O	O
a	O	O
structured	O	O
array	O	B-API
consisting	O	O
of	O	O
two	O	O
elements	O	O
(	O	O
`	O	O
(	O	O
1	O	O
,	O	O
2	O	O
,	O	O
3	O	O
)`	O	O
and	O	O
`	O	O
(	O	O
4	O	O
,	O	O
5	O	O
,	O	O
6	O	O
)`)	O	O
,	O	O
each	O	O
element	O	O
(	O	O
or	O	O
'	O	O
record	O	B-API
')	O	O
having	O	O
3	O	O
fields	O	O
.	O	O

If	O	O
i	O	O
have	O	O
two	O	O
variables	O	O
-	O	O
where	O	B-API
they	O	O
either	O	O
are	O	O
a	O	O
1d	O	O
array	O	B-API
of	O	O
values	O	B-API
length	O	O
n	O	O
,	O	O
or	O	O
are	O	O
a	O	O
single	O	O
value	O	O
,	O	O
how	O	O
do	O	O
i	O	O
loop	O	O
through	O	O
them	O	O
so	O	O
that	O	O
I	O	O
get	O	B-API
n	O	O
values	O	B-API
returned	O	O
.	O	O

For	O	O
each	O	O
point	O	O
in	O	O
array	O	B-API
A	O	O
,	O	O
I	O	O
need	O	O
to	O	O
find	O	B-API
how	O	O
many	O	O
points	O	O
in	O	O
array	O	B-API
B	O	O
are	O	O
within	O	O
a	O	O
certain	O	O
distance	O	O
of	O	O
it	O	O
.	O	O

It	O	O
does	O	O
,	O	O
but	O	O
somehow	O	O
it	O	O
is	O	O
8	O	O
times	O	O
slower	O	O
than	O	O
copying	O	O
to	O	O
numpy	O	O
array	O	B-API
:(	O	O
I	O	O
suppose	O	O
the	O	O
regular	O	O
python	O	O
overhead	O	O
slows	O	O
things	O	O
down	O	O
much	O	O
more	O	O
than	O	O
a	O	O
copy	O	B-API
...	O	O

It	O	O
all	O	B-API
depends	O	O
on	O	O
its	O	O
dependencies	O	O
.	O	O

Is	O	O
there	O	O
a	O	O
way	O	O
to	O	O
make	O	O
an	O	O
array	O	B-API
of	O	O
such	O	O
strings	O	O
?	O	O

`	O	O
grid	O	B-API
[	O	O
1	O	O
]`	O	O
can	O	O
be	O	O
used	O	O
as	O	O
a	O	O
proxy	O	O
for	O	O
the	O	O
index	O	B-API
`	O	O
j	O	O
`	O	O
.	O	O

After	O	O
doing	O	O
so	O	O
,	O	O
I	O	O
discovered	O	O
that	O	O
if	O	O
I	O	O
tried	O	O
to	O	O
open	O	B-API
the	O	O
IPython	O	O
HTML	O	O
Notebook	O	O
I	O	O
got	O	O
the	O	O
error	O	O
message	O	O
:	O	O
#CODE	O	O

(	O	O
the	O	O
new	O	O
matrix	O	B-API
would	O	O
have	O	O
n-2	O	O
rows	O	O
m-2	O	O
columns	O	O
)	O	O
.	O	O

and	O	O
duplicate	O	O
index	O	B-API
values	O	B-API
at	O	B-API
the	O	O
correpsonding	O	O
sites	O	O
within	O	O

I	O	O
found	O	O
that	O	O
the	O	O
best	O	O
way	O	O
to	O	O
produce	O	O
small	O	O
pdf	O	O
files	O	O
is	O	O
to	O	O
save	O	B-API
as	O	O
eps	O	O
in	O	O
matplotlib	O	O
and	O	O
then	O	O
use	O	B-API
epstopdf	O	O
.	O	O

You	O	O
could	O	O
rearrange	O	O
the	O	O
image	O	B-API
to	O	O
put	O	B-API
the	O	O
(	O	O
0	O	O
,	O	O
0	O	O
)	O	O
in	O	O
the	O	O
middle	O	O
with	O	O
some	O	O
matrix	O	B-API
manipulation	O	O
.	O	O

Please	O	O
,	O	O
see	O	O
the	O	O
next	O	B-API
example	O	O
:	O	O

A	O	O
function	O	B-API
that	O	O
broadcasts	O	O
a	O	O
scalar	O	O
operation	O	O
over	O	B-API
an	O	O
array	O	B-API
is	O	O
called	O	O
a	O	O
universal	O	O
function	O	B-API
,	O	O
or	O	O
ufunc	O	O
.	O	O

may	O	O
not	O	O
exist	O	O
until	O	O
the	O	O
datasets	O	O
get	O	B-API
quite	O	O
big	O	O
(	O	O
maybe	O	O
you'll	O	O
need	O	O
at	O	B-API
least	O	O
10,000	O	O
rows	O	O
per	O	O
data	O	B-API
set	O	B-API
)	O	O
.	O	O

Magic	O	O
answers	O	O
like	O	O
this	O	O
are	O	O
not	O	O
really	O	O
helpful	O	O
because	O	O
they	O	O
don't	O	O
solve	O	B-API
the	O	O
problem	O	O
.	O	O

I	O	O
think	O	O
what	O	O
I	O	O
was	O	O
missing	O	O
is	O	O
that	O	O
I	O	O
really	O	O
have	O	O
a	O	O
3	O	O
dimensional	O	O
array	O	B-API
,	O	O
48x365x3	O	O
.	O	O

I	O	O
load	O	B-API
a	O	O
some	O	O
machine	O	O
learning	O	O
data	O	B-API
from	O	O
a	O	O
csv	O	O
file	O	O
.	O	O

So	O	O
I	O	O
have	O	O
it	O	O
running	O	O
(	O	O
or	O	O
at	O	B-API
least	O	O
that	O	O
assignment	O	O
isn't	O	O
throwing	O	O
an	O	O
error	O	O
and	O	O
it's	O	O
compiling	O	O
)	O	O
!	O	O

@USER	O	O
The	O	O
first	O	B-API
function	O	B-API
is	O	O
taking	O	O
chunks	O	O
of	O	O
200	O	O
items	O	O
from	O	O
your	O	O
huge	O	O
array	O	B-API
,	O	O
and	O	O
copying	O	O
those	O	O
chunks	O	O
to	O	O
a	O	O
new	O	O
,	O	O
even	O	O
more	O	O
ginormous	O	O
array	O	B-API
.	O	O

@USER	O	O
:	O	O
With	O	O
`	O	O
where	O	B-API
`	O	O
it	O	O
looks	O	O
definitely	O	O
nice	O	O
,	O	O
but	O	O
have	O	O
you	O	O
consider	O	O
also	O	O
the	O	O
implications	O	O
to	O	O
performance	O	O
when	O	O
implementing	O	O
with	O	O
`	O	O
where	O	B-API
`	O	O
?	O	O

Anyone	O	O
any	O	B-API
idea	O	O
what	O	O
this	O	O
means	O	O
?!	O	O

Assuming	O	O
you	O	O
are	O	O
using	O	O
g++	O	O
to	O	O
compile	O	O
...	O	O
have	O	O
you	O	O
had	O	O
different	O	O
results	O	O
in	O	O
any	O	B-API
way	O	O
when	O	O
experimenting	O	O
with	O	O
compiler	O	O
optimization	O	O
flags	O	B-API
?	O	O

With	O	O
the	O	O
overhead	O	O
of	O	O
the	O	O
data	O	B-API
structure	O	O
you	O	O
could	O	O
be	O	O
looking	O	O
at	O	B-API
usage	O	O
much	O	O
higher	O	O
than	O	O
that	O	O
--	O	O
I	O	O
can't	O	O
say	O	O
how	O	O
much	O	O
because	O	O
I	O	O
don't	O	O
know	O	O
the	O	O
memory	O	O
model	O	O
behind	O	O
SciPy	O	O
/	O	O
numpy	O	O
.	O	O

I	O	O
have	O	O
serious	O	O
doubt	O	O
that	O	O
adding	O	O
two	O	O
numpy	O	O
arrays	O	O
is	O	O
a	O	O
bottleneck	O	O
that	O	O
you	O	O
can	O	O
solve	O	B-API
rewriting	O	O
things	O	O
in	O	O
C	O	O
.	O	O

Where	O	O
exactly	O	O
is	O	O
the	O	O
error	O	O
occurring	O	O
?	O	O

I	O	O
frequently	O	O
convert	O	B-API
16-bit	O	O
grayscale	O	O
image	O	B-API
data	O	B-API
to	O	O
8-b	O	O
it	O	O
image	O	B-API
data	O	B-API
for	O	O
display	O	O
.	O	O

Reduce	O	O
it	O	O
to	O	O
a	O	O
1	O	O
/	O	O
10	O	O
resolution	O	B-API
,	O	O
find	O	B-API
the	O	O
one	O	O
white	O	O
pixel	O	O
,	O	O
and	O	O
then	O	O
you	O	O
have	O	O
a	O	O
precise	O	O
idea	O	O
of	O	O
where	O	B-API
to	O	O
search	O	O
for	O	O
the	O	O
centroid	O	O
.	O	O

I	O	O
ran	O	O
a	O	O
test	O	B-API
to	O	O
compare	O	O
the	O	O
times	O	O
,	O	O
and	O	O
found	O	O
that	O	O
my	O	O
method	O	O
is	O	O
faster	O	O
by	O	O
quite	O	O
a	O	O
bit	O	O
,	O	O
but	O	O
Freddie	O	O
Witherdon	O	O
'	O	O
s	O	O
suggestion	O	O
is	O	O
even	O	O
faster	O	O
.	O	O

I	O	O
couldn't	O	O
find	O	B-API
it	O	O
in	O	O
the	O	O
OLS	O	O
recipe	O	O
(	O	O
#URL	O	O
)	O	O
.	O	O

convert	O	B-API
binary	O	O
string	O	O
to	O	O
numpy	O	O
array	O	B-API

How	O	O
to	O	O
know	O	O
where	O	B-API
warning	O	O
come	O	O
from	O	O
in	O	O
Python	O	O

