Rolling	B-API
median	B-API
in	O
python	O

I	O
need	O
to	O
be	O
able	O
to	O
insert	B-API
these	O
values	O
into	O
a	O
python	O
list	O
and	O
get	O
a	O
median	B-API
for	O
the	O
last	O
30	O
closes	O
.	O

It	O
would	O
be	O
more	O
efficient	O
to	O
do	O
the	O
median	B-API
of	O
the	O
last	O
29	O
values	O
.	O

isn't	O
the	O
median	B-API
just	O
the	O
middle	O
value	O
in	O
a	O
sorted	O
range	O
?	O

For	O
an	O
list	O
with	O
an	O
even	O
number	O
of	O
values	O
the	O
median	B-API
is	O
the	O
mean	O
of	O
the	O
two	O
middle	O
values	O
.	O

so	O
you	O
could	O
grab	O
daily	O
close	O
prices	O
,	O
their	O
rolling	B-API
means	O
,	O
etc	O
...	O
then	O
timestamp	O
every	O
calculation	O
,	O
and	O
get	O
all	O
this	O
stored	O
in	O
something	O
similar	O
to	O
a	O
python	O
dictionary	O
(	O
see	O
the	O
`	O
pandas.DataFrame	B-API
`	O
class	O
)	O
...	O
then	O
you	O
access	O
slices	O
of	O
the	O
data	O
as	O
simply	O
as	O
:	O
#CODE	O

See	O
the	O
pandas	O
rolling	B-API
moments	O
doc	O
for	O
more	O
information	O
on	O
to	O
calculate	O
the	O
rolling	B-API
stdev	O
(	O
it's	O
a	O
one-liner	O
)	O
.	O

@USER	O
Pennington	O
:	O
couponded	O
is	O
an	O
array	O
in	O
this	O
case	O
and	O
has	O
no	O
shift	B-API
method	O
...	O

@USER	O
Pennington	O
:	O
Done	O
,	O
sorry	O
,	O
new	O
to	O
Stack	B-API
:)	O

b	O
)	O
strip	B-API
the	O
seconds	O
out	O
of	O
python	O
datetime	O
objects	O
(	O
Set	O
seconds	O
to	O
00	O
,	O
without	O
changing	O
minutes	O
)	O
.	O

You	O
have	O
a	O
number	O
of	O
options	O
using	O
pandas	O
,	O
but	O
you	O
have	O
to	O
make	O
a	O
decision	O
about	O
how	O
it	O
makes	O
sense	O
to	O
align	B-API
the	O
data	O
given	O
that	O
they	O
don't	O
occur	O
at	O
the	O
same	O
instants	O
.	O

The	O
`	O
reindex	B-API
`	O
function	O
enables	O
you	O
to	O
align	B-API
data	O
while	O
filling	O
forward	O
values	O
(	O
getting	O
the	O
"	O
as	O
of	O
"	O
value	O
):	O
#CODE	O

I	O
try	O
to	O
merge	B-API
dataframes	O
by	O
rows	O
doing	O
:	O
#CODE	O

Just	O
as	O
a	O
small	O
addition	O
,	O
you	O
can	O
also	O
do	O
an	O
apply	B-API
if	O
you	O
have	O
a	O
complex	O
function	O
that	O
you	O
apply	B-API
to	O
a	O
single	O
column	O
:	O

probably	O
x	O
is	O
a	O
confusing	O
name	O
for	O
the	O
column	O
name	O
and	O
the	O
row	O
variable	O
,	O
though	O
I	O
agree	O
apply	B-API
is	O
easiest	O
way	O
to	O
do	O
it	O
:)	O

just	O
to	O
add	O
,	O
`	O
apply	B-API
`	O
can	O
also	O
be	O
applied	O
to	O
multiple	O
columns	O
:	O

Can	O
apply	B-API
take	O
in	O
a	O
function	O
defined	O
elsewhere	O
in	O
code	O
?	O

Could	O
you	O
have	O
a	O
look	O
at	O
the	O
new	O
concat	B-API
function	O
in	O
pandas	O
0.7.0	O
and	O
see	O
if	O
it	O
meets	O
your	O
needs	O
:	O

I	O
recently	O
spent	O
a	O
great	O
deal	O
of	O
time	O
on	O
the	O
join	B-API
and	O
concatenation	O
methods	O
.	O

I	O
realize	O
the	O
map	B-API
function	O
can	O
only	O
output	O
lists	O
.	O

How	O
to	O
apply	B-API
slicing	O
on	O
pandas	O
Series	O
of	O
strings	O

I'm	O
playing	O
with	O
pandas	O
and	O
trying	O
to	O
apply	B-API
string	O
slicing	O
on	O
a	O
Series	O
of	O
strings	O
object	O
.	O

I	O
got	O
it	O
to	O
work	O
by	O
using	O
the	O
map	B-API
function	O
instead	O
,	O
but	O
I	O
think	O
I'm	O
missing	O
something	O
about	O
how	O
it's	O
supposed	O
to	O
work	O
.	O

`	O
apply	B-API
`	O
first	O
tries	O
to	O
apply	B-API
the	O
function	O
to	O
the	O
whole	O
series	O
.	O

also	O
,	O
how	O
can	O
I	O
then	O
reindex	B-API
things	O
so	O
that	O
the	O
first	O
indices	O
are	O
the	O
column	O
labels	O
of	O
each	O
file	O
and	O
the	O
second	O
is	O
the	O
filename	O
?	O

Suppose	O
there	O
are	O
many	O
columns	O
and	O
you	O
only	O
want	O
the	O
`	O
any	B-API
`	O
to	O
apply	B-API
to	O
a	O
subset	O
of	O
them	O
(	O
you	O
know	O
the	O
subset's	O
labels	O
)	O
.	O

Expanding	B-API
the	O
mini	O
domain-specific	O
language	O
I	O
made	O
above	O
for	O
expressing	O
logicals	O
to	O
have	O
this	O
option	O
with	O
simple	O
syntax	O
will	O
probably	O
be	O
an	O
uncomfortable	O
chore	O
.	O

Is	O
there	O
a	O
way	O
to	O
perform	O
inner	O
and	O
outer	O
joins	O
in	O
`	O
data.table	O
`	O
without	O
resorting	O
to	O
`	O
merge	B-API
(	O
X	O
,	O
Y	O
,	O
all=FALSE	O
)`	O
and	O
`	O
merge	B-API
(	O
X	O
,	O
Y	O
,	O
all=TRUE	O
)`	O
?	O

And	O
I	O
think	O
most	O
of	O
the	O
pandas	O
merge	B-API
code	O
is	O
in	O
Cython	O
.	O

Of	O
course	O
,	O
now	O
that	O
you've	O
figured	O
it	O
all	O
out	O
in	O
python	O
,	O
it	O
should	O
be	O
easy	O
to	O
translate	B-API
into	O
R	O
;)	O

Two	O
aspects	O
to	O
that	O
:	O
i	O
)	O
multi	O
column	O
ordered	O
keys	O
such	O
as	O
(	O
id	O
,	O
datetime	O
)	O
ii	O
)	O
fast	O
prevailing	O
join	B-API
(	O
`	O
roll=TRUE	O
`)	O
a.k.a.	O
last	O
observation	O
carried	O
forward	O
.	O

join	B-API
(	O
`	O
roll=TRUE	O
`)	O
a.k.a.	O
last	O
observation	O
carried	O
forward	O
.	O

I	O
hope	O
someone	O
does	O
a	O
join	B-API
benchmark	O
soon	O
too	O
!	O

You	O
can	O
also	O
use	O
panels	O
to	O
help	O
you	O
do	O
this	O
pivot	B-API
.	O

I	O
am	O
trying	O
to	O
do	O
a	O
pivot	B-API
table	O
of	O
frequency	O
counts	O
using	O
Panda	O
.	O

Just	O
replace	B-API
`	O
rows	O
=[	O
'	O
Y	O
']`	O
with	O
`	O
rows	O
=[	O
'	O
X2	O
']`	O
#CODE	O

Debug	O
build	O
of	O
Python	O
(	O
python-dbg	O
)	O
in	O
tandem	O
with	O
gdb	O
allow	O
you	O
right	O
away	O
debug	O
your	O
extensions	O
while	O
inspecting	O
Python	O
stack	B-API
etc	O
.	O

I	O
would	O
also	O
be	O
interested	O
in	O
aligning	O
my	O
irregular	O
timestamp	O
intervals	O
to	O
one	O
second	O
resolution	O
,	O
I	O
would	O
still	O
wish	O
to	O
plot	O
multiple	O
events	O
for	O
a	O
given	O
second	O
,	O
but	O
maybe	O
I	O
could	O
introduce	O
a	O
unique	O
index	O
,	O
then	O
align	B-API
my	O
prices	O
to	O
it	O
?	O

I	O
have	O
a	O
SAS	O
background	O
and	O
was	O
thinking	O
it'd	O
replace	B-API
proc	O
freq	B-API
--	O
it	O
looks	O
like	O
it'll	O
scale	O
to	O
what	O
I	O
may	O
want	O
to	O
do	O
in	O
the	O
future	O
.	O

Then	O
,	O
using	O
the	O
ability	O
to	O
apply	B-API
multiple	O
aggregation	O
functions	O
following	O
a	O
groupby	B-API
,	O
you	O
can	O
say	O
:	O
#CODE	O

suspect	O
with	O
some	O
unix	O
magic	O
you	O
can	O
transform	B-API
a	O
FWF	O
file	O
into	O
a	O
CSV	O

Pandas	O
rolling	B-API
median	B-API
for	O
duplicate	O
time	O
series	O
data	O

@USER	O
:	O
here's	O
the	O
link	O
to	O
the	O
description	O
of	O
truncate	B-API
in	O
the	O
current	O
documentation	O
(	O
v0.7.2	O
):	O
#URL	O

See	O
my	O
answer	O
below	O
--	O
if	O
someone	O
would	O
contribute	O
some	O
docs	O
about	O
truncate	B-API
that	O
would	O
be	O
helpful	O
.	O

it	O
uses	O
numpys	O
"	O
argmax	B-API
"	O
function	O
to	O
find	O
the	O
rowindex	O
in	O
which	O
the	O
maximum	O
appears	O
.	O

If	O
the	O
number	O
of	O
"	O
obj_id	O
"	O
s	O
is	O
very	O
high	O
you'll	O
want	O
to	O
sort	O
the	O
entire	O
dataframe	B-API
and	O
then	O
drop	B-API
duplicates	O
to	O
get	O
the	O
last	O
element	O
.	O

This	O
should	O
be	O
faster	O
(	O
sorry	O
I	O
didn't	O
test	O
it	O
)	O
because	O
you	O
don't	O
have	O
to	O
do	O
a	O
custom	O
agg	B-API
function	O
,	O
which	O
is	O
slow	O
when	O
there	O
is	O
a	O
large	O
number	O
of	O
keys	O
.	O

I	O
have	O
tried	O
using	O
`	O
groupby	B-API
`	O
and	O
`	O
agg	B-API
`	O
but	O
to	O
no	O
avail	O
.	O

to	O
pivot	B-API
the	O
values	O
.	O

It	O
wants	O
to	O
apply	B-API
the	O
to	O
strings	O
,	O
not	O
series	O
object	O
.	O

I	O
think	O
you	O
received	O
a	O
KeyError	O
because	O
``	O
df	O
``	O
was	O
indexed	O
before	O
joining	O
,	O
thus	O
'	O
first	O
'	O
was	O
no	O
longer	O
a	O
column	O
to	O
join	B-API
"	O
on	O
"	O
.	O

How	O
to	O
resample	B-API
a	O
dataframe	B-API
with	O
different	O
functions	O
applied	O
to	O
each	O
column	O
?	O

You	O
can	O
also	O
downsample	O
using	O
the	O
`	O
asof	B-API
`	O
method	O
of	O
`	O
pandas.DateRange	O
`	O
objects	O
.	O

@	O
Wes	O
McKinney	O
this	O
should	O
be	O
`	O
resample	B-API
`	O
in	O
0.8	O
,	O
isn't	O
it	O
?	O

But	O
I	O
eventually	O
need	O
to	O
join	B-API
multiple	O
`	O
pandas	O
`	O
`	O
DataFrames	O
`	O
so	O
I	O
need	O
to	O
get	O
this	O
method	O
working	O
.	O

Try	O
using	O
`	O
merge	B-API
`	O
(	O
#URL	O
):	O
#CODE	O

Best	O
way	O
to	O
insert	B-API
a	O
new	O
value	O

Now	O
use	O
this	O
as	O
an	O
auxiliary	O
index	O
variable	O
and	O
unstack	B-API
:	O
#CODE	O

Pandas	O
:	O
trouble	O
understading	O
how	O
merge	B-API
works	O

If	O
I	O
print	O
`	O
hist	B-API
`	O
and	O
`	O
freq	B-API
`	O
this	O
is	O
what	O
I	O
get	O
:	O
#CODE	O

They're	O
both	O
indexed	O
by	O
`"	O
series	O
"`	O
but	O
if	O
I	O
try	O
to	O
merge	B-API
:	O
#CODE	O

are	O
False	O
,	O
the	O
intersection	B-API
of	O
the	O
columns	O
in	O
the	O
DataFrames	O
will	O
be	O

Alternatively	O
and	O
more	O
simply	O
,	O
`	O
DataFrame	B-API
`	O
has	O
`	O
join	B-API
`	O
method	O
which	O
does	O
exactly	O
what	O
you	O
want	O
:	O
#CODE	O

I	O
would	O
like	O
to	O
use	O
pandas	O
to	O
create	O
a	O
HLOC	O
chart	O
of	O
data	O
for	O
every	O
one	O
minute	O
starting	O
with	O
time	O
zero	O
being	O
9:46	O
using	O
the	O
asof	B-API
method	O
....	O

Is	O
there	O
a	O
add	O
to	O
table	O
method	O
....	O
thinking	O
.....	O
take	O
new	O
data	O
,	O
process	O
(	O
ts.convert	O
)	O
.	O
append	B-API
table	O
..	O
numpy	O
add	O
to	O
array	O
.	O
any	O
help	O
here	O
.	O

Color	O
each	O
alternative	O
cell	O
with	O
a	O
specific	O
color	O
(	O
like	O
a	O
chess	O
board	O
:	O
instead	O
of	O
black	O
/	O
white	O
I	O
will	O
use	O
some	O
other	O
color	O
combination	O
)	O
and	O
insert	B-API
value	O
for	O
each	O
cell	O
from	O
a	O
pandas	O
data	O
frame	O
or	O
python	O
dictionary	O
.	O

You	O
can	O
either	O
truncate	B-API
the	O
data	O
,	O
or	O
add	O
an	O
extra	O
column	O
.	O

This	O
function	O
was	O
updated	O
to	O
the	O
name	O
`	O
idxmax	B-API
`	O
in	O
the	O
Pandas	O
API	O
,	O
though	O
as	O
of	O
Pandas	O
0.16	O
,	O
`	O
argmax	B-API
`	O
still	O
exists	O
and	O
performs	O
the	O
same	O
function	O
(	O
though	O
appears	O
to	O
run	O
more	O
slowly	O
than	O
`	O
idxmax	B-API
`)	O
.	O

Previously	O
(	O
as	O
noted	O
in	O
the	O
comments	O
)	O
it	O
appeared	O
that	O
`	O
argmax	B-API
`	O
would	O
exist	O
as	O
a	O
separate	O
function	O
which	O
provided	O
the	O
integer	O
position	O
within	O
the	O
index	O
of	O
the	O
row	O
location	O
of	O
the	O
maximum	O
element	O
.	O

In	O
general	O
,	O
I	O
think	O
the	O
move	O
to	O
`	O
idxmax	B-API
`	O
-like	O
behavior	O
for	O
all	O
three	O
of	O
the	O
approaches	O
(	O
`	O
argmax	B-API
`	O
,	O
which	O
still	O
exists	O
,	O
`	O
idxmax	B-API
`	O
,	O
and	O
`	O
numpy.argmax	O
`)	O
is	O
a	O
bad	O
thing	O
,	O
since	O
it	O
is	O
very	O
common	O
to	O
require	O
the	O
positional	O
integer	O
location	O
of	O
a	O
maximum	O
,	O
perhaps	O
even	O
more	O
common	O
than	O
desiring	O
the	O
label	O
of	O
that	O
positional	O
location	O
within	O
some	O
index	O
,	O
especially	O
in	O
applications	O
where	O
duplicate	O
row	O
labels	O
are	O
common	O
.	O

So	O
here	O
a	O
naive	O
use	O
of	O
`	O
idxmax	B-API
`	O
is	O
not	O
sufficient	O
,	O
whereas	O
the	O
old	O
form	O
of	O
`	O
argmax	B-API
`	O
would	O
correctly	O
provide	O
the	O
positional	O
location	O
of	O
the	O
max	O
row	O
(	O
in	O
this	O
case	O
,	O
position	O
9	O
)	O
.	O

So	O
you're	O
left	O
with	O
hoping	O
that	O
your	O
unit	O
tests	O
covered	O
everything	O
(	O
they	O
didn't	O
,	O
or	O
more	O
likely	O
no	O
one	O
wrote	O
any	O
tests	O
)	O
--	O
otherwise	O
(	O
most	O
likely	O
)	O
you're	O
just	O
left	O
waiting	O
to	O
see	O
if	O
you	O
happen	O
to	O
smack	O
into	O
this	O
error	O
at	O
runtime	O
,	O
in	O
which	O
case	O
you	O
probably	O
have	O
to	O
go	O
drop	B-API
many	O
hours	O
worth	O
of	O
work	O
from	O
the	O
database	O
you	O
were	O
outputting	O
results	O
to	O
,	O
bang	O
your	O
head	O
against	O
the	O
wall	O
in	O
IPython	O
trying	O
to	O
manually	O
reproduce	O
the	O
problem	O
,	O
finally	O
figuring	O
out	O
that	O
it's	O
because	O
`	O
idxmax	B-API
`	O
can	O
only	O
report	O
the	O
label	O
of	O
the	O
max	O
row	O
,	O
and	O
then	O
being	O
disappointed	O
that	O
no	O
standard	O
function	O
automatically	O
gets	O
the	O
positions	O
of	O
the	O
max	O
row	O
for	O
you	O
,	O
writing	O
a	O
buggy	O
implementation	O
yourself	O
,	O
editing	O
the	O
code	O
,	O
and	O
praying	O
you	O
don't	O
run	O
into	O
the	O
problem	O
again	O
.	O

Per	O
#URL	O
argmax	B-API
is	O
now	O
idxmax	B-API
.	O

Based	O
on	O
the	O
second-to-last	O
comment	O
there	O
,	O
it	O
looks	O
like	O
`	O
argmin	B-API
`	O
and	O
`	O
argmax	B-API
`	O
will	O
remain	O
part	O
of	O
`	O
DataFrame	B-API
`	O
and	O
the	O
difference	O
is	O
just	O
whether	O
you	O
want	O
the	O
index	O
or	O
the	O
label	O
.	O

`	O
argmax	B-API
`	O
will	O
give	O
you	O
the	O
index	O
integer	O
itself	O
.	O

Another	O
way	O
I	O
did	O
something	O
similar	O
was	O
create	O
a	O
pivot	B-API
table	O

In	O
this	O
case	O
I	O
want	O
to	O
convert	O
this	O
pivot	B-API
table	O
to	O
2d	O
numpy	O
array	O
.	O

if	O
you	O
really	O
need	O
to	O
replace	B-API
the	O
version	O
provided	O
by	O
the	O
system	O
,	O
uninstall	O
it	O
.	O

The	O
`	O
reindex	B-API
`	O
method	O
can	O
accomplish	O
this	O
when	O
passed	O
a	O
reordered	O
array	O
of	O
tuples	O
matching	O
the	O
desired	O
order	O
.	O

The	O
final	O
step	O
is	O
to	O
"	O
unstack	B-API
"	O
weekday	B-API
from	O
the	O

I	O
think	O
the	O
same	O
concepts	O
apply	B-API
to	O
an	O
index	O
of	O
floats	O
.	O

It	O
would	O
be	O
nice	O
to	O
have	O
a	O
convenience	O
function	O
for	O
this	O
where	O
you	O
can	O
pick	O
the	O
axes	O
to	O
interpolate	B-API
over	O

I'm	O
trying	O
to	O
align	B-API
my	O
index	O
values	O
between	O
multiple	O
DataFrames	O
or	O
Series	O
and	O
I'm	O
using	O

Series.interpolate	B-API
but	O
it	O
doesn't	O
seem	O
to	O
interpolate	B-API
correctly	O
.	O

It	O
assumes	O
they	O
are	O
equally	O
spaced	O
and	O
just	O
uses	O
`	O
len	B-API
(	O
serie	O
)`	O
for	O
indexes	O
.	O

I	O
modified	O
the	O
`	O
Series.interpolate	B-API
`	O
method	O
and	O
came	O
up	O
with	O
this	O
`	O
interpolate	B-API
`	O
function	O
.	O

I	O
don't	O
understand	O
why	O
the	O
join	B-API
has	O
created	O
a	O
tuple	O
.	O

When	O
I	O
export	O
the	O
csv	O
--	O
it	O
gives	O
back	O
the	O
*	O
original	O
*	O
data	O
set	O
df1	O
(	O
&	O
vice	O
versa	O
for	O
if	O
df1	O
and	O
df2	O
are	O
swapped	O
in	O
the	O
align	B-API
command	O
)	O
.	O

Using	O
join	B-API
works	O
for	O
what	O
I	O
needed	O
.	O

@USER	O
Align	B-API
,	O
I	O
would	O
imagine	O
,	O
simply	O
arranges	O
the	O
data	O
.	O

Not	O
sure	O
whats	O
the	O
way	O
to	O
append	B-API
to	O
current	O
data	O
frame	O
in	O
pandas	O
or	O
is	O
there	O
a	O
way	O
for	O
pandas	O
to	O
suck	O
a	O
list	O
of	O
files	O
into	O
a	O
data	O
frame	O
.	O

Once	O
you	O
have	O
read	O
the	O
files	O
and	O
save	O
it	O
in	O
two	O
dataframes	O
,	O
you	O
could	O
merge	B-API
the	O
two	O
dataframes	O
or	O
add	O
additional	O
columns	O
to	O
one	O
of	O
the	O
two	O
dataframes	O
(	O
assuming	O
common	O
index	O
)	O
.	O

The	O
pandas	O
`	O
concat	B-API
`	O
command	O
is	O
your	O
friend	O
here	O
.	O

data	O
=	O
dt	B-API
[	O
selector	O
]`	O

Python	O
Pandas	O
:	O
Aggregate	B-API
changed	O
from	O
0.7.1	O
to	O
0.7.3	O

"	O
No	O
numeric	O
values	O
to	O
aggregate	B-API
"	O

Pandas	O
:	O
Sort	O
pivot	B-API
table	O

Just	O
trying	O
out	O
Pandas	O
for	O
the	O
first	O
time	O
,	O
and	O
I	O
am	O
trying	O
to	O
sort	O
a	O
pivot	B-API
table	O
first	O
by	O
an	O
index	O
,	O
then	O
by	O
the	O
values	O
in	O
a	O
series	O
.	O

What's	O
the	O
correct	O
way	O
to	O
sort	O
a	O
pivot	B-API
table	O
by	O
index	O
then	O
value	O
?	O

using	O
the	O
ix	B-API

using	O
the	O
reindex	B-API
method	O

I'm	O
trying	O
to	O
do	O
shift	B-API
operations	O
...	O
but	O
this	O
also	O
happens	O
with	O
the	O
window	O
functions	O
like	O
`	O
rolling_mean	B-API
`	O
.	O

On	O
an	O
aside	O
:	O
does	O
truncate	B-API
need	O
to	O
be	O
existing	O
indexes	O
in	O
the	O
data	O
?	O

Note	O
this	O
is	O
a	O
very	O
inefficient	O
way	O
to	O
build	O
a	O
large	O
DataFrame	B-API
;	O
new	O
arrays	O
have	O
to	O
be	O
created	O
(	O
copying	O
over	O
the	O
existing	O
data	O
)	O
when	O
you	O
append	B-API
a	O
row	O
.	O

I	O
has	O
a	O
similar	O
problem	O
where	O
if	O
I	O
created	O
a	O
data	O
frame	O
for	O
each	O
row	O
and	O
append	B-API
it	O
to	O
the	O
main	O
data	O
frame	O
it	O
took	O
30	O
mins	O
.	O

Add	O
rows	O
through	O
`	O
loc	B-API
`	O
on	O
non	O
existing	O
index	O
data	O
.	O

`	O
.loc	B-API
`	O
is	O
referencing	O
the	O
index	O
column	O
,	O
so	O
if	O
you're	O
working	O
with	O
a	O
pre-existing	O
DataFrame	B-API
with	O
an	O
index	O
that	O
isn't	O
a	O
continous	O
sequence	O
of	O
integers	O
starting	O
with	O
0	O
(	O
as	O
in	O
your	O
example	O
)	O
,	O
`	O
.loc	B-API
`	O
will	O
overwrite	O
existing	O
rows	O
,	O
or	O
insert	B-API
rows	O
,	O
or	O
create	O
gaps	O
in	O
your	O
index	O
.	O

I	O
would	O
like	O
to	O
print	O
the	O
intersection	B-API
between	O
them	O
removing	O
all	O
"	O
NaN's	O
"	O
,	O
but	O
without	O
loose	O
alignment	O
.	O

Do	O
you	O
mean	O
you	O
want	O
to	O
drop	B-API
rows	O
where	O
there	O
are	O
NaNs	O
in	O
either	O
of	O
the	O
S	O
or	O
JEXP	O
columns	O
only	O
?	O

numpy	O
function	O
to	O
aggregate	B-API
a	O
signal	O
for	O
time	O
?	O

I	O
know	O
about	O
apply	B-API
,	O
but	O
sometimes	O
it's	O
more	O
convenient	O
to	O
use	O
a	O
for	O
loop	O
.	O

This	O
is	O
fairly	O
trivial	O
with	O
pandas	O
,	O
using	O
`	O
apply	B-API
`	O
with	O
axis=1	O
.	O

However	O
,	O
I	O
can	O
either	O
return	O
a	O
DataFrame	B-API
of	O
the	O
same	O
shape	O
if	O
my	O
function	O
doesn't	O
aggregate	B-API
,	O
or	O
a	O
Series	O
if	O
it	O
aggregates	O
.	O

Is	O
this	O
possible	O
or	O
I	O
have	O
to	O
do	O
two	O
runs	O
for	O
the	O
two	O
calculations	O
,	O
then	O
merge	B-API
them	O
together	O
?	O

Why	O
are	O
you	O
using	O
`	O
apply	B-API
`	O
in	O
the	O
first	O
place	O
?	O

You	O
could	O
just	O
have	O
`	O
t_test_and_mean	O
`	O
accept	O
your	O
input	O
dataframe	B-API
(	O
and	O
the	O
columns	O
to	O
group	O
by	O
)	O
and	O
return	O
a	O
1-row-2-columns	O
dataframe	B-API
,	O
without	O
using	O
`	O
apply	B-API
`	O
.	O

Is	O
there	O
a	O
really	O
straight	O
forward	O
way	O
to	O
apply	B-API
a	O
css	O
to	O
an	O
IPython	O
Notebook	O
and	O
then	O
have	O
tables	O
rendered	O
using	O
the	O
style	O
sheet	O
?	O

If	O
you	O
just	O
stick	O
that	O
in	O
one	O
of	O
your	O
markdown	O
cells	O
,	O
then	O
it	O
will	O
apply	B-API
to	O
everything	O
on	O
the	O
page	O
.	O

b	O
)	O
now	O
do	O
a	O
left	O
join	B-API
on	O
this	O
on	O
the	O
data	O
set	O
A	O
.	O

It	O
also	O
does	O
a	O
`	O
sort	B-API
`	O
of	O
the	O
output	O
index	O
,	O
so	O
finally	O
the	O
complexity	O
is	O
something	O
like	O
O	O
(	O
m	O
lg	O
m	O
)	O
with	O
m	O
=	O
len	B-API
(	O
B.index	O
)	O
...	O

I	O
have	O
two	O
pandas	O
DataFrames	O
and	O
I	O
want	O
to	O
join	B-API
them	O
together	O
such	O
that	O
I	O
get	O
the	O
outer	O
join	B-API
with	O
the	O
duplicates	O
removed	O
.	O

Note	O
that	O
I	O
have	O
implemented	O
new	O
`	O
cut	B-API
`	O
and	O
`	O
qcut	B-API
`	O
functions	O
for	O
discretizing	O
continuous	O
data	O
:	O

I	O
would	O
like	O
to	O
apply	B-API
the	O
same	O
function	O
to	O
each	O
item	O
of	O
a	O
given	O
dataset	O
but	O
using	O
a	O
time-dependent	O
parameter	O
.	O

One	O
way	O
to	O
do	O
it	O
is	O
to	O
use	O
the	O
`	O
map	B-API
`	O
function	O
,	O
or	O
`	O
numpy.vectorize	O
`	O
;	O
it's	O
also	O
possible	O
to	O
do	O
it	O
with	O
lambda	O
functions	O
.	O

Pandas	O
:	O
List	O
of	O
Column	O
names	O
in	O
a	O
pivot	B-API
table	O

I	O
got	O
stuck	O
trying	O
to	O
get	O
the	O
resulting	O
names	O
of	O
a	O
pivot	B-API
table	O
.	O

I'm	O
having	O
a	O
bit	O
of	O
trouble	O
altering	O
a	O
duplicated	O
pandas	O
DataFrame	B-API
and	O
not	O
having	O
the	O
edits	O
apply	B-API
to	O
both	O
the	O
duplicate	O
and	O
the	O
original	O
DataFrame	B-API
.	O

Essentially	O
my	O
question	O
would	O
then	O
boil	O
down	O
to	O
:	O
how	O
to	O
join	B-API
several	O
unaligned	O
time	O
series	O
,	O
where	O
each	O
series	O
has	O
a	O
date	O
column	O
,	O
and	O
column	O
for	O
the	O
series	O
itself	O
(	O
.CSV	O
file	O
exported	O
from	O
Excel	O
)	O

So	O
,	O
apply	B-API
this	O
function	O
to	O
each	O
of	O
those	O
3	O
columns	O
:	O
#CODE	O

I	O
can	O
reindex	B-API
the	O
`	O
df	O
`	O
easily	O
along	O
`	O
DOYtimestamp	O
`	O
with	O
:	O
`	O
df.reindex	B-API
(	O
index	O
=d	O
f.dtstamp	O
)`	O

Somewhat	O
confusingly	O
`	O
reindex	B-API
`	O
is	O
not	O
for	O
defining	O
a	O
new	O
index	O
,	O
exactly	O
;	O
rather	O
,	O
it	O
looks	O
for	O
rows	O
that	O
have	O
the	O
specified	O
indices	O
.	O

So	O
if	O
you	O
have	O
a	O
DataFrame	B-API
with	O
index	O
`	O
[	O
0	O
,	O
1	O
,	O
2	O
]`	O
,	O
then	O
doing	O
a	O
`	O
reindex	B-API
([	O
2	O
,	O
1	O
,	O
0	O
])`	O
will	O
return	O
the	O
rows	O
in	O
reverse	O
order	O
.	O

Doing	O
something	O
like	O
`	O
reindex	B-API
([8	O
,	O
9	O
,	O
10	O
])`	O
does	O
not	O
make	O
a	O
new	O
index	O
for	O
the	O
rows	O
;	O
rather	O
,	O
it	O
will	O
return	O
a	O
DataFrame	B-API
with	O
`	O
NaN	O
`	O
values	O
,	O
since	O
there	O
are	O
no	O
rows	O
with	O
indices	O
8	O
,	O
9	O
,	O
or	O
10	O
.	O

To	O
do	O
that	O
i	O
could	O
loop	O
through	O
the	O
file	O
using	O
beautiful	O
soup	O
and	O
insert	B-API
the	O
values	O
row	O
by	O
row	O
or	O
create	O
lists	O
to	O
be	O
inserted	O
as	O
columns	O
.	O

I	O
am	O
not	O
seeing	O
`	O
concat	B-API
`	O
as	O
a	O
function	O
in	O
the	O
pandas	O
namespace	O
;	O
I'm	O
not	O
sure	O
what	O
I	O
am	O
missing	O
.	O

I	O
was	O
running	O
pandas	O
ver	O
0.6.1	O
which	O
doesn't	O
have	O
the	O
concat	B-API
function	O
included	O
.	O

How	O
to	O
shift	B-API
a	O
column	O
in	O
Pandas	O
DataFrame	B-API

I	O
would	O
like	O
to	O
shift	B-API
a	O
column	O
in	O
a	O
Pandas	O
DataFrame	B-API
,	O
but	O
I	O
havent	O
been	O
able	O
to	O
find	O
a	O
method	O
to	O
do	O
it	O
from	O
the	O
documentation	O
without	O
rewriting	O
the	O
whole	O
DF	O
.	O

How	O
to	O
aggregate	B-API
duplicate	O
timestamps	O
with	O
pandas	O
?	O

@USER	O
-	O
you	O
have	O
to	O
aggregate	B-API
them	O
somehow	O
.	O

You	O
can	O
possibly	O
duplicate	O
the	O
`	O
quote	O
`	O
column	O
twice	O
shifting	O
it	O
by	O
one	O
each	O
direction	O
and	O
apply	B-API
it	O
to	O
your	O
dataset	O
to	O
create	O
a	O
pivot	B-API
table	O
based	O
on	O
entries	O
where	O
`	O
quote	O
`	O
is	O
!	O

For	O
example	O
,	O
when	O
I	O
try	O
to	O
aggregate	B-API
(	O
using	O
'	O
mean	O
')	O
10min	O
values	O
to	O
monthly	O
values	O
,	O
the	O
function	O
seems	O
to	O
use	O
the	O
last	O
day	O
of	O
data	O
from	O
one	O
month	O
in	O
the	O
mean	O
of	O
the	O
next	O
month	O
...	O

I've	O
tried	O
the	O
examples	O
given	O
in	O
the	O
documentation	O
,	O
but	O
I'm	O
still	O
a	O
little	O
unclear	O
how	O
to	O
apply	B-API
it	O
to	O
my	O
situation	O
.	O

Once	O
I	O
have	O
the	O
frame	O
given	O
by	O
this	O
routine	O
,	O
I	O
can	O
easily	O
apply	B-API
the	O
various	O
operations	O
suggested	O
below	O
-	O
of	O
particular	O
utility	O
is	O
being	O
able	O
to	O
use	O
the	O
`	O
names	B-API
`	O
field	O
when	O
I	O

call	O
`	O
concat	B-API
`	O
-	O
this	O
eliminates	O
the	O
need	O
to	O
store	O
the	O
name	O
of	O
the	O
column	O
key	O
internally	O

I	O
might	O
suggest	O
using	O
`	O
pandas.concat	B-API
`	O
along	O
with	O
its	O
`	O
keys	B-API
`	O
argument	O
to	O
glue	O
together	O
Series	O
DataFrames	O
to	O
create	O
a	O
MultiIndex	B-API
in	O
the	O
columns	O
:	O
#CODE	O

However	O
,	O
I	O
see	O
that	O
this	O
doesn't	O
drop	B-API
the	O
top	O
level	O
as	O
you're	O
looking	O
for	O
.	O

How	O
do	O
I	O
apply	B-API
it	O
to	O
a	O
pandas	O
DataFrame	B-API
?	O

`	O
df.resample	B-API
(	O
'	O
Min	O
')`	O
is	O
too	O
high	O
level	O
and	O
wants	O
to	O
aggregate	B-API
.	O

Other	O
thing	O
that	O
is	O
great	O
in	O
pandas	O
is	O
the	O
Panel	O
class	O
that	O
you	O
can	O
join	B-API
series	O
of	O
layers	O
with	O
different	O
properties	O
and	O
combine	O
it	O
using	O
groupby	B-API
function	O
.	O

Is	O
there	O
a	O
way	O
to	O
get	O
pivot	B-API
to	O
give	O
me	O
a	O
DataFrame	B-API
object	O
without	O
that	O
additional	O
information	O
in	O
the	O
upper-left	O
corner	O
?	O

to	O
build	O
on	O
@USER	O
,	O
it	O
would	O
be	O
really	O
helpful	O
if	O
you	O
could	O
convert	O
the	O
pandas	O
output	O
to	O
either	O
a	O
list	O
of	O
lists	O
or	O
a	O
list	O
of	O
dicts	O
and	O
then	O
show	O
the	O
result	O
of	O
the	O
conversion	O
e.g.	O
with	O
`	O
map	B-API
(	O
list	O
,	O
B_p	O
)`	O
.	O

I'm	O
just	O
confused	O
because	O
in	O
the	O
documentation	O
(	O
help	O
(	O
B_p.to_csv	O
))	O
it	O
doesn't	O
show	O
anything	O
in	O
the	O
upper-left-hand	O
corner	O
when	O
you	O
pivot	B-API
a	O
table	O
.	O

The	O
solution	O
I	O
have	O
come	O
up	O
with	O
is	O
to	O
exclude	O
dates	O
for	O
which	O
valuation	O
(	O
actually	O
price	O
)	O
data	O
doesn't	O
exist	O
for	O
a	O
given	O
holding	O
and	O
then	O
aggregate	B-API
on	O
these	O
dates	O
where	O
I	O
have	O
complete	O
data	O
.	O

I	O
would	O
like	O
to	O
roll	O
through	O
my	O
data	O
by	O
date	O
and	O
on	O
each	O
date	O
take	O
a	O
time	O
slice	O
in	O
the	O
past	O
apply	B-API
a	O
function	O
to	O
every	O
time	O
series	O
so	O
I	O
get	O
a	O
result	O
such	O
as	O
this	O
where	O
X	O
is	O
the	O
output	O
of	O
the	O
function	O
of	O
timeslice	O
.	O

Also	O
is	O
there	O
some	O
other	O
way	O
to	O
do	O
the	O
following.Using	O
Apply	B-API
function	O
seems	O
to	O
be	O
very	O
slow	O
for	O
large	O
dataset	O
.	O

pandas	O
row	O
specific	O
apply	B-API

If	O
you	O
use	O
the	O
apply	B-API
method	O
with	O
a	O
function	O
what	O
happens	O
is	O
that	O
every	O
item	O
in	O
the	O
Series	O
will	O
be	O
mapped	O
with	O
such	O
a	O
function	O
.	O

A	O
more	O
complex	O
usage	O
of	O
apply	B-API
would	O
be	O
this	O
one	O
:	O
#CODE	O

When	O
you	O
read	O
in	O
your	O
files	O
,	O
you	O
can	O
use	O
`	O
concat	B-API
`	O
to	O
join	B-API
the	O
resulting	O
DataFrames	O
into	O
one	O
,	O
then	O
just	O
use	O
normal	O
pandas	O
averaging	O
techniques	O
to	O
average	O
them	O
.	O

but	O
when	O
I	O
do	O
it	O
on	O
the	O
'	O
link	O
'	O
series	O
I	O
can	O
draw	O
the	O
boxplot	B-API
correctly	O
.	O

You	O
could	O
create	O
a	O
semi-log	O
boxplot	B-API
,	O
for	O
example	O
,	O
by	O
:	O
#CODE	O

Can	O
you	O
post	O
the	O
exact	O
pivot	B-API
method	O
call	O
you're	O
using	O
?	O

If	O
you	O
have	O
duplicates	O
you	O
may	O
need	O
to	O
aggregate	B-API
first	O
.	O

It	O
would	O
be	O
nice	O
to	O
add	O
an	O
option	O
to	O
pivot	B-API
to	O
take	O
either	O
the	O
first	O
or	O
last	O
observed	O
entry	O
:	O
#URL	O

I	O
fixed	O
the	O
parser	O
bug	O
shown	O
in	O
the	O
stack	B-API
trace	O
that	O
you	O
pasted	O
.	O

I	O
am	O
currently	O
rolling	B-API
up	O
numbers	O
with	O
the	O
following	O
code	O
.	O

Try	O
saving	O
that	O
to	O
a	O
temporary	O
variable	O
and	O
using	O
the	O
temp	O
variable	O
inside	O
`	O
startswith	B-API
`	O
.	O

`	O
ix	B-API
`	O
indexes	O
rows	O
,	O
not	O
columns	O
.	O

`	O
ix	B-API
`	O
accepts	O
slice	O
arguments	O
,	O
so	O
you	O
can	O
also	O
get	O
columns	O
.	O

So	O
,	O
`	O
ix	B-API
`	O
is	O
perfectly	O
general	O
for	O
this	O
question	O
.	O

Never	O
knew	O
about	O
that	O
feature	O
of	O
`	O
ix	B-API
`	O
.	O

You're	O
correct	O
that	O
this	O
would	O
be	O
wrong	O
for	O
most	O
types	O
;	O
however	O
`	O
pandas.DataFrame	B-API
`	O
has	O
special	O
support	O
for	O
setting	O
values	O
using	O
a	O
Boolean	O
mask	B-API
;	O
it	O
will	O
select	O
the	O
corresponding	O
values	O
from	O
the	O
RHS	O
with	O
the	O
corresponding	O
time	O
value	O
.	O

My	O
worry	O
is	O
that	O
in	O
the	O
original	O
code	O
,	O
the	O
first	O
N	O
values	O
of	O
cap_level	O
will	O
be	O
taken	O
and	O
used	O
,	O
where	O
N	O
is	O
the	O
number	O
of	O
True	O
values	O
in	O
the	O
Boolean	O
mask	B-API
.	O

I	O
know	O
that	O
I	O
can	O
apply	B-API
numpy	O
methods	O
by	O
doing	O
the	O
following	O
:	O

However	O
,	O
what	O
if	O
I	O
want	O
to	O
compute	O
the	O
standard	O
error	O
of	O
the	O
mean	O
(	O
sem	B-API
)	O
?	O

Doesn't	O
the	O
true	O
/	O
false	O
part	O
of	O
QRY	O
explain	O
the	O
bool	B-API
nature	O
of	O
i	O
for	O
your	O
example	O
?	O

I	O
have	O
a	O
data	O
table	O
using	O
pandas	O
and	O
column	O
labels	O
that	O
I	O
need	O
to	O
edit	O
to	O
replace	B-API
the	O
original	O
column	O
labels	O
.	O

I	O
have	O
the	O
edited	O
column	O
names	O
stored	O
it	O
in	O
a	O
list	O
,	O
but	O
I	O
don't	O
know	O
how	O
to	O
replace	B-API
the	O
column	O
names	O
.	O

This	O
will	O
put	O
them	O
into	O
dictionary	O
form	O
,	O
including	O
the	O
earlier	O
defined	O
class	O
and	O
subject	O
variables	O
,	O
and	O
append	B-API
them	O
to	O
an	O
outputList	O
.	O

A	O
great	O
thing	O
will	O
be	O
to	O
have	O
the	O
possibility	O
to	O
append	B-API
informations	O
like	O
"	O
unit	O
"	O
,	O
"	O
origin	O
"	O
or	O
anything	O
relevant	O
for	O
the	O
user	O
that	O
will	O
not	O
be	O
lost	O
during	O
computations	O
,	O
like	O
the	O
"	O
name	O
"	O
parameter	O
.	O

We'd	O
welcome	O
any	O
additional	O
feedback	O
you	O
have	O
(	O
see	O
pandas	O
on	O
github	O
)	O
and	O
would	O
love	O
to	O
accept	O
a	O
pull-request	O
if	O
you're	O
interested	O
in	O
rolling	B-API
your	O
own	O
.	O

Basically	O
,	O
I'm	O
trying	O
to	O
pivot	B-API
on	O
location	O
to	O
end	O
up	O
with	O
a	O
dataframe	B-API
like	O
:	O
#CODE	O

Unfortunately	O
when	O
I	O
pivot	B-API
,	O
the	O
index	O
,	O
which	O
is	O
equivalent	O
to	O
the	O
original	O
dates	O
column	O
,	O
does	O
not	O
change	O
and	O
I	O
get	O
:	O
#CODE	O

because	O
I	O
have	O
a	O
#	O
of	O
data	O
columns	O
I	O
want	O
to	O
pivot	B-API
(	O
don't	O
want	O
to	O
list	O
each	O
one	O
as	O
an	O
argument	O
)	O
.	O

I	O
believe	O
by	O
default	O
pivot	B-API
pivots	O
the	O
rest	O
of	O
the	O
columns	O
in	O
the	O
dataframe	B-API
.	O

I'm	O
actually	O
calling	O
df.pivot	B-API
without	O
the	O
third	O
argument	O
as	O
in	O
my	O
actual	O
data	O
,	O
i	O
have	O
a	O
#	O
of	O
data	O
columns	O
and	O
I	O
want	O
to	O
pivot	B-API
all	O
of	O
them	O
.	O

Yeah	O
I'm	O
seeing	O
the	O
information	O
come	O
out	O
as	O
a	O
multiindex	B-API
,	O
but	O
again	O
,	O
I	O
get	O
the	O
same	O
issue	O
where	O
pandas	O
seems	O
to	O
recognize	O
all	O
the	O
dates	O
as	O
unique	O
and	O
I	O
get	O
a	O
bunch	O
of	O
Nans	O
.	O

Even	O
if	O
I	O
set	O
the	O
pivot	B-API
argument	O
values	O
to	O
say	O
column	O
C	O
,	O
I	O
still	O
get	O
the	O
same	O
#	O
of	O
rows	O
as	O
in	O
my	O
original	O
table	O
,	O
just	O
with	O
Nans	O
for	O
all	O
the	O
repeated	O
dates	O
.	O

I	O
tried	O
the	O
drop	B-API
method	O
like	O
this	O
:	O
#CODE	O

I	O
also	O
tried	O
to	O
drop	B-API
by	O
index	O
name	O
and	O
it	O
still	O
doesn't	O
seem	O
to	O
be	O
working	O
.	O

I	O
can	O
use	O
sin	O
and	O
DataFrame.prod	B-API
to	O
create	O
a	O
boolean	O
mask	B-API
:	O
#CODE	O

Then	O
use	O
the	O
mask	B-API
to	O
select	O
from	O
the	O
DataFrame	B-API
:	O
#CODE	O

Is	O
there	O
a	O
vectorised	O
way	O
to	O
aggregate	B-API
data	O
in	O
this	O
way	O
?	O

What's	O
the	O
right	O
way	O
for	O
me	O
to	O
aggregate	B-API
these	O
stock	O
prices	O
into	O
Monthly	O
?	O

The	O
error	O
message	O
is	O
"	O
GroupByError	O
(	O
'	O
No	O
numeric	O
types	O
to	O
aggregate	B-API
')"	O
.	O

EDIT	O
:	O
I	O
just	O
realized	O
that	O
most	O
of	O
the	O
other	O
functions	O
(	O
min	O
,	O
max	O
,	O
median	B-API
,	O
etc	O
.	O
)	O
work	O
fine	O
but	O
not	O
the	O
mean	O
function	O
that	O
i	O
desperately	O
need	O
:-(	O
.	O

I	O
am	O
trying	O
to	O
use	O
the	O
agg	B-API
fn	O
but	O
without	O
doing	O
a	O
groupby	B-API
.	O

I	O
think	O
it	O
uses	O
`	O
patsy	O
`	O
in	O
the	O
backend	O
to	O
translate	B-API
the	O
formula	O
expression	O
,	O
and	O
intercept	O
is	O
added	O
automatically	O
.	O

dalejung	O
on	O
GitHub	O
has	O
done	O
quite	O
a	O
bit	O
of	O
work	O
recently	O
in	O
creating	O
a	O
tighter	O
pandas-xts	O
interface	O
with	O
rpy2	O
,	O
you	O
might	O
get	O
in	O
touch	O
with	O
him	O
or	O
join	B-API
the	O
PyData	O
mailing	O
list	O

Length	O
:	O
3	O
,	O
Freq	B-API
:	O
3H	O
,	O
Timezone	O
:	O
None	O

Length	O
:	O
3	O
,	O
Freq	B-API
:	O
H	O
,	O
Timezone	O
:	O
None	O

We	O
run	O
into	O
issues	O
that	O
join	B-API
columns	O
are	O
converted	O
into	O
either	O
ints	O
or	O
floats	O
,	O
based	O
on	O
the	O
existence	O
of	O
a	O
NA	O
value	O
in	O
the	O
original	O
list	O
.	O

(	O
Creating	O
issues	O
later	O
on	O
when	O
trying	O
to	O
merge	B-API
these	O
dataframes	O
)	O

I	O
haven't	O
done	O
time	O
benchmarking	O
,	O
but	O
I	O
am	O
skeptical	O
of	O
the	O
following	O
immediately	O
obvious	O
way	O
that	O
comes	O
to	O
mind	O
(	O
and	O
variants	O
that	O
might	O
use	O
`	O
map	B-API
`	O
or	O
`	O
filter	O
`)	O
.	O

Collapse	O
a	O
Pandas	O
multiindex	B-API
or	O
run	O
OLS	O
regression	O
on	O
a	O
multiindexed	O
dataframe	B-API

I	O
can	O
create	O
a	O
new	O
dataframe	B-API
,	O
loop	O
over	O
both	O
column	O
indexes	O
,	O
and	O
insert	B-API
new	O
columns	O
into	O
the	O
new	O
dataframe	B-API
with	O
the	O
same	O
name	O
,	O
but	O
with	O
names	O
as	O
strings	O
instead	O
of	O
tuples	O
.	O

I.e.	O
how	O
easy	O
is	O
it	O
for	O
me	O
to	O
cvs	O
checkout	O
the	O
code	O
,	O
test	O
my	O
changes	O
in	O
iPython	O
rather	O
than	O
with	O
the	O
prod	B-API
version	O
then	O
creating	O
a	O
pull	O
request	O
?	O

So	O
in	O
this	O
case	O
I	O
would	O
replace	B-API
that	O
missing	O
value	O
with	O
the	O
average	O
rating	O
given	O
to	O
that	O
artist	O
(	O
a	O
bad	O
first	O
approximation	O
,	O
better	O
to	O
use	O
the	O
SVD	O
)	O

It	O
depends	O
on	O
the	O
size	O
of	O
your	O
DataFrame	B-API
,	O
but	O
potentially	O
you	O
could	O
repeat	O
the	O
mean	O
rating	O
so	O
it's	O
the	O
same	O
size	O
as	O
the	O
ratings	O
matrix	O
and	O
then	O
use	O
the	O
NA	O
mask	B-API
to	O
replace	B-API
the	O
missing	O
values	O
?	O

This	O
supersedes	O
the	O
`	O
irow	B-API
`	O
approach	O
.	O

If	O
you	O
want	O
to	O
remove	O
the	O
old	O
10-based	O
indices	O
,	O
you	O
can	O
insert	B-API
the	O
flag	O
`	O
drop=True	O
`	O
into	O
the	O
parenthesis	O
of	O
the	O
reset_index	B-API
function	O
.	O

I	O
tried	O
merge	B-API
as	O
well	O
but	O
I	O
have	O
the	O
same	O
issue	O
.	O

If	O
you	O
are	O
having	O
issues	O
with	O
join	B-API
,	O
read	O
Wes's	O
answer	O
below	O
.	O

`	O
merge	B-API
`	O
and	O
`	O
join	B-API
`	O
do	O
,	O
well	O
,	O
joins	O
,	O
which	O
means	O
they	O
will	O
give	O
you	O
something	O
based	O
around	O
the	O
Cartesian	O
product	O
of	O
the	O
two	O
inputs	O
,	O
but	O
it	O
sounds	O
like	O
you	O
just	O
want	O
to	O
paste	O
them	O
together	O
into	O
one	O
big	O
table	O
.	O

Perhaps	O
`	O
concat	B-API
([	O
x	O
,	O
y	O
]	O
,	O
axis=1	O
)`	O
?	O

Pandas	O
:	O
pivot	B-API
a	O
dataframe	B-API

The	O
sensor	O
timeseries	O
data	O
is	O
then	O
also	O
rounded	O
to	O
the	O
nearest	O
minute	O
and	O
I	O
use	O
numpy.in1d	O
and	O
take	O
the	O
timestamps	O
from	O
the	O
above	O
'	O
minutes_array	O
'	O
and	O
the	O
'	O
sensor_data	O
'	O
array	O
and	O
create	O
a	O
mask	B-API
for	O
the	O
records	O
relating	O
to	O
that	O
sensor	O
.	O

I	O
then	O
wish	O
to	O
modify	O
the	O
records	O
in	O
minutes_array	O
which	O
are	O
true	O
for	O
that	O
mask	B-API
and	O
place	O
the	O
sensor_data	O
value	O
into	O
the	O
first	O
column	O
following	O
the	O
timestamp	O
in	O
minutes_array	O
.	O

From	O
my	O
attempts	O
it	O
does	O
not	O
seem	O
possible	O
to	O
alter	O
the	O
original	O
'	O
minutes_array	O
'	O
when	O
a	O
mask	B-API
is	O
applied	O
to	O
it	O
,	O
is	O
there	O
a	O
way	O
to	O
achieve	O
this	O
outcome	O
in	O
numpy	O
without	O
using	O
for	O
loops	O
and	O
matching	O
timestamps	O
individually	O
?	O

I	O
have	O
two	O
largish	O
(	O
snippets	O
provided	O
)	O
pandas	O
DateFrames	O
with	O
unequal	O
dates	O
as	O
indexes	O
that	O
I	O
wish	O
to	O
concat	B-API
into	O
one	O
:	O
#CODE	O

Not	O
sure	O
what	O
your	O
`	O
concat	B-API
`	O
line	O
will	O
do	O

Try	O
to	O
join	B-API
on	O
outer	O
.	O

I	O
often	O
need	O
to	O
apply	B-API
a	O
function	O
to	O
the	O
groups	O
of	O
a	O
very	O
large	O
`	O
DataFrame	B-API
`	O
(	O
of	O
mixed	O
data	O
types	O
)	O
and	O
would	O
like	O
to	O
take	O
advantage	O
of	O
multiple	O
cores	O
.	O

pandas	O
concat	B-API
(	O
'	O
outer	O
')	O
not	O
doing	O
union	O
?	O

How	O
to	O
resample	B-API
a	O
python	O
pandas	O
TimeSeries	O
containing	O
dytpe	O
Decimal	O
values	O
?	O

I'd	O
like	O
to	O
use	O
the	O
new	O
pandas	O
0.8	O
function	O
to	O
resample	B-API
the	O
decimal	O
time	O
series	O
like	O
this	O
:	O
#CODE	O

When	O
trying	O
this	O
i	O
get	O
an	O
"	O
GroupByError	O
:	O
No	O
numeric	O
types	O
to	O
aggregate	B-API
"	O
error	O
.	O

I	O
assume	O
the	O
problem	O
is	O
that	O
np.mean	O
is	O
used	O
internaly	O
to	O
resample	B-API
the	O
values	O
and	O
np.mean	O
expects	O
floats	O
instead	O
of	O
Decimals	O
.	O

Thanks	O
to	O
the	O
help	O
of	O
this	O
forum	O
i	O
managed	O
to	O
solve	O
a	O
similar	O
question	O
using	O
groupBy	B-API
and	O
the	O
apply	B-API
function	O
but	O
i	O
would	O
love	O
to	O
also	O
use	O
the	O
cool	O
resample	B-API
function	O
.	O

It	O
is	O
possible	O
to	O
provide	O
a	O
function	O
to	O
the	O
'	O
how	O
'	O
argument	O
of	O
resample	B-API
:	O
#CODE	O

Currently	O
i'm	O
using	O
string	O
replace	B-API
which	O
i	O
consider	O
to	O
be	O
a	O
significant	O
perfomance	O
penalty	O
.	O

Unexpected	O
result	O
when	O
upsampling	O
hourly	O
values	O
using	O
the	O
pandas	O
resample	B-API
function	O

I	O
try	O
to	O
upsample	O
daily	O
TimeSeries	O
values	O
using	O
the	O
pandas	O
resample	B-API
function	O
.	O

However	O
,	O
I	O
think	O
that	O
you	O
can	O
get	O
away	O
with	O
`	O
.max	B-API
(	O
axis=1	O
)`	O
instead	O
of	O
`	O
apply	B-API
(	O
...	O
)`	O
.	O

`	O
max()	O
`	O
is	O
ok	O
too	O
of	O
course	O
,	O
i	O
think	O
i	O
got	O
biased	O
towards	O
`	O
apply	B-API
`	O
by	O
the	O
way	O
you	O
asked	O
the	O
question	O
:-)	O

Simplest	O
way	O
is	O
probably	O
`	O
list	O
(	O
dt.T.itertuples()	O
)`	O
(	O
where	O
`	O
dt	B-API
`	O
is	O
your	O
dataframe	B-API
)	O
.	O

The	O
problem	O
in	O
your	O
code	O
is	O
that	O
you	O
want	O
to	O
apply	B-API
the	O
operation	O
on	O
every	O
row	O
.	O

Most	O
operations	O
in	O
`	O
pandas	O
`	O
can	O
be	O
accomplished	O
with	O
operator	O
chaining	O
(	O
`	O
groupby	B-API
`	O
,	O
`	O
aggregate	B-API
`	O
,	O
`	O
apply	B-API
`	O
,	O
etc	O
)	O
,	O
but	O
the	O
only	O
way	O
I've	O
found	O
to	O
filter	O
rows	O
is	O
via	O
normal	O
bracket	O
indexing	O
#CODE	O

If	O
you	O
want	O
to	O
chain	O
methods	O
,	O
you	O
can	O
add	O
your	O
own	O
mask	B-API
method	O
and	O
use	O
that	O
one	O
.	O

I	O
would	O
extend	O
it	O
by	O
generalizing	O
the	O
mask	B-API
function	O
as	O
:	O
#CODE	O

If	O
you	O
would	O
like	O
to	O
apply	B-API
all	O
of	O
the	O
common	O
boolean	O
masks	O
as	O
well	O
as	O
a	O
general	O
purpose	O
mask	B-API
you	O
can	O
chuck	O
the	O
following	O
in	O
a	O
file	O
and	O
then	O
simply	O
assign	O
them	O
all	O
as	O
follows	O
:	O
#CODE	O

pandas	O
:	O
stacking	O
DataFrames	O
generated	O
by	O
apply	B-API

1	O
)	O
"	O
join	B-API
"	O
the	O
results	O
back	O
to	O
the	O
initial	O
DataFrame	B-API

transform	B-API
(	O
#URL	O
)	O
and	O
agg	B-API
(	O
#URL	O
)	O
can	O
be	O
used	O
.	O

If	O
you	O
want	O
different	O
operations	O
on	O
each	O
column	O
,	O
according	O
to	O
the	O
docs	O
you	O
can	O
pass	O
a	O
`	O
dict	O
`	O
to	O
`	O
aggregate	B-API
`	O
.	O

Excel	O
considers	O
1900	O
a	O
leap	O
year	O
,	O
so	O
be	O
careful	O
with	O
exactly	O
what	O
you	O
want	O
to	O
translate	B-API
:	O

You	O
should	O
use	O
list	O
(	O
islice	O
(	O
cycle	O
([	O
'	O
b	O
'	O
,	O
'	O
r	O
'	O
,	O
'	O
g	O
'	O
,	O
'	O
y	O
'	O
,	O
'	O
k	O
'])	O
,	O
None	O
,	O
len	B-API
(	O
df	O
)))	O
instead	O
.	O

This	O
creates	O
a	O
boolean	O
mask	B-API
which	O
is	O
then	O
used	O
for	O
the	O
subsetting	O
.	O

The	O
correct	O
solution	O
is	O
to	O
wait	O
use	O
the	O
results	O
objects	O
to	O
get	O
the	O
results	O
and	O
then	O
append	B-API
all	O
of	O
them	O
in	O
the	O
main	O
thread	O
.	O

Where	O
has	O
`	O
unstack	B-API
`	O
been	O
hiding	O
???	O

Filtering	O
and	O
selecting	O
from	O
pivot	B-API
tables	O
made	O
with	O
python	O
pandas	O

Is	O
there	O
a	O
way	O
to	O
do	O
this	O
directly	O
within	O
the	O
pivot	B-API
table	O
structure	O
,	O
or	O
do	O
I	O
need	O
to	O
convert	O
this	O
back	O
in	O
to	O
a	O
panda	O
data	O
frame	O
?	O

Is	O
there	O
a	O
way	O
to	O
get	O
a	O
list	O
of	O
values	O
in	O
a	O
pivot	B-API
table	O
column	O
by	O
specifying	O
the	O
header	O
?	O

I	O
can	O
do	O
this	O
on	O
the	O
dataframe	B-API
with	O
'	O
df	O
[	O
'	O
A	O
']	O
.values	B-API
'	O
but	O
I'm	O
struggling	O
to	O
obtain	O
something	O
similar	O
from	O
the	O
pivot	B-API
table	O

the	O
result	O
of	O
the	O
pivot	B-API
table	O
is	O
a	O
DataFrame	B-API
.	O

How	O
to	O
keep	O
index	O
when	O
using	O
pandas	O
merge	B-API

I	O
would	O
like	O
to	O
merge	B-API
two	O
data	O
frames	O
,	O
and	O
keep	O
the	O
index	O
from	O
the	O
first	O
frame	O
as	O
the	O
index	O
on	O
the	O
merged	O
dataset	O
.	O

There	O
are	O
some	O
places	O
where	O
pandas	O
is	O
not	O
as	O
careful	O
as	O
it	O
could	O
be	O
about	O
memory	O
usage	O
when	O
it	O
comes	O
to	O
MultiIndex	B-API
--	O
if	O
you	O
do	O
find	O
a	O
case	O
that	O
reproduces	O
the	O
issue	O
please	O
do	O
post	O
it	O
on	O
the	O
issue	O
tracker	O
.	O

Ok	O
,	O
I	O
can	O
create	O
an	O
empty	O
dict	O
,	O
insert	B-API
values	O
and	O
create	O
a	O
DataFrame	B-API
.	O

Just	O
for	O
completeness	O
,	O
though	O
,	O
you	O
could	O
--	O
inefficiently	O
--	O
use	O
`	O
join	B-API
`	O
or	O
`	O
concat	B-API
`	O
to	O
get	O
a	O
column-by-column	O
approach	O
to	O
work	O
:	O
#CODE	O

In	O
this	O
example	O
I	O
get	O
an	O
Attribute	O
error	O
related	O
to	O
the	O
map	B-API
function	O
.	O

The	O
problem	O
is	O
that	O
multiindex	B-API
is	O
getting	O
reversed	O
after	O
the	O
operation	O
,	O
is	O
there	O
any	O
easy	O
way	O
to	O
make	O
this	O
work	O
?	O

Perhaps	O
I'm	O
misusing	O
the	O
stack	B-API
from	O
the	O
start	O
?	O

thanks	O
almost	O
works	O
,	O
you	O
have	O
to	O
add	O
an	O
`	O
.sortlevel	B-API
(	O
0	O
)`	O
to	O
get	O
a	O
correct	O
multiindex	B-API
.	O

How	O
do	O
I	O
really	O
use	O
the	O
`	O
ix	B-API
`	O
method	O
of	O
a	O
pandas	O
DataFrame	B-API
?	O

Having	O
read	O
the	O
docs	O
one	O
the	O
`	O
ix	B-API
`	O
method	O
of	O
DataFrames	O
,	O
I'm	O
a	O
bit	O
confused	O
by	O
the	O
following	O
behavior	O
with	O
my	O
MultiIndexed	O
DataFrame	B-API
(	O
specifying	O
select	O
columns	O
of	O
the	O
index	O
)	O
.	O

Why	O
does	O
the	O
`	O
ix	B-API
`	O
method	O
behave	O
like	O
this	O
?	O

If	O
you	O
want	O
to	O
select	O
rows	O
/	O
columns	O
based	O
on	O
MultiIndex	B-API
level	O
values	O
i	O
suggest	O
using	O
the	O
'	O
.xs()	B-API
'	O
method	O
.	O

We	O
can	O
join	B-API
these	O
strings	O
with	O
the	O
regex	O
'	O
or	O
'	O
character	O
`	O
|	O
`	O
and	O
pass	O
the	O
string	O
to	O
`	O
str.contains	B-API
`	O
to	O
filter	O
the	O
DataFrame	B-API
:	O
#CODE	O

You	O
mention	O
in	O
your	O
question	O
that	O
the	O
red	O
line	O
is	O
the	O
mean	O
-	O
it	O
is	O
actually	O
the	O
median	B-API
.	O

with	O
a	O
line	O
at	O
the	O
median	B-API
.	O

The	O
set_value	B-API
approach	O
also	O
works	O
for	O
multiindex	B-API
DataFrames	O
by	O
putting	O
the	O
multiple	O
levels	O
of	O
the	O
index	O
in	O
as	O
a	O
tuple	O
(	O
e.g.	O
replacing	O
column	O
with	O
(	O
col	O
,	O
subcol	O
)	O
)	O

I	O
want	O
to	O
normalize	B-API
this	O
data	O
,	O
by	O
splitting	O
it	O
into	O
tables	O
.	O

In	O
case	O
of	O
fixed	O
width	O
file	O
,	O
no	O
need	O
to	O
do	O
anything	O
special	O
to	O
strip	B-API
white	O
space	O
,	O
or	O
handle	O
missing	O
fields	O
.	O

Should	O
I	O
use	O
a	O
lambda	O
with	O
`	O
apply	B-API
`	O
?	O

How	O
to	O
broadcast	O
to	O
a	O
multiindex	B-API

If	O
B	O
is	O
the	O
one	O
with	O
a	O
MultiIndex	B-API
then	O
you	O
can	O
do	O
A.reindex	O
(	O
B.index	O
,	O
level=0	O
)	O
,	O
compute	O
the	O
result	O
,	O
and	O
then	O
do	O
result.groupby	O
(	O
level=0	O
)	O
to	O
compute	O
an	O
aggregate	B-API
result	O
.	O

And	O
then	O
,	O
I	O
need	O
to	O
join	B-API
these	O
.	O

python	O
pandas	O
:	O
apply	B-API
a	O
function	O
with	O
arguments	O
to	O
a	O
series	O

I	O
want	O
to	O
apply	B-API
a	O
function	O
with	O
arguments	O
to	O
a	O
series	O
in	O
python	O
pandas	O
:	O
#CODE	O

The	O
apply	B-API
method	O
accept	O
a	O
python	O
function	O
which	O
should	O
have	O
a	O
single	O
parameter	O
.	O

@USER	O
:	O
I	O
notice	O
that	O
`	O
np.random.permutation	O
`	O
would	O
strip	B-API
the	O
column	O
names	O
from	O
the	O
DataFrame	B-API
,	O
because	O
`	O
np.random.permutation	O
`	O
.	O

I	O
would	O
like	O
to	O
merge	B-API
the	O
existing	O
series	O
with	O
the	O
new	O
ones	O
subsequently	O
in	O
every	O
loop	O
,	O
while	O
preserving	O
their	O
(	O
different	O
)	O
indices	O
.	O

I	O
tried	O
concat	B-API
,	O
but	O
somehow	O
I	O
cannot	O
add	O
another	O
series	O
after	O
the	O
first	O
one	O
...	O

so	O
I	O
really	O
need	O
to	O
append	B-API
the	O
time	O
series	O
after	O
every	O
loop	O
...	O

I	O
do	O
something	O
like	O
this	O
all	O
the	O
time	O
but	O
I	O
use	O
`	O
append	B-API
`	O
like	O
this	O
:	O
#CODE	O

I	O
want	O
to	O
apply	B-API
a	O
groupby	B-API
operation	O
that	O
computes	O
cap-weighted	O
average	O
return	O
across	O
everything	O
,	O
per	O
each	O
date	O
in	O
the	O
"	O
yearmonth	O
"	O
column	O
.	O

Then	O
you	O
reindex	B-API
this	O
result	O
according	O
to	O
the	O
original	O
DataFrame	B-API
,	O
matching	O
their	O
indices	O
on	O
the	O
2	O
values	O
in	O
your	O
example	O
.	O

While	O
I'm	O
still	O
exploring	O
all	O
of	O
the	O
incredibly	O
smart	O
ways	O
that	O
`	O
apply	B-API
`	O
concatenates	O
the	O
pieces	O
it's	O
given	O
,	O
here's	O
another	O
way	O
to	O
add	O
a	O
new	O
column	O
in	O
the	O
parent	O
after	O
a	O
groupby	B-API
operation	O
.	O

My	O
understanding	O
was	O
that	O
transform	B-API
produces	O
an	O
object	O
that	O
looks	O
like	O
the	O
one	O
it	O
was	O
passed	O
.	O

Whereas	O
in	O
my	O
case	O
,	O
I	O
want	O
to	O
append	B-API
a	O
new	O
result	O
to	O
the	O
original	O
data	O
frame	O
.	O

IMHO	O
,	O
`	O
transform	B-API
`	O
looks	O
cleaner	O
.	O

Very	O
weird	O
bug	O
here	O
:	O
I'm	O
using	O
pandas	O
to	O
merge	B-API
several	O
dataframes	O
.	O

Inspecting	O
frame.py	O
,	O
it	O
looks	O
like	O
pandas	O
tries	O
to	O
insert	B-API
a	O
column	O
'	O
index	O
'	O
or	O
'	O
level_0	O
'	O
.	O

Fortunately	O
,	O
there's	O
a	O
"	O
drop	B-API
"	O
option	O
.	O

And	O
now	O
I	O
want	O
to	O
replace	B-API
the	O
element	O
of	O
df_a	O
by	O
element	O
of	O
df_b	O
which	O
have	O
the	O
same	O
(	O
index	O
,	O
column	O
)	O
coordinate	O
,	O
and	O
attach	O
df_b's	O
elements	O
whose	O
(	O
index	O
,	O
column	O
)	O
coordinate	O
beyond	O
the	O
scope	O
of	O
df_a	O
.	O

And	O
if	O
I	O
want	O
to	O
filter	O
the	O
Q1	O
,	O
Q3	O
,	O
Q4	O
together	O
,	O
which	O
is	O
"	O
NOT	O
endswith	B-API
(	O
'	O
0630	O
')"	O
,	O
how	O
to	O
add	O
the	O
'	O
NOT	O
'	O
to	O
the	O
command	O
of	O
"	O
df	O
[	O
df.index.map	O
(	O
lambda	O
x	O
:	O
x	O
[	O
1	O
]	O
.endswith	B-API
(	O
"	O
0630	O
"))]	O
"	O
?	O

There	O
might	O
be	O
a	O
slick	O
vectorized	O
way	O
to	O
do	O
this	O
,	O
but	O
I'd	O
just	O
apply	B-API
the	O
obvious	O
per-entry	O
function	O
to	O
the	O
values	O
and	O
get	O
on	O
with	O
my	O
day	O
:	O
#CODE	O

If	O
you	O
would	O
use	O
the	O
timestamps	O
of	O
the	O
events	O
as	O
index	O
of	O
the	O
series	O
instead	O
of	O
the	O
data	O
,	O
resample	B-API
can	O
do	O
this	O
.	O

resample	B-API
(	O
this	O
method	O
can	O
also	O
be	O
used	O
on	O
a	O
DataFrame	B-API
)	O
will	O
give	O
a	O
new	O
series	O
with	O
in	O
this	O
case	O
15min	O
periods	O
,	O
the	O
end	O
time	O
of	O
a	O
bucket	O
(	O
period	O
)	O
is	O
used	O
to	O
refer	O
to	O
it	O
(	O
you	O
can	O
control	O
this	O
with	O
the	O
label	O
arg	O
)	O
.	O

Definitely	O
pay	O
attention	O
to	O
the	O
`	O
closed	O
`	O
and	O
`	O
label	O
`	O
options	O
to	O
`	O
resample	B-API
`	O
!	O

You	O
can	O
also	O
use	O
this	O
to	O
transform	B-API
a	O
subset	O
of	O
a	O
column	O
,	O
e.g.	O
:	O
#CODE	O

However	O
,	O
it	O
says	O
[	O
here	O
]	O
(	O
#URL	O
)	O
that	O
setting	O
works	O
with	O
ix	B-API
.	O

I	O
didn't	O
realize	O
@USER	O
B	O
.	O
was	O
asking	O
about	O
`	O
ix	B-API
`	O
in	O
general	O
.	O

The	O
section	O
after	O
'	O
Assignment	O
/	O
setting	O
values	O
is	O
possible	O
when	O
using	O
ix	B-API
:	O
'	O
will	O
explain	O
exactly	O
what	O
you	O
need	O
!	O

I	O
see	O
that	O
pandas	O
has	O
an	O
asof	B-API
function	O
but	O
that	O
is	O
not	O
defined	O
on	O
the	O
DataFrame	B-API
,	O
only	O
on	O
the	O
Series	O
object	O
.	O

I	O
guess	O
one	O
could	O
loop	O
through	O
each	O
of	O
the	O
Series	O
and	O
align	B-API
them	O
one	O
by	O
one	O
,	O
but	O
I	O
am	O
wondering	O
if	O
there	O
is	O
a	O
better	O
way	O
?	O

this	O
is	O
also	O
called	O
*	O
rolling	B-API
join	B-API
*	O

It	O
could	O
be	O
easily	O
(	O
well	O
,	O
for	O
someone	O
who	O
is	O
familiar	O
with	O
the	O
code	O
)	O
extended	O
to	O
be	O
a	O
"	O
left	O
join	B-API
"	O
mimicking	O
KDB	O
.	O

Date	O
=	O
range	O
(	O
len	B-API
(	O
df2	O
))	O

Now	O
for	O
the	O
strides	B-API
.	O

Basic	O
problem	O
:	O
how	O
do	O
I	O
map	B-API
the	O
function	O
to	O
the	O
column	O
,	O
specifically	O
where	O
I	O
would	O
like	O
to	O
reference	O
more	O
than	O
one	O
other	O
column	O
or	O
the	O
whole	O
row	O
or	O
whatever	O
?	O

Then	O
you	O
can	O
use	O
map	B-API
:	O
#CODE	O

The	O
exact	O
code	O
will	O
vary	O
for	O
each	O
of	O
the	O
columns	O
you	O
want	O
to	O
do	O
,	O
but	O
it's	O
likely	O
you'll	O
want	O
to	O
use	O
the	O
`	O
map	B-API
`	O
and	O
`	O
apply	B-API
`	O
functions	O
.	O

For	O
the	O
second	O
part	O
of	O
your	O
question	O
,	O
you	O
can	O
also	O
use	O
`	O
shift	B-API
`	O
,	O
for	O
example	O
:	O
#CODE	O

Generating	O
a	O
boolean	O
mask	B-API
indexing	O
one	O
array	O
into	O
another	O
array	O

Now	O
I	O
really	O
don't	O
know	O
why	O
you	O
want	O
a	O
boolean	O
mask	B-API
,	O
these	O
indices	O
can	O
be	O
applied	O
to	O
z	O
to	O
give	O
back	O
x	O
already	O
and	O
are	O
more	O
compact	O
.	O

Python	O
Pandas	O
:	O
how	O
to	O
add	O
a	O
totally	O
new	O
column	O
to	O
a	O
data	O
frame	O
inside	O
of	O
a	O
groupby	B-API
/	O
transform	B-API
operation	O

Now	O
,	O
the	O
real	O
question	O
is	O
how	O
to	O
use	O
`	O
transform	B-API
`	O
to	O
add	O
a	O
new	O
column	O
to	O
the	O
data	O
.	O

Note	O
that	O
a	O
simple	O
`	O
apply	B-API
`	O
will	O
not	O
work	O
here	O
,	O
since	O
it	O
won't	O
know	O
how	O
to	O
make	O
sense	O
of	O
the	O
possibly	O
differently-sized	O
result	O
arrays	O
for	O
each	O
group	O
.	O

can	O
you	O
not	O
use	O
`	O
map	B-API
`	O
?	O

What	O
problems	O
are	O
you	O
running	O
into	O
with	O
`	O
apply	B-API
`	O
?	O

Python	O
Pandas	O
:	O
How	O
to	O
broadcast	O
an	O
operation	O
using	O
apply	B-API
without	O
writing	O
a	O
secondary	O
function	O

It	O
seems	O
logical	O
to	O
use	O
the	O
`	O
apply	B-API
`	O
function	O
for	O
this	O
,	O
but	O
it	O
doesn't	O
work	O
like	O
expected	O
.	O

It	O
does	O
not	O
even	O
seem	O
to	O
be	O
consistent	O
with	O
other	O
uses	O
of	O
`	O
apply	B-API
`	O
.	O

Based	O
on	O
this	O
,	O
it	O
appears	O
that	O
`	O
apply	B-API
`	O
does	O
nothing	O
but	O
perform	O
the	O
NumPy	O
equivalent	O
of	O
whatever	O
is	O
called	O
inside	O
.	O

That	O
is	O
,	O
`	O
apply	B-API
`	O
seems	O
to	O
execute	O
the	O
same	O
thing	O
as	O
`	O
arr	O
+	O
"	O
cat	O
"`	O
in	O
the	O
first	O
example	O
.	O

But	O
this	O
seems	O
to	O
break	O
from	O
what	O
`	O
apply	B-API
`	O
promises	O
in	O
the	O
docs	O
.	O

Is	O
there	O
some	O
way	O
of	O
using	O
`	O
apply	B-API
`	O
that	O
I	O
am	O
missing	O
here	O
?	O

and	O
I	O
verified	O
that	O
this	O
version	O
does	O
work	O
with	O
Pandas	O
`	O
apply	B-API
`	O
.	O

Isn't	O
this	O
specifically	O
what	O
`	O
apply	B-API
`	O
is	O
supposed	O
to	O
abstract	O
away	O
from	O
the	O
user	O
?	O

and	O
use	O
this	O
in	O
`	O
apply	B-API
`	O
:	O
#CODE	O

This	O
works	O
,	O
but	O
I	O
consider	O
it	O
a	O
workaround	O
as	O
well	O
,	O
since	O
it	O
doesn't	O
address	O
the	O
fact	O
that	O
`	O
apply	B-API
`	O
isn't	O
working	O
as	O
promised	O
.	O

That	O
contradicts	O
the	O
docs	O
for	O
`	O
apply	B-API
`	O
,	O
as	O
well	O
as	O
its	O
0.8.1	O
behavior	O
,	O
in	O
which	O
it	O
successfully	O
performs	O
the	O
elementwise	O
version	O
of	O
my	O
example	O
above	O
,	O
whereas	O
version	O
0.7.3	O
seems	O
to	O
use	O
the	O
logic	O
you	O
describe	O
.	O

Since	O
`	O
apply	B-API
`	O
should	O
work	O
in	O
0.7.3	O
as	O
it	O
does	O
in	O
0.8.1	O
(	O
according	O
to	O
the	O
docs	O
)	O
,	O
that's	O
why	O
I	O
think	O
it's	O
a	O
workaround	O
.	O

`	O
map	B-API
`	O
is	O
fine	O
,	O
but	O
`	O
apply	B-API
`	O
should	O
work	O
.	O

`	O
apply	B-API
`	O
is	O
designed	O
so	O
that	O
you	O
can	O
apply	B-API
a	O
ufunc	O
and	O
get	O
back	O
a	O
Series	O
with	O
the	O
index	O
intact	O
.	O

So	O
to	O
be	O
clear	O
,	O
we	O
should	O
use	O
`	O
apply	B-API
`	O
whenever	O
we	O
have	O
a	O
vectorized	O
/	O
ufunc	O
already	O
,	O
and	O
`	O
map	B-API
`	O
when	O
we	O
literally	O
want	O
to	O
apply	B-API
an	O
elementwise	O
operation	O
to	O
a	O
series	O
?	O

Yup	O
,	O
that's	O
exactly	O
right	O
on	O
`	O
apply	B-API
`	O
vs	O
`	O
map	B-API
`	O
.	O

Stepping	O
the	O
trace	O
in	O
the	O
case	O
of	O
date	O
column	O
,	O
shows	O
that	O
matplotlib	O
tries	O
to	O
do	O
x	O
[	O
0	O
]	O
on	O
the	O
dates	O
to	O
retrieve	O
tz	B-API
info	O
,	O
which	O
throws	O
a	O
KeyError	O
.	O

You'd	O
have	O
to	O
map	B-API
that	O
to	O
the	O
columns	O
using	O
`	O
map	B-API
`	O
or	O
`	O
apply	B-API
`	O
or	O
something	O
.	O

@USER	O
:	O
To	O
avoid	O
the	O
error	O
,	O
replace	B-API
`	O
int	O
(	O
x	O
)`	O
with	O
the	O
expression	O
`	O
int	O
(	O
text	O
)	O
if	O
x.isdigit()	O
else	O
x	O
`	O
.	O

Now	O
I	O
want	O
to	O
merge	B-API
the	O
data	O
frame	O
with	O
the	O
series	O
,	O
such	O
that	O
the	O
values	O
from	O
the	O
series	O
are	O
broadcasted	O
along	O
the	O
second	O
level	O
index	O
.	O

And	O
I	O
want	O
to	O
apply	B-API
a	O
function	O
`	O
func	O
`	O
(	O
exp	O
:	O
`'	O
lambda	O
x	O
:	O
x*10	O
'`)	O
to	O
`	O
second	B-API
`	O
,	O
somewhat	O
like	O
:	O
#CODE	O

This	O
way	O
,	O
the	O
index	O
column	O
is	O
not	O
dropped	O
and	O
still	O
accessible	O
for	O
your	O
`	O
apply	B-API
`	O
.	O

I	O
want	O
to	O
drop	B-API
duplicates	O
,	O
keeping	O
the	O
row	O
with	O
the	O
highest	O
value	O
in	O
column	O
B	O
.	O

Wes	O
has	O
added	O
some	O
nice	O
functionality	O
to	O
drop	B-API
duplicates	O
:	O
#URL	O
.	O

D'you	O
know	O
the	O
best	O
idiom	O
to	O
reindex	B-API
this	O
to	O
look	O
like	O
the	O
original	O
DataFrame	B-API
?	O

There's	O
some	O
code	O
to	O
reindex	B-API
the	O
grouped	O
dataframe	B-API
.	O

PS	O
:	O
but	O
if	O
you	O
really	O
just	O
want	O
the	O
last	O
column	O
,	O
`	O
apply	B-API
`	O
would	O
suffice	O
:	O
#CODE	O

So	O
to	O
try	O
and	O
generalize	O
my	O
question	O
,	O
how	O
can	O
I	O
get	O
`	O
df1	O
*	O
df2	O
`	O
using	O
`	O
map	B-API
`	O
to	O
define	O
the	O
columns	O
to	O
multiply	O
together	O
?	O

Suppose	O
we	O
want	O
to	O
multiply	O
several	O
columns	O
with	O
other	O
serveral	O
columns	O
in	O
the	O
same	O
dataframe	B-API
and	O
append	B-API
these	O
results	O
into	O
the	O
original	O
dataframe	B-API
.	O

(	O
I	O
think	O
it	O
can	O
be	O
some	O
problem	O
with	O
`	O
lambda	O
`	O
When	O
I	O
want	O
to	O
apply	B-API
my	O
function	O
to	O
the	O
column	O
I	O
have	O
an	O
error	O
:	O
`	O
TypeError	O
:	O
only	O
length-1	O
arrays	O
can	O
be	O
converted	O
to	O
Python	O
scalars	O
`)	O

On	O
top	O
of	O
a	O
dodgy	O
converter	O
,	O
i	O
think	O
you	O
apply	B-API
the	O
converter	O
to	O
the	O
wrong	O
column	O
(	O
look	O
at	O
the	O
exception	O
you	O
get	O
)	O
.	O

Is	O
there	O
a	O
way	O
to	O
do	O
this	O
if	O
you	O
want	O
to	O
normalize	B-API
a	O
subset	O
?	O

Say	O
that	O
row	O
`	O
A	O
`	O
and	O
`	O
B	O
`	O
are	O
part	O
of	O
a	O
larger	O
grouping	O
factor	O
that	O
you	O
want	O
to	O
normalize	B-API
separately	O
from	O
`	O
C	O
`	O
and	O
`	O
D	O
`	O
.	O

You	O
can	O
use	O
`	O
apply	B-API
`	O
for	O
this	O
,	O
and	O
it's	O
a	O
bit	O
neater	O
:	O
#CODE	O

At	O
the	O
moment	O
for	O
conversion	O
I	O
use	O
as	O
below	O
,	O
but	O
need	O
remove	O
unwanted	O
rows	O
first	O
to	O
apply	B-API
it	O
to	O
all	O
df	O
.	O

(	O
The	O
series	O
always	O
got	O
the	O
same	O
length	O
as	O
a	O
dataframe	B-API
.	O
)	O
I	O
tried	O
different	O
versions	O
of	O
`	O
join	B-API
`	O
,	O
`	O
append	B-API
`	O
,	O
`	O
merge	B-API
`	O
,	O
but	O
I	O
did	O
not	O
get	O
it	O
as	O
what	O
I	O
want	O
,	O
only	O
errors	O
at	O
the	O
most	O
.	O

Note	O
my	O
original	O
(	O
very	O
old	O
)	O
suggestion	O
was	O
to	O
use	O
`	O
map	B-API
`	O
(	O
which	O
is	O
much	O
slower	O
):	O
#CODE	O

@USER	O
if	O
you	O
already	O
have	O
`	O
e	O
`	O
as	O
a	O
Series	O
then	O
you	O
don't	O
need	O
to	O
use	O
`	O
map	B-API
`	O
,	O
use	O
`	O
df	O
[	O
'	O
e	O
']	O
=e	O
`	O
(	O
@USER	O
answer	O
)	O
.	O

this	O
will	O
effectively	O
be	O
a	O
left	O
join	B-API
on	O
the	O
df1.index	O
.	O

So	O
if	O
you	O
want	O
to	O
have	O
an	O
outer	O
join	B-API
effect	O
,	O
my	O
probably	O
imperfect	O
solution	O
is	O
to	O
create	O
a	O
dataframe	B-API
with	O
index	O
values	O
covering	O
the	O
universe	O
of	O
your	O
data	O
,	O
and	O
then	O
use	O
the	O
code	O
above	O
.	O

This	O
worked	O
fine	O
to	O
insert	B-API
the	O
column	O
at	O
the	O
end	O
.	O

Then	O
,	O
since	O
you	O
extend	O
the	O
base	O
class	O
,	O
you	O
have	O
to	O
replace	B-API
the	O
methods	O
with	O
a	O
suitable	O
descriptor	O
:	O
#CODE	O

I	O
want	O
to	O
resample	B-API
a	O
TimeSeries	O
in	O
daily	O
(	O
exactly	O
24	O
hours	O
)	O
frequence	O
starting	O
at	O
a	O
certain	O
hour	O
.	O

is	O
there	O
an	O
existing	O
built-in	O
way	O
to	O
apply	B-API
two	O
different	O
aggregating	O
functions	O
to	O
the	O
same	O
column	O
,	O
without	O
having	O
to	O
call	O
`	O
agg	B-API
`	O
multiple	O
times	O
?	O

Is	O
there	O
any	O
other	O
manner	O
for	O
expressing	O
the	O
input	O
to	O
`	O
agg	B-API
`	O
?	O

If	O
you	O
look	O
at	O
the	O
doc	O
string	O
for	O
`	O
aggregate	B-API
`	O
it	O
explicitly	O
says	O
that	O
when	O
a	O
`	O
dict	O
`	O
is	O
passed	O
,	O
the	O
keys	O
must	O
be	O
column	O
names	O
.	O

To	O
get	O
all	O
shank	O
1's	O
(	O
i.e.	O
where	O
the	O
first	O
level	O
of	O
the	O
MultiIndex	B-API
is	O
equal	O
to	O
1	O
)	O
.	O

This	O
is	O
pretty	O
flexible	O
if	O
you	O
need	O
to	O
cross-section	O
by	O
a	O
different	O
level	O
of	O
the	O
MultiIndex	B-API
as	O
well	O
.	O

I	O
think	O
it	O
wight	O
be	O
simpler	O
to	O
completely	O
drop	B-API
this	O
column	O
,	O
and	O
then	O
add	O
a	O
new	O
one	O
with	O
the	O
year	O
,	O
or	O
completely	O
replace	B-API
the	O
values	O
by	O
the	O
year	O
.	O

First	O
,	O
I	O
think	O
you	O
have	O
to	O
either	O
specify	O
named	O
parameters	O
or	O
use	O
`	O
args	O
`	O
to	O
pass	O
additional	O
arguments	O
to	O
`	O
apply	B-API
`	O
.	O

because	O
`	O
apply	B-API
`	O
doesn't	O
act	O
elementwise	O
,	O
it	O
acts	O
on	O
entire	O
Series	O
objects	O
.	O

Is	O
there	O
a	O
grep	O
like	O
built-in	O
function	O
in	O
Pandas	O
to	O
drop	B-API
a	O
row	O
if	O
it	O
has	O
some	O
string	O
or	O
value	O
?	O

Below	O
example	O
will	O
drop	B-API
all	O
rows	O
where	O
column	O
A	O
holds	O
'	O
a	O
'	O
character	O
and	O
'	O
B	O
'	O
equals	O
20	O
.	O

@USER	O
:	O
to	O
drop	B-API
the	O
unmatched	O
condition	O
.	O

You	O
can	O
transform	B-API
the	O
tuple	O
to	O
list	O
with	O
`	O
list	O
(	O
tup	O
)`	O
and	O
do	O
the	O
switch	O
.	O

One	O
way	O
to	O
do	O
this	O
is	O
to	O
use	O
apply	B-API
:	O
#CODE	O

If	O
you	O
want	O
to	O
change	O
the	O
values	O
in	O
only	O
one	O
column	O
you	O
can	O
still	O
use	O
`	O
apply	B-API
`	O
:	O
#CODE	O

`	O
agg	B-API
`	O
is	O
just	O
a	O
shorthand	O
for	O
`	O
aggregate	B-API
`	O
,	O
you	O
are	O
however	O
forcing	O
it	O
to	O
work	O
on	O
single	O
columns	O
always	O
,	O
which	O
works	O
around	O
the	O
issue	O
.	O

This	O
means	O
aggregate	B-API
passes	O
first	O
the	O
2D	O
series	O
in	O
.	O

For	O
things	O
like	O
sum	O
,	O
mean	O
,	O
median	B-API
,	O
max	O
,	O
min	O
,	O
first	O
,	O
last	O
,	O
std	O
,	O
you	O
can	O
call	O
the	O
method	O
directly	O
and	O
not	O
have	O
to	O
worry	O
about	O
the	O
apply-to-DataFrame-but-failover-to-each-column	O
mechanism	O
in	O
the	O
GroupBy	B-API
engine	O
.	O

(	O
what	O
is	O
`	O
pd	O
`	O
and	O
what	O
is	O
`	O
dt	B-API
`)	O
?	O

I	O
replace	B-API
2	O
by	O
1	O
in	O
the	O
isocalendar	O
.	O
the	O
propriety	O
week	O
of	O
TimeStamp	O
is	O
very	O
strange	O
.	O

Use	O
`	O
join	B-API
`	O
:	O
#CODE	O

I	O
do	O
not	O
want	O
to	O
join	B-API
them	O
)	O

I	O
would	O
like	O
to	O
drop	B-API
all	O
non-numeric	O
columns	O
in	O
one	O
fell	O
swoop	O
,	O
without	O
knowing	O
their	O
names	O
or	O
indices	O
,	O
since	O
this	O
could	O
be	O
doable	O
reading	O
their	O
dtype	B-API
.	O

I	O
would	O
like	O
to	O
join	B-API
them	O
side	O
by	O
side	O
resulting	O
in	O
a	O
21	O
cols	O
dataframe	B-API
with	O
the	O
same	O
624	O
number	O
of	O
rows	O
.	O

I	O
have	O
tried	O
several	O
things	O
join	B-API
them	O
by	O
axis=1	O
ignoring	O
index	O
or	O
not	O
.	O

One	O
alternative	O
is	O
to	O
merge	B-API
on	O
'	O
Name	O
'	O
and	O
'	O
L1	O
'	O
:	O
#CODE	O

I	O
had	O
realized	O
that	O
reset	O
would	O
work	O
,	O
however	O
,	O
why	O
to	O
reset	O
index	O
to	O
concat	B-API
dfs	O
ignoring	O
them	O
?	O

At	O
least	O
in	O
`	O
concat	B-API
`	O
,	O
you	O
have	O
to	O
declare	O
axis	O
.	O

Pandas	O
DataFrame	B-API
:	O
apply	B-API
function	O
to	O
all	O
columns	O

How	O
to	O
transpose	B-API
a	O
DataFrame	B-API
returned	O
by	O
concat()	B-API
?	O

you	O
can	O
fill	O
the	O
resampled	O
series	O
sr	O
as	O
following	O
:	O
sr.groupby	O
(	O
sr.index.month	O
)	O
.transform	B-API
(	O
lambda	O
x	O
:	O
x.fillna	O
(	O
method=	O
'	O
backfill	B-API
'))	O

Using	O
your	O
guidance	O
,	O
I	O
was	O
also	O
able	O
to	O
implement	O
the	O
daily	O
average	O
I	O
mentioned	O
:	O
sr.groupby	O
(	O
sr.index.month	O
)	O
.transform	B-API
(	O
lambda	O
x	O
:	O
x.fillna	O
(	O
method=	O
'	O
backfill	B-API
')	O
/	O
len	B-API
(	O
x	O
))	O

No	O
numeric	O
types	O
to	O
aggregate	B-API
-	O
change	O
in	O
groupby()	B-API
behaviour	O
?	O

On	O
0.9	O
,	O
I	O
get	O
No	O
numeric	O
types	O
to	O
aggregate	B-API
errors	O
.	O

I	O
can	O
understand	O
why	O
this	O
might	O
happen	O
,	O
as	O
the	O
weekly	O
dates	O
don't	O
exactly	O
align	B-API
with	O
the	O
monthly	O
dates	O
,	O
and	O
weeks	O
can	O
overlap	O
months	O
.	O

I	O
believe	O
you	O
can	O
use	O
the	O
append	B-API
#CODE	O

Python	O
Pandas	O
:	O
pivot	B-API
table	O
with	O
aggfunc	O
=	O
count	O
unique	O
distinct	O

Note	O
that	O
using	O
`	O
len	B-API
`	O
assumes	O
you	O
don't	O
have	O
`	O
NA	O
`	O
s	O
in	O
your	O
DataFrame	B-API
.	O

You	O
can	O
construct	O
a	O
pivot	B-API
table	O
for	O
each	O
distinct	O
value	O
of	O
`	O
X	O
`	O
.	O

will	O
construct	O
a	O
pivot	B-API
table	O
for	O
each	O
value	O
of	O
`	O
X	O
`	O
.	O

You	O
could	O
also	O
do	O
an	O
inner	O
join	B-API
on	O
stations.id	O
:	O

It	O
was	O
my	O
bad	O
:	O
"	O
on	O
"	O
is	O
only	O
to	O
be	O
used	O
when	O
the	O
columns	O
occur	O
in	O
both	O
DataFrames	O
(	O
so	O
my	O
code	O
was	O
referring	O
to	O
a	O
join	B-API
on	O
both	O
id	O
and	O
start_station_id	O
which	O
is	O
wrong	O
here	O
)	O
.	O

For	O
the	O
reindex	B-API
:	O
non-unique	O
indices	O
are	O
rather	O
new	O
in	O
pandas	O
.	O

Using	O
the	O
same	O
basic	O
loop	O
as	O
above	O
,	O
just	O
append	B-API
the	O
set	O
of	O
every	O
forth	O
row	O
starting	O
at	O
0	O
to	O
3	O
after	O
you	O
run	O
your	O
code	O
above	O
.	O

Here	O
is	O
a	O
solution	O
based	O
on	O
numpy's	O
repeat	O
and	O
array	O
indexing	O
to	O
build	O
de-stacked	O
values	O
,	O
and	O
pandas	O
'	O
merge	B-API
to	O
output	O
the	O
concatenated	O
result	O
.	O

Then	O
build	O
a	O
de-stacked	O
vector	O
of	O
TDRs	O
and	O
merge	B-API
it	O
with	O
the	O
original	O
data	O
frame	O
#CODE	O

i	O
had	O
figured	O
out	O
that	O
i	O
need	O
to	O
pivot	B-API
the	O
first	O
point-in-time	O
timeseries	O
for	O
tickers	O
go	O
into	O
the	O
columns	O
and	O
date	O
into	O
rows	O
and	O
for	O
the	O
second	O
timeseries	O
expand	O
the	O
interval	O
into	O
daily	O
granularity	O
and	O
also	O
pivot	B-API
it	O
(	O
through	O
dataframe.pivot	B-API
function	O
.	O
by	O
combining	O
the	O
two	O
dataframes	O
one	O
can	O
write	O
function	O
i	O
need	O
.	O

I	O
was	O
hoping	O
to	O
get	O
this	O
to	O
work	O
but	O
a	O
pyTable	O
table	O
where	O
does	O
not	O
provide	O
a	O
len	B-API

`	O
reindex	B-API
`	O
realigns	O
the	O
existing	O
index	O
to	O
the	O
given	O
index	O
rather	O
than	O
changing	O
the	O
index	O
.	O

`	O
fhs	O
=	O
fhs.drop	O
([	O
1002	O
])`	O
to	O
drop	B-API
that	O
row	O
and	O
data	O
types	O
are	O
still	O
good	O
.	O

first	O
column	O
comes	O
into	O
df	O
as	O
Yes	O
,	O
No	O
,	O
Yes	O
,	O
Yes	O
type	O
bool	B-API
xxxx	O
below	O

3rd	O
column	O
comes	O
into	O
df	O
as	O
FALSE	O
,	O
FALSE	O
,	O
TRUE	O
,	O
TRUE	O
type	O
bool	B-API

first	O
column	O
comes	O
into	O
df	O
as	O
Yes	O
,	O
No	O
,	O
Yes	O
,	O
Yes	O
type	O
bool	B-API
xxxx	O
below	O

3rd	O
column	O
comes	O
into	O
df	O
as	O
FALSE	O
,	O
FALSE	O
,	O
TRUE	O
,	O
TRUE	O
type	O
bool	B-API

Using	O
the	O
same	O
function	O
with	O
transform	B-API
would	O
work	O
if	O
the	O
'	O
new	O
'	O
column	O
already	O
exists	O
in	O
the	O
df	O
,	O
but	O
how	O
do	O
you	O
add	O
a	O
new	O
column	O
at	O
a	O
specific	O
level	O
'	O
on	O
the	O
fly	O
'	O
or	O
before	O
grouping	O
?	O

Creating	O
a	O
new	O
column	O
based	O
on	O
grouped	O
values	O
is	O
a	O
task	O
for	O
transform	B-API
,	O
but	O
i	O
`	O
m	O
not	O
aware	O
if	O
tranform	O
can	O
output	O
multiple	O
columns	O
.	O

Probably	O
with	O
another	O
method	O
name	O
,	O
to	O
make	O
intent	O
clear	O
(	O
applyfork	O
or	O
something	O
like	O
that	O
,	O
or	O
a	O
keyword	O
splitseq=True	O
in	O
apply	B-API
)	O
.	O

I	O
want	O
to	O
reindex	B-API
all	O
the	O
data	O
frames	O
according	O
to	O
totalColumns	O
.	O

So	O
I	O
used	O
the	O
reindex	B-API
method	O
:	O
#CODE	O

After	O
implementing	O
a	O
custom	O
frequency	O
in	O
pandas	O
by	O
subclassing	O
`	O
DateOffset	O
`	O
,	O
is	O
it	O
possible	O
to	O
"	O
register	O
"	O
an	O
offset	O
alias	O
for	O
that	O
frequency	O
so	O
that	O
the	O
alias	O
can	O
be	O
used	O
in	O
built-in	O
pandas	O
functions	O
such	O
as	O
`	O
date_range	B-API
`	O
and	O
`	O
resample	B-API
`	O
?	O

Basically	O
,	O
I	O
want	O
to	O
mimic	O
R's	O
melt	B-API
/	O
cast	O
without	O
getting	O
into	O
hierarchical	O
indexing	O
or	O
stacked	O
dataframes	O
.	O

Following	O
the	O
official	O
docs	O
you	O
can	O
use	O
loc	B-API
#CODE	O

I	O
read	O
that	O
join	B-API
can	O
handle	O
multiple	O
dataframes	O
,	O
however	O
I	O
get	O
:	O
#CODE	O

I	O
am	O
interested	O
to	O
see	O
if	O
the	O
experts	O
have	O
a	O
more	O
algorithmic	O
approach	O
to	O
merge	B-API
a	O
list	O
of	O
data	O
frames	O
.	O

I	O
would	O
try	O
`	O
pandas.merge	B-API
`	O
instead	O
of	O
`	O
join	B-API
`	O
.	O

Forcing	O
dates	O
to	O
conform	B-API
to	O
a	O
given	O
frequency	O
in	O
pandas	O

Calculate	O
diff	B-API
of	O
a	O
numpy	O
array	O
using	O
custom	O
function	O
instead	O
of	O
subtraction	O

This	O
would	O
give	O
me	O
either	O
a	O
list	O
of	O
distances	O
with	O
`	O
len	B-API
(	O
distances	O
)	O
==	O
coord_array.shape	O
[	O
1	O
]`	O
,	O
or	O
maybe	O
a	O
third	O
column	O
in	O
the	O
same	O
array	O
.	O

It	O
is	O
important	O
to	O
say	O
that	O
I	O
already	O
have	O
a	O
function	O
that	O
returns	O
a	O
distance	O
between	O
two	O
points	O
(	O
two	O
coordinate	O
pairs	O
)	O
,	O
but	O
I	O
don't	O
know	O
how	O
to	O
apply	B-API
it	O
with	O
a	O
single	O
array	O
operation	O
instead	O
of	O
looping	O
through	O
row	O
pairs	O
.	O

How	O
to	O
shift	B-API
a	O
pandas	O
MultiIndex	B-API
Series	O
?	O

In	O
a	O
regular	O
time	O
series	O
you	O
can	O
shift	B-API
it	O
back	O
or	O
forward	O
in	O
time	O
.	O

We	O
can	O
shift	B-API
it	O
with	O
:	O
#CODE	O

but	O
not	O
sure	O
how	O
to	O
proceed	O
from	O
here	O
,	O
and	O
how	O
to	O
join	B-API
the	O
new	O
column	O
back	O
to	O
the	O
original	O
data	O
frame	O
.	O

Based	O
on	O
the	O
values	O
in	O
two	O
columns	O
merge	B-API
values	O
in	O
other	O
columns	O

One	O
way	O
I	O
am	O
thinking	O
of	O
is	O
to	O
use	O
nested	O
loops	O
:	O
outer	O
loop	O
read	O
the	O
lines	O
sequentially	O
and	O
the	O
inner	O
loop	O
reads	O
all	O
lines	O
from	O
the	O
begining	O
and	O
look	O
for	O
map	B-API
.	O

The	O
zlib	O
header	O
is	O
fixed	O
at	O
two	O
bytes	O
and	O
the	O
trailer	O
at	O
four	O
bytes	O
,	O
so	O
those	O
are	O
easy	O
to	O
strip	B-API
.	O

Then	O
you	O
can	O
prepend	O
a	O
basic	O
gzip	O
header	O
of	O
ten	O
bytes	O
:	O
`"	O
\x1f\x	O
8b	O
\x0	O
8\	O
0\0\0\0\0\0\xff	O
"`	O
(	O
C	O
string	O
format	O
)	O
and	O
append	B-API
a	O
four-byte	O
CRC	O
in	O
little-endian	O
order	O
.	O

Unfortunately	O
,	O
I	O
don't	O
think	O
Pandas	O
allows	O
one	O
to	O
drop	B-API
dups	O
off	O
the	O
indices	O
.	O

I	O
am	O
trying	O
to	O
transform	B-API
DataFrame	B-API
,	O
such	O
that	O
some	O
of	O
the	O
rows	O
will	O
be	O
replicated	O
a	O
given	O
number	O
of	O
times	O
.	O

One	O
possibility	O
might	O
be	O
to	O
allow	O
`	O
DataFrame.applymap	B-API
`	O
function	O
return	O
multiple	O
rows	O
(	O
akin	O
`	O
apply	B-API
`	O
method	O
of	O
`	O
GroupBy	B-API
`)	O
.	O

How	O
I	O
do	O
find	O
median	B-API
using	O
pandas	O
on	O
a	O
dataset	O
?	O

You	O
could	O
try	O
applying	O
your	O
own	O
median	B-API
function	O
to	O
see	O
if	O
you	O
can	O
work	O
around	O
the	O
cause	O
of	O
the	O
error	O
,	O
something	O
like	O
:	O
#CODE	O

Here	O
is	O
a	O
different	O
approach	O
,	O
you	O
can	O
add	O
the	O
median	B-API
back	O
to	O
your	O
original	O
dataframe	B-API
,	O
the	O
median	B-API
for	O
the	O
metric	O
column	O
becomes	O
:	O
#CODE	O

Wether	O
its	O
useful	O
to	O
have	O
the	O
median	B-API
of	O
the	O
group	O
attached	O
to	O
each	O
datapoint	O
depends	O
a	O
bit	O
what	O
you	O
want	O
to	O
do	O
afterwards	O
.	O

Any	O
idea	O
how	O
to	O
resample	B-API
by	O
an	O
index	O
?	O

I	O
started	O
a	O
github	O
issue	O
to	O
maybe	O
think	O
about	O
adding	O
in	O
additional	O
parameters	O
to	O
resample	B-API
.	O

Wes	O
replied	O
saying	O
he	O
plans	O
to	O
extend	O
`	O
resample	B-API
`	O
like	O
this	O
eventually	O
.	O

Or	O
use	O
a	O
boolean	O
mask	B-API
:	O
data.A	O
[	O
data.index.get_level_values	O
(	O
1	O
)	O
==	O
2	O
]	O
=	O
0	O

I've	O
played	O
around	O
with	O
groupby	B-API
and	O
transpose	B-API
to	O
no	O
avail	O
,	O
any	O
tips	O
would	O
be	O
great	O
appreciated	O
.	O

I	O
suppose	O
I	O
could	O
loop	O
through	O
and	O
append	B-API
to	O
the	O
DataFrame	B-API
,	O
however	O
I	O
feel	O
like	O
there	O
should	O
be	O
a	O
much	O
smarter	O
method	O
to	O
doing	O
this	O
.	O

Could	O
you	O
upload	O
an	O
example	O
of	O
when	O
it	O
saves	O
with	O
the	O
graph	O
cut	B-API
off	O
?	O

How	O
do	O
I	O
stack	B-API
two	O
DataFrames	O
next	O
to	O
each	O
other	O
in	O
Pandas	O
?	O

And	O
I	O
want	O
to	O
do	O
a	O
rolling	B-API
average	O
for	O
all	O
columns	O
,	O
after	O
groupby	B-API
`	O
STK_ID	O
`	O
,	O
the	O
rule	O
expressed	O
by	O
pseudocode	O
like	O
:	O
#CODE	O

I	O
notice	O
Pandas	O
can	O
apply	B-API
different	O
function	O
to	O
different	O
column	O
by	O
passing	O
a	O
dict	O
.	O

To	O
get	O
the	O
ultimate	O
perf	O
you'd	O
want	O
to	O
drop	B-API
down	O
into	O
C	O
or	O
Cython	O
and	O
build	O
the	O
raw	O
byte	O
string	O
yourself	O
using	O
C	O
string	O
functions	O
.	O

How	O
to	O
apply	B-API
condition	O
on	O
level	O
of	O
pandas.multiindex	B-API
?	O

I.e.	O
,	O
I	O
would	O
like	O
to	O
apply	B-API
np.mean	O
over	O
all	O
counts	O
of	O
the	O
detectors	O
of	O
1	O
channel	O
at	O
each	O
time	O
separately	O
.	O

Other	O
aggregation	O
functions	O
can	O
be	O
passed	O
via	O
`	O
agg	B-API
`	O
:	O
#CODE	O

(	O
after	O
diving	O
in	O
Pandas	O
doc	O
,	O
I	O
think	O
`	O
cut	B-API
`	O
function	O
can	O
help	O
me	O
because	O
it's	O
a	O
discretization	O
problem	O
...	O
but	O
I'm	O
don't	O
understand	O
how	O
to	O
use	O
it	O
)	O

to	O
plot	O
the	O
results	O
you	O
can	O
use	O
the	O
matplotlib	O
function	O
hist	B-API
,	O
but	O
if	O
you	O
are	O
working	O
in	O
pandas	O
each	O
Series	O
has	O
its	O
own	O
handle	O
to	O
the	O
hist	B-API
function	O
,	O
and	O
you	O
can	O
give	O
it	O
the	O
chosen	O
binning	O
:	O
#CODE	O

I	O
suspect	O
that	O
I	O
need	O
to	O
use	O
searchsort	O
and	O
asof	B-API
,	O
but	O
I	O
am	O
not	O
quite	O
sure	O
how	O
to	O
do	O
that	O
with	O
.	O

You're	O
looking	O
for	O
a	O
near	O
timestamp	O
,	O
where	O
`	O
asof	B-API
`	O
searches	O
for	O
the	O
latest	O
timestamp	O
.	O

It	O
is	O
only	O
applied	O
to	O
a	O
time	O
series	O
,	O
so	O
you	O
would	O
have	O
to	O
apply	B-API
`	O
reset_index	B-API
`	O
to	O
your	O
`	O
DataFrame	B-API
`	O

This	O
can	O
be	O
accomplished	O
quite	O
simply	O
with	O
the	O
DataFrame	B-API
method	O
`	O
apply	B-API
`	O
.	O

`	O
df.apply	B-API
`	O
acts	O
column-wise	O
by	O
default	O
,	O
but	O
it	O
can	O
can	O
also	O
act	O
row-wise	O
by	O
passing	O
`	O
axis=1	O
`	O
as	O
an	O
argument	O
to	O
`	O
apply	B-API
`	O
.	O

This	O
could	O
be	O
done	O
more	O
concisely	O
by	O
defining	O
the	O
anonymous	O
function	O
inside	O
`	O
apply	B-API
`	O
#CODE	O

to	O
find	O
a	O
way	O
to	O
group	O
the	O
data	O
in	O
a	O
way	O
that	O
I	O
can	O
aggregate	B-API
the	O
time	O
column	O
`	O
D_Time	O
`	O

Most	O
efficient	O
way	O
to	O
shift	B-API
MultiIndex	B-API
time	O
series	O

You	O
can	O
verify	O
it's	O
been	O
lagged	O
by	O
one	O
period	O
(	O
you	O
want	O
shift	B-API
(	O
1	O
)	O
instead	O
of	O
shift	B-API
(	O
-1	O
)):	O
#CODE	O

(	O
And	O
I	O
did	O
mean	O
shift	B-API
(	O
-1	O
);	O
it's	O
a	O
hazard	O
rate	O
calculation	O
,	O
so	O
it's	O
forward-looking	O
.	O
)	O

How	O
do	O
I	O
resample	B-API
/	O
align	B-API
a	O
pandas	O
timeseries	O
to	O
the	O
closest	O
calendar	O
quarters	O
?	O

Also	O
,	O
is	O
there	O
any	O
way	O
I	O
can	O
get	O
it	O
to	O
align	B-API
to	O
Dec	O
/	O
Mar	O
(	O
which	O
seem	O
to	O
be	O
closer	O
to	O
the	O
original	O
dates	O
)	O
with	O
the	O
timeseries	O
functions	O
?	O

I	O
know	O
no	O
easy	O
solution	O
to	O
get	O
to	O
align	B-API
to	O
the	O
closest	O
and	O
I	O
find	O
the	O
current	O
version	O
quite	O
logical	O
.	O

I	O
rewrote	O
the	O
answer	O
to	O
remove	O
the	O
map	B-API
function	O
as	O
it	O
was	O
more	O
confusing	O
than	O
helpful	O
.	O
thank	O
you	O
for	O
your	O
answer	O

The	O
goal	O
is	O
to	O
align	B-API
the	O
data	O
to	O
calendar	O
quarter	O
markers	O
so	O
the	O
3	O
data	O
sets	O
can	O
be	O
compared	O
.	O

The	O
above	O
gives	O
me	O
what	O
I	O
want	O
,	O
aggregate	B-API
stats	O
on	O
julian	O
day	O
of	O
the	O
year	O
BUT	O
I	O
would	O
then	O
like	O
to	O
reorder	O
the	O
group	O
so	O
the	O
last	O
half	O
(	O
183	O
days	O
)	O
is	O
placed	O
in	O
front	O
of	O
the	O
1st	O
half	O
.	O

Why	O
not	O
just	O
reindex	B-API
the	O
result	O
?	O

I	O
think	O
the	O
easiest	O
way	O
to	O
do	O
this	O
is	O
to	O
`	O
join	B-API
`	O
on	O
index	O
.	O

I've	O
got	O
some	O
radar	O
data	O
that's	O
in	O
a	O
bit	O
of	O
an	O
odd	O
format	O
,	O
and	O
I	O
can't	O
figure	O
out	O
how	O
to	O
correctly	O
pivot	B-API
it	O
using	O
the	O
pandas	O
library	O
.	O

Note	O
that	O
I	O
did	O
not	O
set	O
`	O
loc	B-API
`	O
as	O
the	O
index	O
yet	O
so	O
it	O
uses	O
an	O
autoincrement	O
integer	O
index	O
.	O

However	O
,	O
if	O
your	O
data	O
frame	O
is	O
already	O
using	O
`	O
loc	B-API
`	O
as	O
the	O
index	O
,	O
we	O
will	O
need	O
to	O
append	B-API
the	O
`	O
time	B-API
`	O
column	O
into	O
it	O
so	O
that	O
we	O
have	O
a	O
loc-time	O
hierarchal	O
index	O
.	O

If	O
I	O
transpose	B-API
the	O
input	O
to	O
model.predict	O
,	O
I	O
do	O
get	O
a	O
result	O
but	O
with	O
a	O
shape	O
of	O
(	O
426,213	O
)	O
,	O
so	O
I	O
suppose	O
its	O
wrong	O
as	O
well	O
(	O
I	O
expect	O
one	O
vector	O
of	O
213	O
numbers	O
as	O
label	O
predictions	O
):	O
#CODE	O

The	O
input	O
data	O
for	O
my	O
multiindex	B-API
attempt	O
looked	O
like	O
this	O
:	O
#CODE	O

Maybe	O
the	O
multiindex	B-API
approach	O
is	O
totally	O
wrong	O
,	O
but	O
it's	O
one	O
thing	O
I	O
tried	O
.	O

I	O
found	O
a	O
way	O
using	O
`	O
join	B-API
`	O
:	O
#CODE	O

Thanks	O
,	O
the	O
map	B-API
method	O
seems	O
pretty	O
powerful	O
.	O

I	O
would	O
like	O
to	O
apply	B-API
a	O
function	O
to	O
a	O
dataframe	B-API
and	O
receive	O
a	O
single	O
dictionary	O
as	O
a	O
result	O
.	O
pandas.apply	O
gives	O
me	O
a	O
Series	O
of	O
dicts	O
,	O
and	O
so	O
currently	O
I	O
have	O
to	O
combine	O
keys	O
from	O
each	O
.	O

I	O
had	O
overlooked	O
`	O
map	B-API
`	O
completely	O
,	O
and	O
my	O
rewritten	O
function	O
is	O
much	O
cleaner	O
now	O
.	O

There	O
seem	O
to	O
be	O
a	O
lot	O
of	O
possibilities	O
to	O
pivot	B-API
flat	O
table	O
data	O
into	O
a	O
3d	O
array	O
but	O
I'm	O
somehow	O
not	O
finding	O
one	O
that	O
works	O
:	O
Suppose	O
I	O
have	O
some	O
data	O
with	O
columns	O
=[	O
'	O
name	O
'	O
,	O
'	O
type	O
'	O
,	O
'	O
date	O
'	O
,	O
'	O
value	O
']	O
.	O

When	O
I	O
try	O
to	O
pivot	B-API
via	O
#CODE	O

You	O
probably	O
want	O
to	O
use	O
`	O
pivot_table	B-API
`	O
to	O
generate	O
a	O
pivot	B-API
table	O
using	O
multiple	O
columns	O
e.g.	O
#CODE	O

However	O
,	O
my	O
goal	O
is	O
to	O
be	O
able	O
to	O
use	O
a	O
row-wise	O
function	O
in	O
the	O
`	O
DataFrame.apply()	B-API
`	O
method	O
(	O
so	O
I	O
can	O
apply	B-API
the	O
desired	O
functionality	O
to	O
other	O
functions	O
I	O
build	O
)	O
.	O

Row-wise	O
functionality	O
should	O
be	O
possible	O
with	O
apply	B-API
.	O

If	O
you	O
have	O
a	O
key	O
that	O
is	O
repeated	O
for	O
each	O
row	O
,	O
then	O
you	O
can	O
produce	O
a	O
cartesian	O
product	O
using	O
merge	B-API
(	O
like	O
you	O
would	O
in	O
SQL	O
)	O
.	O

This	O
won't	O
win	O
a	O
code	O
golf	O
competition	O
,	O
and	O
borrows	O
from	O
the	O
previous	O
answers	O
-	O
but	O
clearly	O
shows	O
how	O
the	O
key	O
is	O
added	O
,	O
and	O
how	O
the	O
join	B-API
works	O
.	O

So	O
,	O
I	O
created	O
a	O
list	O
of	O
all	O
the	O
weeks	O
I	O
wanted	O
to	O
have	O
,	O
then	O
a	O
list	O
of	O
all	O
the	O
store	O
IDs	O
I	O
wanted	O
to	O
map	B-API
them	O
against	O
.	O

`	O
combine_first	B-API
`	O
is	O
not	O
actually	O
an	O
`	O
append	B-API
`	O
operation	O
.	O

What	O
would	O
be	O
a	O
way	O
to	O
read	O
this	O
file	O
and	O
align	B-API
the	O
date	O
/	O
values	O
?	O

Just	O
replace	B-API
`'	O
/	O
Users	O
/	O
spencerlyon2	O
/	O
Desktop	O
/	O
test.csv	O
'`	O
with	O
the	O
path	O
to	O
your	O
file	O

How	O
can	O
I	O
replace	B-API
all	O
the	O
NaN	O
values	O
with	O
Zero's	O
in	O
a	O
column	O
of	O
a	O
pandas	O
dataframe	B-API

I	O
have	O
also	O
looked	O
at	O
this	O
article	O
How	O
do	O
I	O
replace	B-API
NA	O
values	O
with	O
zeros	O
in	O
R	O
?	O

Also	O
,	O
this	O
is	O
a	O
complex	O
example	O
(	O
though	O
I	O
really	O
ran	O
into	O
it	O
)	O
,	O
but	O
the	O
same	O
may	O
apply	B-API
to	O
fewer	O
levels	O
of	O
indexes	O
depending	O
on	O
how	O
you	O
slice	O
.	O

Merge	B-API
parameters	O
for	O
Pandas	O

I	O
have	O
a	O
loop	O
in	O
Python	O
which	O
sequentially	O
imports	O
CSV	O
files	O
,	O
assigns	O
them	O
to	O
a	O
temporary	O
DataFrame	B-API
object	O
and	O
then	O
attempts	O
to	O
merge	B-API
/	O
concact	O
them	O
to	O
a	O
'	O
master	O
'	O
DataFrame	B-API
.	O

The	O
MLS_Stats	O
DF	O
is	O
initially	O
empty	O
,	O
which	O
is	O
the	O
reasoning	O
for	O
the	O
if	O
loop	O
,	O
since	O
I	O
don't	O
think	O
you	O
can	O
merge	B-API
a	O
DF	O
with	O
an	O
empty	O
DF	O
.	O

You	O
can	O
filter	O
duplicate	O
rows	O
with	O
`	O
drop_duplicates	B-API
`	O
,	O
and	O
select	O
to	O
join	B-API
only	O
columns	O
that	O
are	O
not	O
yet	O
present	O
.	O

You	O
can	O
use	O
the	O
append	B-API
function	O
to	O
add	O
another	O
element	O
to	O
it	O
.	O

Only	O
,	O
make	O
a	O
series	O
of	O
the	O
new	O
element	O
,	O
before	O
you	O
append	B-API
it	O
:	O
#CODE	O

How	O
to	O
apply	B-API
a	O
function	O
to	O
two	O
columns	O
of	O
Pandas	O
dataframe	B-API

Now	O
I	O
want	O
to	O
apply	B-API
the	O
`	O
f	O
`	O
to	O
`	O
df	O
`'	O
s	O
two	O
columns	O
`'	O
col_1	O
'	O
,	O
'	O
col_2	O
'`	O
to	O
element-wise	O
calculate	O
a	O
new	O
column	O
`'	O
col_3	O
'`	O
,	O
somewhat	O
like	O
:	O
#CODE	O

can	O
you	O
apply	B-API
f	O
directly	O
to	O
columns	O
:	O
df	O
[	O
'	O
col_3	O
']	O
=	O
f	O
(	O
df	O
[	O
'	O
col_1	O
']	O
,	O
df	O
[	O
'	O
col_2	O
'])	O

Here's	O
an	O
example	O
using	O
`	O
apply	B-API
`	O
on	O
the	O
dataframe	B-API
,	O
which	O
I	O
am	O
calling	O
with	O
`	O
axis	O
=	O
1	O
`	O
.	O

Depending	O
on	O
your	O
use	O
case	O
,	O
it	O
is	O
sometimes	O
helpful	O
to	O
create	O
a	O
pandas	O
`	O
group	O
`	O
object	O
,	O
and	O
then	O
use	O
`	O
apply	B-API
`	O
on	O
the	O
group	O
.	O

Yes	O
,	O
i	O
tried	O
to	O
use	O
apply	B-API
,	O
but	O
can't	O
find	O
the	O
valid	O
syntax	O
expression	O
.	O

Since	O
you	O
haven't	O
provided	O
the	O
body	O
of	O
f	O
I	O
can't	O
help	O
in	O
anymore	O
detail	O
-	O
but	O
this	O
should	O
provide	O
the	O
way	O
out	O
without	O
fundamentally	O
changing	O
your	O
code	O
or	O
using	O
some	O
other	O
methods	O
rather	O
than	O
apply	B-API

align	B-API
edge	O
(	O
default	O
)	O
|	O
center	O

For	O
vertical	O
bars	O
,	O
align	B-API
=	O
edge	O
aligns	O
bars	O
by	O
their	O
left	O
edges	O
in	O
left	O
,	O
while	O
align	B-API
=	O
center	O
interprets	O
these	O
values	O
as	O
the	O
x	O
coordinates	O
of	O
the	O
bar	O
centers	O
.	O

So	O
adding	O
try	O
adding	O
the	O
keyword	O
align	B-API
=	O
'	O
center	O
'	O
to	O
you	O
first	O
plot	O
call	O
and	O
that	O
might	O
get	O
aligned	O
your	O
x-axis	O
.	O

As	O
a	O
work-around	O
,	O
I'm	O
probably	O
going	O
to	O
simply	O
import	O
from	O
my	O
target	O
sql	O
and	O
do	O
a	O
join	B-API
.	O

I	O
feel	O
as	O
though	O
I'm	O
missing	O
a	O
more	O
elegant	O
solution	O
involving	O
a	O
join	B-API
.	O

I	O
used	O
`	O
loffset=	O
'	O
-1M	O
'`	O
to	O
tell	O
pandas	O
to	O
aggregate	B-API
one	O
period	O
earlier	O
than	O
its	O
default	O
(	O
moved	O
us	O
to	O
Jan-Jun	O
)	O
.	O

Assuming	O
you	O
had	O
a	O
`	O
DateTimeIndex	B-API
`	O
with	O
regular	O
frequency	O
you	O
could	O
always	O
use	O
`	O
df.resample	B-API
`	O
to	O
aggregate	B-API
the	O
data	O
at	O
another	O
regular	O
frequency	O
(	O
like	O
every	O
two	O
months	O
)	O
and	O
then	O
use	O
`	O
df.pct_change()	B-API
`	O
to	O
get	O
the	O
returns	O
.	O

Also	O
there	O
are	O
various	O
options	O
for	O
`	O
pct_change()	B-API
`	O
[	O
see	O
`	O
periods	O
`	O
,	O
`	O
freq	B-API
`]	O
that	O
allow	O
you	O
to	O
specify	O
how	O
many	O
data	O
points	O
should	O
be	O
used	O
to	O
compute	O
the	O
returns	O
(	O
`	O
periods	O
`	O
defaults	O
to	O
1	O
,	O
which	O
is	O
why	O
the	O
solution	O
gave	O
the	O
same	O
answer	O
as	O
your	O
function	O
)	O
.	O

Because	O
you	O
have	O
a	O
relatively	O
small	O
data	O
set	O
,	O
the	O
easiest	O
way	O
is	O
to	O
resample	B-API
on	O
the	O
parameters	O
that	O
you	O
need	O
to	O
calculate	O
the	O
data	O
on	O
then	O
use	O
the	O
`	O
pct_change()	B-API
`	O
function	O
again	O
.	O

However	O
,	O
after	O
you've	O
read	O
it	O
in	O
,	O
you	O
could	O
strip	B-API
out	O
the	O
whitespace	O
by	O
doing	O
,	O
e.g.	O
,	O
`	O
df	O
[	O
"	O
Make	O
"]	O
=	O
df	O
[	O
"	O
Make	O
"]	O
.map	B-API
(	O
str.strip	B-API
)`	O
(	O
where	O
`	O
df	O
`	O
is	O
your	O
dataframe	B-API
)	O
.	O

I	O
don't	O
have	O
enough	O
reputation	O
to	O
leave	O
a	O
comment	O
,	O
but	O
the	O
answer	O
above	O
suggesting	O
using	O
the	O
map	B-API
function	O
along	O
with	O
strip	B-API
won't	O
work	O
if	O
you	O
have	O
NaN	O
values	O
,	O
since	O
strip	B-API
only	O
works	O
on	O
chars	O
and	O
NaN	O
are	O
floats	O
.	O

pandas	O
:	O
slice	O
a	O
MultiIndex	B-API
by	O
range	O
of	O
secondary	O
index	O

not	O
sure	O
if	O
this	O
is	O
ideal	O
but	O
it	O
works	O
by	O
creating	O
a	O
mask	B-API
#CODE	O

Use	O
`	O
ix	B-API
`	O
:	O
#CODE	O

That	O
said	O
,	O
I	O
kinda	O
disagree	O
with	O
the	O
docs	O
that	O
ix	B-API
is	O
:	O

use	O
loc	B-API
for	O
labels	O

use	O
ix	B-API
for	O
both	O
(	O
if	O
you	O
really	O
have	O
to	O
)	O

Surprisingly	O
(	O
for	O
me	O
at	O
least	O
)	O
,	O
although	O
comparable	O
for	O
small	O
Series	O
,	O
this	O
starts	O
to	O
become	O
slower	O
than	O
using	O
`	O
ix	B-API
`	O
when	O
the	O
Series	O
is	O
longer	O
than	O
250	O
.	O

you	O
can	O
also	O
use	O
a	O
mask	B-API
:	O

Using	O
a	O
mask	B-API
is	O
my	O
fallback	O
option	O
,	O
at	O
this	O
point	O
=)	O

I	O
want	O
to	O
do	O
a	O
rolling	B-API
computation	O
on	O
missing	O
data	O
.	O

I	O
think	O
a	O
partial	O
answer	O
to	O
this	O
question	O
is	O
probably	O
via	O
using	O
the	O
keyword	O
argument	O
min_periods	O
in	O
the	O
rolling	B-API
apply	B-API
function	O
.	O

Finally	O
,	O
to	O
drop	B-API
by	O
index	O
instead	O
of	O
by	O
name	O
,	O
try	O
this	O
to	O
delete	O
,	O
e.g.	O
the	O
1st	O
,	O
2nd	O
and	O
4th	O
columns	O
:	O
#CODE	O

I	O
think	O
in	O
version	O
0.16.2	O
drop	B-API
by	O
index	O
doesn't	O
work	O
-	O
do	O
nothing	O
.	O

`	O
notnull	B-API
`	O
is	O
also	O
what	O
Wes	O
(	O
author	O
of	O
Pandas	O
)	O
suggested	O
in	O
his	O
comment	O
on	O
another	O
answer	O
.	O

Though	O
of	O
course	O
that	O
will	O
drop	B-API
rows	O
with	O
negative	O
numbers	O
,	O
too	O
.	O

You	O
can	O
use	O
groupby	B-API
and	O
then	O
apply	B-API
to	O
achieve	O
what	O
you	O
want	O
:	O
#CODE	O

I	O
think	O
you	O
want	O
to	O
`	O
resample	B-API
`	O
your	O
dataframe	B-API
,	O
but	O
I'm	O
not	O
sure	O
.	O

My	O
actual	O
goal	O
is	O
to	O
use	O
`	O
groupby	B-API
`	O
,	O
`	O
crosstab	B-API
`	O
and	O
/	O
or	O
`	O
resample	B-API
`	O
to	O
calculate	O
values	O
for	O
each	O
period	O
based	O
on	O
sums	O
/	O
means	O
/	O
etc	O
of	O
individual	O
entries	O
within	O
the	O
period	O
.	O

In	O
other	O
words	O
,	O
I	O
want	O
to	O
transform	B-API
data	O
from	O
:	O
#CODE	O

But	O
you	O
can	O
use	O
`	O
.shift	B-API
`	O
to	O
shift	B-API
it	O
by	O
any	O
number	O
of	O
days	O
(	O
or	O
any	O
frequency	O
for	O
that	O
matter	O
):	O
#CODE	O

However	O
,	O
this	O
doesn't	O
help	O
with	O
resampling	O
on	O
a	O
range	O
,	O
as	O
resample	B-API
will	O
still	O
use	O
bins	O
aligned	O
to	O
the	O
beginning	O
of	O
the	O
month	O
AFAIK	O
.	O

I	O
don't	O
have	O
a	O
simple	O
workaround	O
for	O
you	O
at	O
the	O
moment	O
because	O
`	O
resample	B-API
`	O
requires	O
passing	O
a	O
known	O
frequency	O
rule	O
.	O

I	O
want	O
to	O
find	O
all	O
values	O
in	O
a	O
Pandas	O
dataframe	B-API
that	O
contain	O
whitespace	O
(	O
any	O
arbitrary	O
amount	O
)	O
and	O
replace	B-API
those	O
values	O
with	O
NaNs	O
.	O

I	O
loop	O
through	O
each	O
column	O
and	O
do	O
boolean	O
replacement	O
against	O
a	O
column	O
mask	B-API
generated	O
by	O
applying	O
a	O
function	O
that	O
does	O
a	O
regex	O
search	O
of	O
each	O
value	O
,	O
matching	O
on	O
whitespace	O
.	O

And	O
finally	O
,	O
this	O
code	O
sets	O
the	O
target	O
strings	O
to	O
None	O
,	O
which	O
works	O
with	O
Pandas	O
'	O
functions	O
like	O
fillna()	B-API
,	O
but	O
it	O
would	O
be	O
nice	O
for	O
completeness	O
if	O
I	O
could	O
actually	O
insert	B-API
a	O
NaN	O
directly	O
instead	O
of	O
None	O
.	O

Edit	O
:	O
If	O
you've	O
already	O
created	O
your	O
dict	O
as	O
in	O
your	O
edited	O
post	O
,	O
just	O
use	O
`	O
d	O
[	O
'	O
Borough	O
']	O
=	O
d.City.map	O
(	O
paired	O
[	O
'	O
Borough	O
'])`	O
to	O
map	B-API
each	O
city	O
to	O
the	O
borough	O
from	O
your	O
dict	O
.	O

`	O
map	B-API
`	O
is	O
a	O
useful	O
method	O
to	O
know	O
about	O
.	O

It	O
can	O
map	B-API
values	O
either	O
with	O
a	O
Pandas	O
series	O
,	O
with	O
a	O
dict	O
,	O
or	O
with	O
a	O
function	O
that	O
returns	O
the	O
mapped	O
value	O
given	O
the	O
key	O
.	O

i	O
usually	O
just	O
use	O
a	O
mask	B-API
and	O
then	O
select	O
the	O
cols	O
i	O
need	O

Of	O
course	O
I	O
can	O
just	O
manually	O
replace	B-API
the	O
truncated	O
words	O
,	O
but	O
I'm	O
curious	O
to	O
know	O
what	O
the	O
cause	O
is	O
?	O

This	O
isn't	O
exclusive	O
to	O
Pandas	O
;	O
in	O
general	O
,	O
any	O
numpy	O
operation	O
will	O
be	O
much	O
faster	O
if	O
you	O
treat	O
arrays	O
and	O
matrices	O
in	O
aggregate	B-API
instead	O
of	O
calling	O
Python	O
functions	O
or	O
inner	O
loops	O
on	O
individual	O
items	O
.	O

In	O
0.15	O
this	O
will	O
be	O
vailable	O
in	O
the	O
dt	B-API
attribute	O
(	O
along	O
with	O
other	O
datetime	O
methods	O
):	O
#CODE	O

With	O
more	O
complicated	O
selections	O
like	O
this	O
one	O
you	O
can	O
use	O
`	O
apply	B-API
`	O
:	O
#CODE	O

I	O
tried	O
to	O
apply	B-API
'	O
manually	O
'	O
the	O
function	O
recursively	O
to	O
see	O
if	O
some	O
of	O
the	O
dates	O
passed	O
as	O
the	O
x	O
parameter	O
in	O
the	O
lambda	O
definition	O
where	O
wrong	O
,	O
but	O
managed	O
to	O
get	O
correct	O
results	O
any	O
time	O
.	O

But	O
the	O
`	O
apply	B-API
`	O
method	O
just	O
seem	O
not	O
to	O
work	O
anymore	O
,	O
and	O
cannot	O
understand	O
why	O
.	O

I	O
think	O
the	O
OP's	O
primary	O
concern	O
is	O
with	O
the	O
division	O
,	O
not	O
the	O
shift	B-API
.	O

Aah	O
,	O
shift	B-API
is	O
what	O
i	O
needed	O
.	O

Python	O
pandas	O
insert	B-API
long	O
integer	O

I'm	O
trying	O
to	O
insert	B-API
long	O
integers	O
in	O
a	O
Pandas	O
Dataframe	B-API
#CODE	O

When	O
I	O
"	O
resample	B-API
"	O
my	O
daily	O
averages	O
to	O
monthly	O
and	O
then	O
plot	O
both	O
,	O
I	O
notice	O
a	O
big	O
time	O
offset	O
.	O

I	O
need	O
to	O
join	B-API
it	O
with	O
some	O
reference	O
tables	O
that	O
I	O
have	O
access	O
via	O
a	O
pyodbc	O
connection	O
.	O

Why	O
not	O
try	O
the	O
`	O
concat	B-API
`	O
function	O
:	O
#CODE	O

Note	O
:	O
the	O
`	O
concat	B-API
`	O
does	O
have	O
some	O
additional	O
options	O
if	O
you	O
have	O
slightly	O
different	O
requirements	O
.	O

The	O
`	O
and	O
`	O
and	O
`	O
or	O
`	O
operators	O
are	O
special	O
in	O
Python	O
and	O
don't	O
interact	O
well	O
with	O
things	O
like	O
numpy	O
and	O
pandas	O
that	O
try	O
to	O
apply	B-API
to	O
them	O
elementwise	O
across	O
a	O
collection	O
.	O

However	O
,	O
if	O
I	O
do	O
the	O
same	O
in	O
a	O
MultiIndex	B-API
column	O
DataFrame	B-API
,	O
then	O
I	O
get	O
a	O
crash	O
.	O

build	O
dataframes	O
for	O
each	O
user	O
and	O
concat	B-API
,	O
very	O
clever	O
!	O

How	O
to	O
keep	O
MultiIndex	B-API
when	O
using	O
pandas	O
merge	B-API

A	O
similar	O
question	O
was	O
asked	O
in	O
How	O
to	O
keep	O
index	O
when	O
using	O
pandas	O
merge	B-API
,	O
but	O
it	O
will	O
not	O
work	O
with	O
MultiIndexes	O
,	O
i.e	O
,	O
#CODE	O

(	O
It	O
would	O
have	O
to	O
be	O
exactly	O
there	O
,	O
if	O
the	O
shift	B-API
was	O
detected	O
a	O
step	O
later	O
,	O
wouldn't	O
matter	O
.	O
)	O

yes	O
,	O
df1	O
+	O
df2	O
will	O
try	O
and	O
align	B-API
the	O
columns	O
.	O

Define	O
the	O
function	O
you	O
want	O
to	O
apply	B-API
.	O

Then	O
,	O
apply	B-API
it	O
.	O

Was	O
wondering	O
if	O
the	O
pandas	O
pivot	B-API
had	O
any	O
similar	O
built	O
in	O
functionality	O
.	O

Efficient	O
way	O
to	O
apply	B-API
multiple	O
filters	O
to	O
pandas	O
DataFrame	B-API
or	O
Series	O

I	O
have	O
a	O
scenario	O
where	O
a	O
user	O
wants	O
to	O
apply	B-API
several	O
filters	O
to	O
a	O
Pandas	O
DataFrame	B-API
or	O
Series	O
object	O
.	O

I	O
want	O
to	O
take	O
a	O
dictionary	O
of	O
the	O
following	O
form	O
and	O
apply	B-API
each	O
operation	O
to	O
a	O
given	O
Series	O
object	O
and	O
return	O
a	O
'	O
filtered	O
'	O
Series	O
object	O
.	O

My	O
example	O
could	O
do	O
something	O
like	O
`	O
df	O
[(	O
ge	B-API
(	O
df	O
[	O
'	O
col1	O
']	O
,	O
1	O
)	O
&	O
le	O
(	O
df	O
[	O
'	O
col1	O
']	O
,	O
1	O
)]`	O
.	O

Maybe	O
I	O
could	O
add	O
each	O
intermediate	O
boolean	O
array	O
to	O
a	O
big	O
array	O
and	O
then	O
just	O
use	O
`	O
map	B-API
`	O
to	O
apply	B-API
the	O
`	O
and	O
`	O
operator	O
to	O
them	O
?	O

The	O
call	O
to	O
`	O
reindex_like()	B-API
`	O
inserts	O
some	O
NaN	O
data	O
into	O
the	O
series	O
so	O
the	O
`	O
dtype	B-API
`	O
of	O
that	O
series	O
changes	O
from	O
`	O
bool	B-API
`	O
to	O
`	O
object	O
`	O
.	O

I	O
have	O
two	O
DataFrames	O
which	O
I	O
want	O
to	O
merge	B-API
based	O
on	O
a	O
column	O
.	O

However	O
,	O
due	O
to	O
alternate	O
spellings	O
,	O
different	O
number	O
of	O
spaces	O
,	O
absence	O
/	O
presence	O
of	O
diacritical	O
marks	O
,	O
I	O
would	O
like	O
to	O
be	O
able	O
to	O
merge	B-API
as	O
long	O
as	O
they	O
are	O
similar	O
to	O
one	O
another	O
.	O

I	O
want	O
to	O
merge	B-API
on	O
similar	O
values	O
between	O
two	O
DataFrames	O

Similar	O
to	O
@USER	O
suggestion	O
,	O
you	O
can	O
apply	B-API
`	O
difflib	O
`	O
'	O
s	O
`	O
get_closest_matches	O
`	O
to	O
`	O
df2	O
`'	O
s	O
index	O
and	O
then	O
apply	B-API
a	O
`	O
join	B-API
`	O
:	O
#CODE	O

If	O
these	O
were	O
columns	O
,	O
in	O
the	O
same	O
vein	O
you	O
could	O
apply	B-API
to	O
the	O
column	O
then	O
`	O
merge	B-API
`	O
:	O
#CODE	O

Instead	O
of	O
directly	O
applying	O
`	O
get_close_matches	O
`	O
,	O
I	O
found	O
it	O
easier	O
to	O
apply	B-API
the	O
following	O
function	O
.	O

Then	O
you	O
can	O
insert	B-API
it	O
again	O
into	O
your	O
DataFrame	B-API
.	O

map	B-API
(	O
lambda	O
x	O
:	O
(	O
x	O
[	O
3	O
]	O
,	O
[	O
int	O
(	O
x	O
[	O
1	O
])	O
,	O
int	O
(	O
x	O
[	O
2	O
])])	O
,	O
[	O
line.split()	O
])	O

or	O
just	O
concat	B-API
dataframes	O
#CODE	O

Which	O
I	O
want	O
to	O
resample	B-API
to	O
say	O
'	O
5s	O
'	O
.	O

Yes	O
,	O
`	O
ix	B-API
`	O
caches	O
results	O
.	O

Feels	O
to	O
me	O
like	O
the	O
trick	O
is	O
to	O
select	O
all	O
unique	O
dates	O
present	O
,	O
create	O
24	O
hour	O
time	O
samples	O
for	O
each	O
of	O
these	O
dates	O
and	O
merge	B-API
the	O
two	O
sets	O
.	O

This	O
gives	O
me	O
the	O
error	O
for	O
serie_5	O
(	O
the	O
second	O
concat	B-API
):	O
#CODE	O

Another	O
way	O
is	O
to	O
use	O
join	B-API
:	O
#CODE	O

I	O
wish	O
to	O
merge	B-API
the	O
values	O
from	O
b	O
into	O
a	O
.	O

Because	O
my	O
lists	O
are	O
large	O
,	O
is	O
there	O
any	O
way	O
not	O
to	O
load	O
the	O
full	O
list	O
into	O
memory	O
but	O
,	O
rather	O
,	O
efficiently	O
append	B-API
values	O
one	O
at	O
a	O
time	O
?	O

If	O
memory	O
is	O
no	O
constraint	O
just	O
preallocate	O
a	O
huge	O
zeros	O
array	O
and	O
append	B-API
at	O
the	O
end	O
of	O
the	O
program	O
removing	O
any	O
excess	O
zeros	O
.	O

Another	O
option	O
is	O
to	O
use	O
messaging	O
to	O
transmit	O
from	O
one	O
process	O
to	O
another	O
(	O
and	O
then	O
append	B-API
in	O
memory	O
)	O
,	O
this	O
avoids	O
the	O
serialization	O
issue	O
.	O

`	O
tz	B-API
`	O
means	O
time	O
zone	O
and	O
`	O
Not	O
Windows	O
`	O
and	O
`	O
Windows	O
`	O
are	O
categories	O
extracted	O
from	O
the	O
User	O
Agent	O
in	O
the	O
original	O
data	O
,	O
so	O
we	O
can	O
see	O
that	O
there	O
are	O
3	O
Windows	O
users	O
and	O
0	O
Non-windows	O
users	O
in	O
Africa	O
/	O
Cairo	O
from	O
the	O
data	O
collected	O
.	O

I	O
need	O
to	O
merge	B-API
these	O
three	O
columns	O
and	O
have	O
the	O
entire	O
date	O
in	O
one	O
column	O
for	O
all	O
the	O
rows	O
.	O

I	O
tried	O
to	O
reindex	B-API
like	O
this	O
but	O
it	O
doesn't	O
work	O
:	O
#CODE	O

I	O
am	O
trying	O
to	O
add	O
a	O
column	O
of	O
smaller	O
`	O
len	B-API
`	O
into	O
a	O
`	O
DataFrame	B-API
`	O
where	O
indexes	O
of	O
smaller	O
item	O
are	O
a	O
subset	O
of	O
a	O
larger	O
item	O
.	O

You	O
are	O
looking	O
for	O
an	O
outer	O
`	O
join	B-API
`	O
,	O
here	O
is	O
a	O
simple	O
example	O
:	O
#CODE	O

I	O
have	O
faced	O
this	O
with	O
rolling	B-API
statistics	O
in	O
pandas	O
,	O
too	O
.	O

I'd	O
say	O
for	O
non-time-related	O
measurements	O
,	O
such	O
as	O
an	O
altitude	O
vs	O
.	O
distance	O
profile	O
,	O
a	O
central-based	O
moving	O
window	O
makes	O
more	O
sense	O
,	O
since	O
it	O
does	O
not	O
introduce	O
lag	O
or	O
shift	B-API
.	O

One	O
"	O
built-in	O
"	O
way	O
to	O
accomplish	O
it	O
might	O
be	O
accomplished	O
using	O
`	O
shift	B-API
`	O
twice	O
,	O
but	O
I	O
think	O
this	O
is	O
going	O
to	O
be	O
somewhat	O
messier	O
...	O

I	O
assume	O
what	O
you	O
are	O
trying	O
to	O
do	O
is	O
change	O
the	O
frequency	O
of	O
a	O
Time	O
Series	O
that	O
contains	O
data	O
,	O
in	O
which	O
case	O
you	O
can	O
use	O
`	O
resample	B-API
`	O
(	O
documentation	O
)	O
.	O

Then	O
you	O
can	O
change	O
the	O
frequency	O
to	O
seconds	O
using	O
resample	B-API
,	O
specifying	O
how	O
you	O
want	O
to	O
aggregate	B-API
the	O
values	O
(	O
mean	O
,	O
sum	O
etc	O
.	O
):	O
#CODE	O

Hence	O
you	O
can	O
apply	B-API
this	O
to	O
the	O
entire	O
index	O
:	O
#CODE	O

I	O
have	O
corrected	O
this	O
and	O
added	O
how	O
to	O
apply	B-API
this	O
to	O
the	O
entire	O
dt_index	O
.	O

You	O
are	O
looking	O
for	O
a	O
`	O
merge	B-API
`	O
:	O
#CODE	O

@USER	O
I've	O
taken	O
the	O
liberty	O
of	O
replacing	O
the	O
second	O
line	O
with	O
the	O
'	O
replace	B-API
'	O
method	O
.	O

This	O
also	O
works	O
on	O
multiindex	B-API
DataFrames	O
and	O
Series	O
objects	O
:	O
#CODE	O

When	O
you	O
do	O
`	O
len	B-API
(	O
df	O
[	O
'	O
column	O
name	O
'])`	O
you	O
are	O
just	O
getting	O
one	O
number	O
,	O
namely	O
the	O
number	O
of	O
rows	O
in	O
the	O
DataFrame	B-API
(	O
i.e.	O
,	O
the	O
length	O
of	O
the	O
column	O
itself	O
)	O
.	O

I	O
came	O
up	O
with	O
a	O
way	O
using	O
a	O
list	O
comprehension	O
:	O
`	O
df	O
[[(	O
len	B-API
(	O
x	O
)	O
<	O
2	O
)	O
for	O
x	O
in	O
df	O
[	O
'	O
column	O
name	O
']]]`	O
but	O
yours	O
is	O
much	O
nicer	O
.	O

Finally	O
doing	O
pivot	B-API
table	O
and	O
putting	O
the	O
pivots	O
into	O
a	O
dataframe	B-API
and	O
plotting	O
the	O
dataframe	B-API
in	O
bar	O
mode	O
created	O
the	O
necessary	O
graphs	O
.	O

I	O
think	O
the	O
best	O
way	O
is	O
to	O
merge	B-API
all	O
dataframes	O
together	O
,	O
then	O
you	O
could	O
use	O
all	O
nice	O
Panda	O
functions	O
to	O
slice	O
and	O
mix-and-match	O
anyway	O
you	O
want	O
.	O

I	O
would	O
merge	B-API
them	O
like	O
this	O
:	O
#CODE	O

I	O
need	O
to	O
join	B-API
levels	O
with	O
lines	O
(	O
atom	O
,	O
ion	O
,	O
level	O
):	O
at	O
first	O
on	O
atom	O
,	O
ion	O
,	O
level_number_upper	O
and	O
then	O
atom	O
,	O
ion	O
,	O
level_number_lower	O
.	O

Is	O
there	O
a	O
way	O
to	O
precompute	O
the	O
join	B-API
-	O
memory	O
is	O
not	O
an	O
issue	O
,	O
but	O
speed	O
is	O
.	O

To	O
show	O
what	O
I	O
want	O
to	O
join	B-API
merge	B-API
here	O
a	O
code	O
snippet	O
#CODE	O

`	O
transform	B-API
`	O
is	O
not	O
that	O
well	O
documented	O
,	O
but	O
it	O
seems	O
that	O
the	O
way	O
it	O
works	O
is	O
that	O
what	O
the	O
transform	B-API
function	O
is	O
passed	O
is	O
not	O
the	O
entire	O
group	O
as	O
a	O
dataframe	B-API
,	O
but	O
a	O
single	O
column	O
of	O
a	O
single	O
group	O
.	O

I	O
don't	O
think	O
it's	O
really	O
meant	O
for	O
what	O
you're	O
trying	O
to	O
do	O
,	O
and	O
your	O
solution	O
with	O
`	O
apply	B-API
`	O
is	O
fine	O
.	O

This	O
makes	O
sense	O
if	O
you	O
think	O
about	O
what	O
transform	B-API
is	O
for	O
.	O

It's	O
meant	O
for	O
applying	O
transform	B-API
functions	O
on	O
the	O
groups	O
.	O

For	O
instance	O
,	O
the	O
example	O
in	O
the	O
pandas	O
docs	O
is	O
about	O
z-standardizing	O
using	O
`	O
transform	B-API
`	O
.	O

You	O
have	O
to	O
z-standardize	O
the	O
age	O
with	O
respect	O
to	O
the	O
mean	O
age	O
and	O
the	O
weight	O
with	O
respect	O
to	O
the	O
mean	O
weight	O
,	O
which	O
means	O
you	O
want	O
to	O
transform	B-API
separately	O
for	O
each	O
column	O
.	O

So	O
basically	O
,	O
you	O
don't	O
need	O
to	O
use	O
transform	B-API
here	O
.	O

Why	O
is	O
transform	B-API
so	O
poorly	O
documented	O
?	O

by	O
setting	O
`	O
index_col	O
=[	O
0	O
,	O
2	O
,	O
4	O
]`	O
you	O
are	O
creating	O
a	O
MultiIndex	B-API
that's	O
why	O
you	O
get	O
that	O
output	O
.	O

Just	O
read	O
single	O
and	O
merge	B-API
the	O
dataframes	O

Try	O
to	O
convert	O
the	O
'	O
sales	O
'	O
string	O
to	O
an	O
`	O
int	O
`	O
,	O
if	O
it	O
is	O
well	O
formed	O
then	O
it	O
goes	O
on	O
,	O
if	O
it	O
is	O
not	O
it	O
will	O
raise	O
a	O
`	O
ValueError	O
`	O
which	O
we	O
catch	O
and	O
replace	B-API
with	O
the	O
place	O
holder	O
.	O

Although	O
,	O
`	O
apply	B-API
`	O
is	O
the	O
important	O
bit	O
of	O
my	O
answer	O
(	O
weirdly	O
no	O
other	O
answers	O
seem	O
to	O
use	O
it	O
)	O
.	O

In	O
pandas	O
it	O
is	O
called	O
'	O
expanding	B-API
'	O
instead	O
of	O
cumulative	O
I	O
think	O
:	O

This	O
will	O
append	B-API
the	O
correct	O
values	O
but	O
does	O
not	O
update	O
the	O
index	O
properly	O
and	O
the	O
graph	O
is	O
messed	O
up	O
.	O

Have	O
you	O
seen	O
/	O
tried	O
the	O
built-in	O
rolling	B-API
mean	O
function	O
?	O

For	O
example	O
,	O
say	O
you	O
want	O
to	O
pivot	B-API
the	O
data	O
so	O
there	O
are	O
separate	O
columns	O
for	O

pd.rolling_mean()	B-API
,	O
like	O
all	O
rolling	B-API
/	O
moving	O
functions	O
in	O
pandas	O
,	O
even	O
accepts	O
a	O
`	O
center	B-API
`	O
parameter	O
for	O
centered	O
sliding	O
windows	O
.	O

Non	O
standard	O
interaction	O
among	O
two	O
tables	O
to	O
avoid	O
very	O
large	O
merge	B-API

The	O
last	O
major	O
improvement	O
I	O
can	O
think	O
of	O
would	O
be	O
to	O
replace	B-API
df.apply()	B-API
with	O
a	O
for	O
loop	O
to	O
avoid	O
calling	O
any	O
function	O
200M	O
times	O
(	O
or	O
however	O
large	O
A	O
is	O
)	O
.	O

If	O
you	O
replace	B-API
that	O
line	O
with	O
:	O

or	O
you	O
can	O
reindex	B-API
afterwards	O
#CODE	O

If	O
I	O
were	O
to	O
export	O
to	O
a	O
list	O
then	O
I	O
could	O
use	O
the	O
numpy's	O
`	O
interp1d	O
`	O
function	O
and	O
apply	B-API
this	O
to	O
the	O
missing	O
values	O
.	O

I'm	O
surprised	O
you	O
accepted	O
the	O
answer	O
so	O
fast	O
(	O
no	O
offense	O
,	O
hayden	O
;)	O
because	O
I	O
thought	O
you	O
especially	O
wanted	O
to	O
interpolate	B-API
time	O
series	O
,	O
but	O
I	O
guess	O
you	O
didn't	O
mean	O
exactly	O
pandas.TimeSeries	O
.	O

How	O
do	O
you	O
apply	B-API
that	O
to	O
one	O
column	O
only	O
(	O
i.e.	O
'	O
data1	O
')	O

I'm	O
a	O
newbie	O
to	O
pandas	O
dataframe	B-API
,	O
and	O
I	O
wanted	O
to	O
apply	B-API
a	O
function	O
to	O
each	O
column	O
so	O
that	O
it	O
computes	O
for	O
each	O
element	O
x	O
,	O
x	O
/	O
max	O
of	O
column	O
.	O

Pandas	O
DataFrame	B-API
:	O
apply	B-API
function	O
to	O
all	O
columns	O

Trying	O
to	O
use	O
the	O
awfully	O
useful	O
pandas	O
to	O
deal	O
with	O
data	O
as	O
time	O
series	O
,	O
I	O
am	O
now	O
stumbling	O
over	O
the	O
fact	O
that	O
there	O
do	O
not	O
seem	O
to	O
exist	O
libraries	O
that	O
can	O
directly	O
interpolate	B-API
(	O
with	O
a	O
spline	O
or	O
similar	O
)	O
over	O
data	O
that	O
has	O
DateTime	O
as	O
an	O
x-axis	O
?	O

)	O
as	O
x-argument	O
,	O
interestingly	O
,	O
the	O
Spline	O
class	O
does	O
create	O
an	O
interpolator	O
,	O
but	O
it	O
still	O
breaks	O
when	O
trying	O
to	O
interpolate	B-API
/	O
extrapolate	O
to	O
a	O
larger	O
DateTimeIndex	B-API
(	O
which	O
is	O
my	O
final	O
goal	O
here	O
)	O
.	O

To	O
simulate	O
different	O
consumption	O
rates	O
,	O
replace	B-API
all	O
real	O
outbound	O
timestamps	O

How	O
to	O
apply	B-API
function	O
to	O
date	O
indexed	O
DataFrame	B-API

Then	O
`	O
apply	B-API
`	O
this	O
to	O
each	O
state	O
in	O
the	O
DataFrame	B-API
:	O
#CODE	O

Using	O
`	O
join	B-API
`	O
or	O
`	O
merge	B-API
`	O
works	O
too	O
:	O
#CODE	O

Pandas	O
interpolate	B-API
changed	O
in	O
version	O
0.10	O
?	O

When	O
I	O
merge	B-API
two	O
CSV	O
files	O
,	O
of	O
the	O
format	O
(	O
date	O
,	O
someValue	O
)	O
,	O
I	O
see	O
some	O
duplicate	O
records	O
.	O

So	O
your	O
requirements	O
are	O
"	O
lots	O
of	O
colors	O
"	O
and	O
"	O
no	O
two	O
colors	O
should	O
map	B-API
to	O
the	O
same	O
grayscale	O
value	O
when	O
printed	O
"	O
,	O
right	O
?	O

The	O
white	O
line	O
is	O
the	O
luminance	O
of	O
each	O
color	O
,	O
so	O
you	O
can	O
see	O
that	O
each	O
color	O
will	O
map	B-API
to	O
a	O
different	O
grayscale	O
value	O
when	O
printed	O
.	O

In	O
[	O
6	O
]	O
,	O
it	O
should	O
be	O
range	O
(	O
len	B-API
(	O
fx.levels	O
))	O
.	O

You	O
can	O
`	O
unstack	B-API
`	O
the	O
groupby	B-API
:	O
#CODE	O

I	O
used	O
map	B-API
instead	O
.	O

The	O
problem	O
is	O
that	O
no	O
two	O
TimeSeries	O
have	O
the	O
exactly	O
the	O
same	O
index	O
,	O
i.e.	O
I	O
would	O
need	O
to	O
merge	B-API
all	O
the	O
TimeSeries	O
'	O
indexes	O
.	O

However	O
,	O
an	O
exception	O
is	O
thrown	O
when	O
attempting	O
to	O
aggregate	B-API
the	O
TimeSeries	O
into	O
a	O
DataFrame	B-API
and	O
I	O
believe	O
it	O
has	O
to	O
do	O
with	O
the	O
duplicate	O
index	O
elements	O
:	O
#CODE	O

For	O
some	O
reason	O
`	O
resample	B-API
`	O
added	O
rows	O
for	O
days	O
that	O
were	O
not	O
present	O
in	O
the	O
intraday	O
data	O
.	O

`	O
resample	B-API
`	O
converts	O
to	O
a	O
regular	O
time	O
interval	O
,	O
so	O
if	O
there	O
are	O
no	O
samples	O
that	O
day	O
you	O
get	O
NaN	O
.	O

Because	O
I	O
need	O
to	O
be	O
able	O
to	O
rely	O
on	O
it	O
that	O
importing	O
,	O
say	O
,	O
a	O
random	O
number	O
module	O
,	O
won't	O
silently	O
change	O
,	O
say	O
,	O
the	O
pickle	O
module	O
to	O
apply	B-API
a	O
random	O
salt	O
to	O
everything	O
it	O
writes	O
..	O

Pandas	O
slicing	O
along	O
multiindex	B-API
and	O
separate	O
indices	O

Python	O
-	O
rolling	B-API
functions	O
for	O
GroupBy	B-API
object	O

Is	O
there	O
any	O
way	O
to	O
apply	B-API
rolling	B-API
functions	O
to	O
`	O
groupby	B-API
`	O
objects	O
?	O

How	O
exactly	O
do	O
you	O
expect	O
rolling	B-API
function	O
to	O
work	O
on	O
grouped	O
objects	O
(	O
I	O
mean	O
write	O
out	O
the	O
math	O
you	O
want	O
to	O
do	O
in	O
symbols	O
)	O
?	O

I	O
think	O
you	O
could	O
apply	B-API
any	O
cumulative	O
or	O
"	O
rolling	B-API
"	O
function	O
in	O
this	O
manner	O
and	O
it	O
should	O
have	O
the	O
same	O
result	O
.	O

If	O
you	O
are	O
creating	O
a	O
timeseries	O
,	O
you	O
can	O
use	O
the	O
`	O
tz	B-API
`	O
argument	O
of	O
`	O
date_range	B-API
`	O
:	O
#CODE	O

Update	O
:	O
In	O
recent	O
pandas	O
,	O
you	O
can	O
use	O
the	O
dt	B-API
accessor	O
to	O
broadcast	O
this	O
:	O
#CODE	O

Here's	O
one	O
way	O
(	O
depending	O
if	O
tz	B-API
is	O
already	O
set	O
it	O
might	O
be	O
a	O
`	O
tz_convert	B-API
`	O
rather	O
than	O
`	O
tz_localize	B-API
`	O
):	O
#CODE	O

If	O
the	O
dicts	O
contain	O
both	O
numerical	O
and	O
string	O
values	O
,	O
then	O
you	O
could	O
combine	O
them	O
using	O
a	O
join	B-API
,	O
followed	O
by	O
a	O
groupy	O
and	O
aggregation	O
.	O

In	O
that	O
case	O
,	O
I	O
would	O
like	O
to	O
know	O
if	O
there	O
is	O
a	O
way	O
to	O
add	O
only	O
the	O
numbers	O
and	O
append	B-API
the	O
'	O
D	O
'	O
values	O
as	O
a	O
list	O

I	O
am	O
using	O
the	O
groupby	B-API
and	O
sum	O
to	O
quickly	O
aggregate	B-API
accros	O
two	O
data	O
sets	O

However	O
,	O
I	O
try	O
using	O
`	O
C	O
=	O
concat	B-API
([	O
A	O
,	O
B	O
])`	O
and	O
now	O
find	O
that	O
I	O
only	O
have	O
the	O
column	O
shares	O
as	O
an	O
index	O
and	O
cannot	O
group	O
by	O
sequence	O
.	O

Pass	O
the	O
`	O
axis	O
`	O
option	O
to	O
the	O
`	O
apply	B-API
`	O
function	O
:	O
#CODE	O

I	O
don't	O
think	O
`	O
ix	B-API
`	O
supports	O
negative	O
indexing	O
at	O
all	O
.	O

You	O
can	O
resample	B-API
the	O
data	O
to	O
business	O
month	O
.	O

@USER	O
Don't	O
know	O
which	O
method	O
is	O
preferred	O
:	O
normally	O
I	O
would	O
use	O
`	O
resample	B-API
`	O
.	O

`	O
resample	B-API
`	O
should	O
work	O
,	O
not	O
sure	O
about	O
advantages	O
of	O
`	O
asfreq	B-API
`	O
.	O

Now	O
we	O
have	O
renamed	O
the	O
columns	O
so	O
they	O
will	O
align	B-API
the	O
way	O
we	O
want	O
.	O

You	O
can	O
use	O
the	O
DataFrame	B-API
`	O
apply	B-API
`	O
method	O
:	O
#CODE	O

For	O
each	O
date	O
,	O
when	O
there	O
is	O
an	O
'	O
S	O
'	O
in	O
the	O
signal	O
column	O
append	B-API
the	O
corresponding	O
price	O
at	O
the	O
time	O
the	O
'	O
S	O
'	O
occurred	O
.	O

That	O
is	O
,	O
"	O
give	O
me	O
the	O
price	O
at	O
1620	O
;	O
(	O
even	O
when	O
it	O
doesn't	O
give	O
a	O
"	O
sell	O
signal	O
"	O
,	O
S	O
)	O
so	O
that	O
I	O
can	O
diff	B-API
.	O
with	O
the	O
"	O
extra	O
B's	O
"	O
--	O
for	O
the	O
special	O
case	O
where	O
B	O
>	O
S	O
.	O

Do	O
I	O
have	O
to	O
write	O
an	O
algorithm	O
which	O
is	O
then	O
going	O
to	O
go	O
back	O
and	O
say	O
on	O
User	O
2	O
,	O
insert	B-API
the	O
following	O
entry	O
(	O
6	O
,	O
35	O
)	O
.	O

You	O
may	O
find	O
it	O
faster	O
to	O
extract	O
the	O
index	O
as	O
a	O
column	O
and	O
use	O
`	O
apply	B-API
`	O
and	O
`	O
bfill	B-API
`	O
.	O

I'm	O
a	O
bit	O
confused	O
,	O
first	O
you	O
append	B-API
something	O
to	O
cash	O
then	O
you	O
reassign	O
it	O
to	O
an	O
empty	O
series	O
.	O

Update	O
:	O
in	O
0.15	O
you	O
will	O
have	O
access	O
to	O
a	O
dt	B-API
attribute	O
for	O
datetimelike	O
methods	O
:	O
#CODE	O

Here's	O
one	O
(	O
slow	O
!	O
)	O
workaround	O
to	O
do	O
it	O
using	O
`	O
apply	B-API
`	O
,	O
not	O
ideal	O
but	O
it	O
works	O
:	O
#CODE	O

How	O
to	O
apply	B-API
quantile	B-API
to	O
pandas	O
groupby	B-API
object	O
?	O

Then	O
we	O
make	O
a	O
copy	O
,	O
and	O
use	O
tril_indices_from	O
to	O
get	O
at	O
the	O
lower	O
indices	O
to	O
mask	B-API
them	O
:	O
#CODE	O

`	O
map	B-API
`	O
before	O
(	O
or	O
even	O
after	O
)	O
the	O
`	O
zip	O
`	O
?	O

Indeed	O
,	O
they	O
are	O
all	O
"	O
numbers	O
"	O
.	O
apply	B-API
(	O
float	O
)	O
for	O
some	O
reason	O
was	O
rejected	O
w	O
/	O
ValueError	O
:	O
could	O
not	O
convert	O
string	O
to	O
float	O
:	O
price	O
.	O

How	O
can	O
I	O
merge	B-API
the	O
two	O
data	O
frames	O
with	O
only	O
one	O
of	O
the	O
multi-indexes	O
,	O
in	O
this	O
case	O
the	O
'	O
first	O
'	O
index	O
?	O

The	O
mnemotechnic	O
for	O
what	O
level	O
you	O
have	O
to	O
use	O
in	O
the	O
reindex	B-API
method	O
:	O

According	O
to	O
the	O
documentation	O
,	O
as	O
of	O
pandas	O
0.14	O
,	O
you	O
can	O
simply	O
join	B-API
single-index	O
and	O
multiindex	B-API
dataframes	O
.	O

You	O
can	O
replace	B-API
`	O
nan	O
`	O
with	O
`	O
None	O
`	O
in	O
your	O
numpy	O
array	O
:	O
#CODE	O

Unfortunately	O
neither	O
this	O
,	O
nor	O
using	O
`	O
replace	B-API
`	O
,	O
works	O
with	O
`	O
None	O
`	O
see	O
this	O
(	O
closed	O
)	O
issue	O
.	O

The	O
way	O
I	O
currently	O
do	O
it	O
is	O
that	O
I	O
reindex	B-API
`	O
df	O
`	O
with	O
every	O
second	O
in	O
the	O
year	O
and	O
use	O
forward	O
filling	O
like	O
:	O
#CODE	O

`	O
applymap()	B-API
`	O
can	O
be	O
used	O
to	O
apply	B-API
a	O
function	O
to	O
every	O
element	O
of	O
a	O
`	O
dataframe	B-API
`	O
#CODE	O

I	O
am	O
having	O
a	O
real	O
strange	O
behaviour	O
when	O
trying	O
to	O
reindex	B-API
a	O
dataframe	B-API
in	O
pandas	O
.	O

and	O
then	O
I	O
try	O
to	O
reindex	B-API
inside	O
a	O
larger	O
date	O
range	O
:	O
#CODE	O

If	O
I	O
reindex	B-API
one	O
larger	O
part	O
of	O
the	O
dataset	O
I	O
get	O
this	O
error	O
:	O
#CODE	O

Is	O
there	O
a	O
way	O
to	O
replace	B-API
the	O
'	O
nan	O
'	O
label	O
with	O
""	O
in	O
the	O
x-axis	O
?	O

Is	O
there	O
a	O
shorter	O
way	O
of	O
dropping	O
a	O
column	O
MultiIndex	B-API
level	O
(	O
in	O
my	O
case	O
,	O
basic_amt	O
)	O
except	O
transposing	O
it	O
twice	O
?	O

For	O
the	O
rows	O
which	O
have	O
'	O
'	O
in	O
front	O
I	O
want	O
to	O
cut	B-API
that	O
and	O
move	O
into	O
column	O
C	O
before	O
the	O
'	O
=	O
'	O
sign	O
.	O

If	O
I	O
use	O
normal	O
slice	O
it	O
will	O
cut	B-API
values	O
where	O
there	O
is	O
no	O
'	O
'	O
sign	O
.	O

And	O
`	O
startswith	B-API
`	O
does	O
not	O
work	O
on	O
float	O
values	O
.	O

If	O
you	O
want	O
to	O
use	O
`	O
startswith	B-API
`	O
with	O
a	O
float	O
,	O
you	O
can	O
just	O
first	O
convert	O
it	O
to	O
a	O
str	O
with	O
str()	O
.	O

Then	O
you	O
can	O
use	O
Series	O
`	O
apply	B-API
`	O
with	O
this	O
function	O
:	O
#CODE	O

Check	O
`	O
asof	B-API
`	O
#CODE	O

I'm	O
trying	O
to	O
merge	B-API
a	O
series	O
of	O
dataframes	O
in	O
pandas	O
.	O

I	O
have	O
a	O
list	O
of	O
dfs	O
,	O
`	O
dfs	O
`	O
and	O
a	O
list	O
of	O
their	O
corresponding	O
labels	O
`	O
labels	O
`	O
and	O
I	O
want	O
to	O
merge	B-API
all	O
the	O
dfs	O
into	O
1	O
df	O
in	O
such	O
that	O
the	O
common	O
labels	O
from	O
a	O
df	O
get	O
the	O
suffix	O
from	O
its	O
label	O
in	O
the	O
`	O
labels	O
`	O
list	O
.	O

I'm	O
trying	O
to	O
make	O
a	O
series	O
of	O
merges	O
that	O
at	O
each	O
merge	B-API
grows	O
at	O
most	O
by	O
number	O
of	O
columns	O
N	O
,	O
where	O
N	O
is	O
the	O
number	O
of	O
columns	O
in	O
the	O
"	O
next	O
"	O
df	O
in	O
the	O
list	O
.	O

Unionize	O
the	O
non-common	O
column	O
names	O
(	O
as	O
in	O
outer	O
join	B-API
)	O
.	O

@USER	O
:	O
Yes	O
,	O
I	O
want	O
an	O
outer	O
join	B-API
but	O
I	O
want	O
it	O
to	O
use	O
the	O
indices	O
of	O
the	O
left	O
and	O
right	O
df	O
.	O

On	O
the	O
other	O
hand	O
,	O
you	O
may	O
want	O
to	O
look	O
into	O
an	O
operation	O
like	O
`	O
pd.concat	B-API
([	O
df1	O
,	O
df2	O
,	O
df3	O
]	O
,	O
keys	O
=[	O
'	O
d1	O
'	O
,	O
'	O
d2	O
'	O
,	O
'	O
d3	O
']	O
,	O
axis=1	O
)`	O
,	O
which	O
produces	O
a	O
dataframe	B-API
with	O
MultiIndex	B-API
columns	O
.	O

Can	O
you	O
explain	O
though	O
why	O
this	O
does	O
not	O
cause	O
combinatorial	O
issues	O
while	O
merge	B-API
does	O
?	O

i.e.	O
,	O
what	O
if	O
the	O
row	O
with	O
shift	B-API
==	O
-560	O
was	O
bad	O
?	O

Here's	O
a	O
solution	O
to	O
separately	O
aggregate	B-API
each	O
contiguous	O
block	O
of	O
bad	O
status	O
(	O
part	O
2	O
of	O
your	O
question	O
?	O
)	O
.	O

I	O
think	O
you	O
are	O
going	O
to	O
be	O
better	O
doing	O
a	O
`	O
concat	B-API
`	O
of	O
these	O
DataFrames	O
before	O
exporting	O
(	O
via	O
`	O
to_excel	B-API
`	O
)	O
.	O

python	O
pandas	O
custom	O
agg	B-API
function	O

My	O
agg	B-API
function	O
before	O
integrating	O
dataframes	O
was	O
u	O
"	O
|	O
"	O
.join	B-API
(	O
sorted	O
(	O
set	O
(	O
x	O
)))	O
.	O

I	O
can	O
create	O
a	O
mask	B-API
explicitly	O
:	O
#CODE	O

You	O
could	O
use	O
the	O
function	O
`	O
isnull	B-API
`	O
instead	O
of	O
the	O
method	O
:	O
#CODE	O

I've	O
also	O
tried	O
doing	O
this	O
with	O
concat	B-API
and	O
I	O
get	O
the	O
same	O
results	O
.	O

You	O
should	O
be	O
able	O
to	O
use	O
`	O
concat	B-API
`	O
and	O
`	O
unstack	B-API
`	O
.	O

If	O
so	O
,	O
could	O
you	O
possibly	O
append	B-API
the	O
output	O
of	O
`	O
s.head()	O
.to_dict()	B-API
`	O
for	O
both	O
Series	O
to	O
your	O
question	O
?	O

One	O
day	O
I	O
hope	O
to	O
replace	B-API
my	O
use	O
of	O
SAS	O
with	O
python	O
and	O
pandas	O
,	O
but	O
I	O
currently	O
lack	O
an	O
out-of-core	O
workflow	O
for	O
large	O
datasets	O
.	O

I	O
would	O
then	O
have	O
to	O
append	B-API
these	O
new	O
columns	O
into	O
the	O
database	O
structure	O
.	O

I	O
rarely	O
append	B-API
rows	O
,	O
but	O
I	O
do	O
perform	O
many	O
operations	O
that	O
create	O
new	O
columns	O
.	O

Finally	O
,	O
I	O
would	O
like	O
to	O
append	B-API
these	O
new	O
columns	O
into	O
the	O
on-disk	O
data	O
structure	O
.	O

At	O
the	O
very	O
end	O
of	O
this	O
process	O
,	O
I	O
apply	B-API
some	O
learning	O
techniques	O
that	O
create	O
an	O
equation	O
out	O
of	O
those	O
compound	O
columns	O
.	O

e.g.	O
I	O
have	O
tables	O
on	O
disk	O
that	O
I	O
read	O
via	O
queries	O
,	O
create	O
data	O
and	O
append	B-API
back	O
.	O

You	O
cannot	O
append	B-API
columns	O
once	O
a	O
table	O
is	O
created	O
.	O

This	O
would	O
allow	O
me	O
to	O
access	O
only	O
the	O
"	O
columns	O
"	O
(	O
in	O
the	O
form	O
of	O
rows	O
)	O
that	O
I	O
need	O
,	O
transpose	B-API
them	O
back	O
,	O
and	O
then	O
append	B-API
any	O
new	O
ones	O
I	O
create	O
.	O

querying	O
:	O
gt	B-API
=	O
greater	O
than	O
...	O

How	O
about	O
a	O
join	B-API
since	O
I	O
normally	O
get	O
10	O
data	O
sources	O
to	O
paste	O
together	O
:	O
#CODE	O

then	O
(	O
in	O
my	O
case	O
sometimes	O
I	O
have	O
to	O
agg	B-API
on	O
`	O
aJoinDF	O
`	O
first	O
before	O
its	O
"	O
mergeable	O
"	O
.	O
)	O
#CODE	O

Finally	O
you	O
can	O
read	O
into	O
pandas	O
your	O
3	O
to	O
memory	O
max	O
key	O
indicators	O
and	O
do	O
pivots	O
/	O
agg	B-API
/	O
data	O
exploration	O
.	O

You	O
can	O
also	O
use	O
the	O
two	O
methods	O
built	O
into	O
MongoDB	O
(	O
MapReduce	O
and	O
aggregate	B-API
framework	O
)	O
.	O

The	O
table	O
transpose	B-API
looks	O
like	O
:	O
#CODE	O

I	O
subsequently	O
process	O
each	O
file	O
separately	O
and	O
aggregate	B-API
results	O
at	O
the	O
end	O

And	O
although	O
the	O
query	O
language	O
and	O
pandas	O
are	O
different	O
,	O
it's	O
usually	O
not	O
complicated	O
to	O
translate	B-API
part	O
of	O
the	O
logic	O
from	O
one	O
to	O
another	O
.	O

How	O
do	O
I	O
turn	O
a	O
row	O
into	O
a	O
map	B-API
?	O

How	O
can	O
I	O
turn	O
a	O
row	O
into	O
a	O
map	B-API
,	O
or	O
otherwise	O
do	O
simple	O
concise	O
custom	O
printing	O
of	O
rows	O
?	O

This	O
will	O
convert	O
to	O
a	O
map	B-API
:	O
`	O
speeds.ix	O
[	O
3	O
]	O
.to_dict()	B-API
`	O

Trouble	O
with	O
pandas	O
cut	B-API

I	O
can	O
then	O
append	B-API
this	O
to	O
my	O
dataframe	B-API
to	O
have	O
a	O
new	O
column	O
.	O

Then	O
,	O
you	O
can	O
groupby	B-API
by	O
the	O
new	O
column	O
(	O
here	O
it's	O
called	O
index	O
)	O
,	O
and	O
use	O
`	O
transform	B-API
`	O
with	O
a	O
lambda	O
function	O
.	O

Can	O
you	O
paste	O
the	O
entire	O
stack	B-API
trace	O
?	O

File	O
"	O
/	O
misc	O
/	O
apps	O
/	O
linux	O
/	O
python-2.6.1	O
/	O
lib	O
/	O
python2.6	O
/	O
site-packages	O
/	O
pandas-0.10.0-py2.6-linux-x86_	O
#URL	O
line	O
1817	O
,	O
in	O
transform	B-API

I	O
pasted	O
your	O
stack	B-API
trace	O
into	O
your	O
original	O
question	O
.	O

I	O
am	O
getting	O
a	O
TypeError	O
:	O
Transform	B-API
function	O
invalid	O
for	O
data	O
types	O
.	O

Also	O
,	O
you	O
shouldn't	O
have	O
to	O
drop	B-API
the	O
NaNs	O
.	O

How	O
do	O
I	O
join	B-API
two	O
dataframes	O
(	O
pandas	O
)	O
with	O
different	O
indices	O
?	O

I'm	O
working	O
on	O
a	O
way	O
to	O
transform	B-API
sequence	O
/	O
genotype	O
data	O
from	O
a	O
csv	O
format	O
to	O
a	O
genepop	O
format	O
.	O

I	O
want	O
to	O
insert	B-API
the	O
values	O
from	O
`	O
df2	O
`	O
into	O
`	O
df1	O
`	O
,	O
keeping	O
empty	O
rows	O
where	O
`	O
df1.index	O
=	O
'	O
POP	O
'`	O
.	O

It	O
sounds	O
like	O
you	O
want	O
an	O
'	O
outer	O
'	O
`	O
join	B-API
`	O
:	O
#CODE	O

My	O
current	O
solution	O
is	O
to	O
define	O
a	O
temporary	O
dataframe	B-API
w	O
,	O
based	O
on	O
the	O
fancy	O
boolean	O
indexing	O
,	O
set	O
the	O
corresponding	O
values	O
in	O
'	O
y	O
'	O
to	O
0	O
in	O
w	O
,	O
and	O
then	O
merge	B-API
w	O
back	O
to	O
d	O
using	O
the	O
index	O
.	O

I	O
was	O
wondering	O
if	O
anybody	O
had	O
a	O
better	O
idea	O
for	O
a	O
join	B-API
such	O
as	O
this	O
.	O

2	O
,	O
Use	O
date	O
as	O
the	O
primary	O
index	O
and	O
time	O
as	O
the	O
secondary	O
index	O
in	O
a	O
multiindex	B-API
dataframe	B-API

My	O
naive	O
inclination	O
would	O
be	O
to	O
prefer	O
a	O
single	O
index	O
over	O
the	O
multiindex	B-API
.	O

However	O
,	O
I	O
am	O
not	O
very	O
experienced	O
with	O
Pandas	O
,	O
and	O
there	O
could	O
be	O
some	O
advantage	O
to	O
having	O
the	O
multiindex	B-API
when	O
doing	O
time-of-day	O
analysis	O
.	O

How	O
can	O
you	O
elegantly	O
apply	B-API
condition	O
a	O
,	O
b	O
,	O
c	O
,	O
etc	O
.	O
and	O
make	O
sure	O
you	O
then	O
plot	O
"	O
the	O
rest	O
"	O
(	O
things	O
not	O
in	O
any	O
of	O
these	O
conditions	O
)	O
as	O
the	O
last	O
step	O
?	O

pandas	O
rolling	B-API
computation	O
with	O
window	O
based	O
on	O
values	O
instead	O
of	O
counts	O

I'm	O
looking	O
for	O
a	O
way	O
to	O
do	O
something	O
like	O
the	O
various	O
`	O
rolling_*	O
`	O
functions	O
of	O
`	O
pandas	O
`	O
,	O
but	O
I	O
want	O
the	O
window	O
of	O
the	O
rolling	B-API
computation	O
to	O
be	O
defined	O
by	O
a	O
range	O
of	O
values	O
(	O
say	O
,	O
a	O
range	O
of	O
values	O
of	O
a	O
column	O
of	O
the	O
DataFrame	B-API
)	O
,	O
not	O
by	O
the	O
number	O
of	O
rows	O
in	O
the	O
window	O
.	O

If	O
I	O
do	O
something	O
like	O
`	O
rolling_sum	B-API
(	O
d	O
,	O
5	O
)`	O
,	O
I	O
get	O
a	O
rolling	B-API
sum	O
in	O
which	O
each	O
window	O
contains	O
5	O
rows	O
.	O

But	O
what	O
I	O
want	O
is	O
a	O
rolling	B-API
sum	O
in	O
which	O
each	O
window	O
contains	O
a	O
certain	O
range	O
of	O
values	O
of	O
`	O
RollBasis	O
`	O
.	O

I	O
can't	O
do	O
it	O
with	O
the	O
rolling	B-API
functions	O
,	O
because	O
their	O
windows	O
always	O
roll	O
by	O
number	O
of	O
rows	O
,	O
not	O
by	O
values	O
.	O

For	O
this	O
to	O
work	O
correctly	O
(	O
at	O
least	O
in	O
pandas	O
0.14	O
)	O
,	O
I	O
think	O
you	O
need	O
to	O
replace	B-API
chunk	O
=	O
indexed_what	O
[	O
indexer	O
]	O
by	O
chunk	O
=	O
indexed_what.iloc	O
[	O
indexer	O
]	O
.	O

In	O
some	O
cases	O
I	O
can	O
get	O
`	O
apply	B-API
`	O
working	O
after	O
`	O
groupby	B-API
`	O
and	O
in	O
other	O
cases	O
not	O
.	O

I	O
am	O
having	O
difficulties	O
understanding	O
how	O
to	O
work	O
with	O
DataFrame	B-API
with	O
MultiIndex	B-API
.	O

I	O
want	O
it	O
to	O
merge	B-API
based	O
on	O
both	O
date	O
and	O
cusip	O
/	O
idc_id	O
.	O

You	O
could	O
append	B-API
`'	O
cuspin	O
'`	O
and	O
`'	O
idc_id	O
'`	O
as	O
a	O
indices	O
to	O
your	O
DataFrames	O
before	O
you	O
`	O
join	B-API
`	O
(	O
here's	O
how	O
it	O
would	O
work	O
on	O
the	O
first	O
couple	O
of	O
rows	O
):	O
#CODE	O

`	O
strip	B-API
`	O
only	O
removes	O
the	O
specified	O
characters	O
at	O
the	O
beginning	O
and	O
end	O
of	O
the	O
string	O
.	O

Maybe	O
a	O
nice	O
trick	O
/	O
slightly	O
dirty	O
way	O
to	O
get	O
around	O
the	O
unicode	O
issues	O
is	O
to	O
convert	O
unicode	O
columns	O
into	O
string	O
columns	O
with	O
the	O
"	O
xmlcharrefreplace	O
"	O
option	O
;	O
later	O
on	O
you	O
can	O
translate	B-API
this	O
back	O
into	O
unicode	O
if	O
you	O
want	O
to	O
.	O

`	O
alternating	O
=	O
big	O
[(	O
big.index.to_pydatetime()	O
-	O
start	O
)	O
.total_seconds()	B-API
/	O
17	O
%	O
2	O
==	O
0	O
]`	O
,	O
but	O
I	O
can't	O
seem	O
to	O
find	O
a	O
way	O
to	O
map	B-API
the	O
total_seconds()	B-API
call	O
to	O
all	O
elements	O
.	O

Renaming	O
a	O
pandas	O
pivot	B-API
table	O
without	O
losing	O
axis	O
labels	O

When	O
you	O
pivot	B-API
,	O
the	O
values	O
of	O
x	O
and	O
y	O
are	O
the	O
labels	O
,	O
and	O
that	O
is	O
expected	O
behaviour	O
.	O

You	O
can	O
use	O
the	O
`	O
DataFrame	B-API
`	O
`	O
drop	B-API
`	O
function	O
to	O
remove	O
columns	O
.	O

This	O
does	O
indeed	O
work	O
well	O
,	O
but	O
in	O
this	O
instance	O
I	O
only	O
need	O
to	O
keep	O
about	O
5-6	O
out	O
of	O
40-50	O
series	O
of	O
data	O
,	O
and	O
the	O
series	O
I	O
want	O
to	O
drop	B-API
may	O
fluctuate	O
based	O
on	O
changes	O
in	O
the	O
input	O
data	O
file	O
.	O

I	O
just	O
had	O
to	O
do	O
something	O
similar	O
to	O
what	O
you've	O
done	O
,	O
and	O
in	O
my	O
case	O
,	O
I've	O
pre-computed	O
the	O
list	O
of	O
things	O
I	O
need	O
to	O
drop	B-API
,	O
and	O
then	O
passed	O
in	O
the	O
list	O
to	O
the	O
drop()	B-API
function	O
.	O

@USER	O
Zelleke	O
,	O
what	O
if	O
i	O
had	O
about	O
50	O
columns	O
i	O
want	O
to	O
drop	B-API
and	O
50	O
columns	O
i	O
want	O
to	O
keep	O
.	O
and	O
the	O
number	O
of	O
columns	O
can	O
change	O
each	O
instance	O
i	O
run	O
it	O
.	O

maybe	O
replace	B-API
the	O
num	O
with	O
enumerate	O
in	O
the	O
for	O
loop	O
?	O

If	O
this	O
is	O
not	O
possible	O
,	O
is	O
there	O
way	O
to	O
resample	B-API
to	O
to	O
one	O
minute	O
,	O
but	O
in	O
the	O
gaps	O
,	O
put	O
in	O
an	O
arbitrary	O
value	O
like	O
0.0	O
?	O

@USER	O
the	O
fact	O
that	O
it	O
causes	O
an	O
exception	O
when	O
you	O
try	O
to	O
do	O
it	O
is	O
surely	O
a	O
bug	O
,	O
either	O
it	O
should	O
let	O
you	O
do	O
it	O
to	O
a	O
DataFrame	B-API
(	O
and	O
reindex	B-API
)	O
or	O
the	O
method	O
shouldn't	O
be	O
available	O
?	O

How	O
to	O
drop	B-API
extra	O
copy	O
of	O
duplicate	O
index	O
of	O
Pandas	O
Series	O
?	O

So	O
how	O
to	O
drop	B-API
extra	O
duplicate	O
rows	O
of	O
series	O
,	O
keep	O
the	O
unique	O
rows	O
and	O
only	O
one	O
copy	O
of	O
the	O
duplicate	O
rows	O
in	O
an	O
efficient	O
way	O
?	O

Not	O
totally	O
drop	B-API
the	O
duplicated	O
ones	O
.	O

You	O
can	O
groupby	B-API
the	O
index	O
and	O
apply	B-API
a	O
function	O
that	O
returns	O
one	O
value	O
per	O
index	O
group	O
.	O

@USER	O
sorry	O
,	O
"	O
arbitrary	O
"	O
of	O
length	O
len	B-API
(	O
s	O
)	O
:)	O
.	O

@USER	O
passing	O
a	O
MultiIndex	B-API
to	O
series.groupby	B-API
and	O
then	O
applying	O
a	O
function	O
also	O
crashed	O
for	O
me	O
.	O

How	O
do	O
I	O
elegantly	O
apply	B-API
this	O
in	O
Pandas	O
?	O

Pandas	O
has	O
set	O
logic	O
for	O
intersection	B-API
and	O
union	O
,	O
but	O
nothing	O
for	O
disjoint	O
.	O

I'm	O
trying	O
to	O
identify	O
the	O
rows	O
with	O
unicode	O
and	O
strip	B-API
the	O
$	O
sign	O
and	O
comma	O
,	O
converting	O
to	O
float	O
.	O

However	O
when	O
I	O
use	O
the	O
apply	B-API
function	O
to	O
my	O
case	O
I	O
get	O
an	O
'	O
unhashable	O
type	O
'	O
error	O
.	O

You	O
are	O
just	O
printing	O
these	O
and	O
not	O
`	O
apply	B-API
`	O
-ing	O
them	O
to	O
the	O
DataFrame	B-API
,	O
here's	O
one	O
way	O
to	O
do	O
it	O
:	O

If	O
I	O
understand	O
you	O
right	O
,	O
you're	O
looking	O
for	O
the	O
`	O
apply	B-API
`	O
method	O
:	O
#CODE	O

Update	O
:	O
I	O
now	O
recommend	O
installing	O
the	O
scientific	O
python	O
stack	B-API
using	O
Anaconda	O
.	O

I	O
want	O
to	O
apply	B-API
the	O
same	O
process	O
to	O
the	O
whole	O
quantity	O
column	O
.	O

After	O
building	O
basic	O
class	O
with	O
`	O
__str__	O
`	O
and	O
plotData()	O
methods	O
I	O
would	O
like	O
to	O
apply	B-API
some	O
filters	O
and	O
build	O
a	O
new	O
class	O
where	O
additional	O
column	O
is	O
the	O
filter	O
.	O

To	O
convert	O
back	O
to	O
what	O
we	O
started	O
with	O
we	O
could	O
`	O
apply	B-API
`	O
`	O
Timestamp	O
`	O
to	O
the	O
column	O
and	O
`	O
set_index	B-API
`	O
:	O
#CODE	O

I	O
don't	O
seem	O
to	O
be	O
able	O
to	O
find	O
a	O
rolling	B-API
rank	O
function	O
.	O

To	O
limit	O
memory	O
usage	O
,	O
simply	O
replace	B-API
the	O
dict	O
cache	O
with	O
something	O
like	O
a	O
LRU	O
.	O

I	O
try	O
to	O
apply	B-API
exactly	O
the	O
same	O
logic	O
to	O
my	O
original	O
problem	O
with	O
large	O
dataframe	B-API
inside	O
a	O
class	O
.	O

No	O
,	O
`	O
reindex	B-API
`	O
doesn't	O
do	O
any	O
sorting	O
.	O

I	O
have	O
a	O
Panda	O
Series	O
and	O
based	O
on	O
a	O
random	O
number	O
I	O
want	O
to	O
pick	O
a	O
row	O
(	O
5	O
in	O
the	O
code	O
example	O
below	O
)	O
and	O
drop	B-API
that	O
row	O
.	O

I	O
want	O
to	O
drop	B-API
row	O
"	O
5	O
NaN	O
"	O
and	O
keep	O
-	O
0.000052	O
with	O
an	O
index	O
0	O
to	O
8	O
.	O

Somewhat	O
confusingly	O
,	O
`	O
reindex	B-API
`	O
does	O
not	O
mean	O
"	O
create	O
a	O
new	O
index	O
"	O
.	O

So	O
at	O
your	O
last	O
step	O
just	O
do	O
`	O
sample_mean_series.index	O
=	O
range	O
(	O
len	B-API
(	O
sample_mean_series	O
))`	O
.	O

Using	O
`	O
reindex	B-API
[	O
blah	O
]`	O
just	O
selects	O
rows	O
,	O
basically	O
like	O
doing	O
`	O
df.ix	B-API
[	O
blah	O
]`	O
,	O
and	O
like	O
that	O
it	O
gives	O
you	O
NaN	O
if	O
the	O
ones	O
you	O
ask	O
for	O
don't	O
exist	O
.	O

Not	O
sure	O
where	O
to	O
drop	B-API
sample	O
data	O
.	O

In	O
some	O
circles	O
this	O
operation	O
is	O
known	O
as	O
the	O
"	O
asof	B-API
"	O
join	B-API
.	O

If	O
you	O
want	O
to	O
combine	O
`	O
join	B-API
`	O
your	O
MultiIndex	B-API
into	O
one	O
Index	O
(	O
assuming	O
you	O
have	O
just	O
string	O
entries	O
in	O
your	O
columns	O
)	O
you	O
could	O
:	O
#CODE	O

Note	O
:	O
we	O
must	O
`	O
strip	B-API
`	O
the	O
whitespace	O
for	O
when	O
there	O
is	O
no	O
second	O
index	O
.	O

And	O
if	O
you	O
want	O
to	O
retain	O
any	O
of	O
the	O
aggregation	O
info	O
from	O
the	O
second	O
level	O
of	O
the	O
multiindex	B-API
you	O
can	O
try	O
this	O
:	O
#CODE	O

pandas	O
:	O
merge	B-API
rows	O
on	O
timestamp	O

I'd	O
like	O
to	O
merge	B-API
the	O
rows	O
based	O
on	O
the	O
first	O
column	O
and	O
have	O
the	O
output	O
look	O
like	O
this	O
:	O
#CODE	O

I	O
am	O
still	O
struggling	O
to	O
get	O
a	O
combination	O
of	O
groupby	B-API
and	O
stack	B-API
to	O
recast	O
the	O
dataframe	B-API
.	O

Now	O
create	O
the	O
desired	O
index	O
and	O
apply	B-API
it	O
.	O

I'm	O
trying	O
to	O
transform	B-API
monthly	O
returns	O
data	O
I	O
have	O
for	O
thousands	O
of	O
stocks	O
in	O
postgres	O
from	O
the	O
form	O
:	O
#CODE	O

My	O
suggestion	O
would	O
be	O
to	O
first	O
`	O
set_index	B-API
`	O
as	O
date	O
and	O
company	O
name	O
,	O
then	O
you	O
can	O
`	O
unstack	B-API
`	O
the	O
company	O
name	O
and	O
`	O
resample	B-API
`	O
.	O

The	O
docs	O
show	O
how	O
to	O
apply	B-API
multiple	O
functions	O
on	O
a	O
groupby	B-API
object	O
at	O
a	O
time	O
using	O
a	O
dict	O
with	O
the	O
output	O
column	O
names	O
as	O
the	O
keys	O
:	O
#CODE	O

What	O
I	O
want	O
to	O
do	O
is	O
apply	B-API
multiple	O
functions	O
to	O
several	O
columns	O
(	O
but	O
certain	O
columns	O
will	O
be	O
operated	O
on	O
multiple	O
times	O
)	O
.	O

but	O
as	O
expected	O
I	O
get	O
a	O
KeyError	O
(	O
since	O
the	O
keys	O
have	O
to	O
be	O
a	O
column	O
if	O
`	O
agg	B-API
`	O
is	O
called	O
from	O
a	O
DataFrame	B-API
)	O
.	O

How	O
do	O
I	O
resample	B-API
a	O
time	O
series	O
in	O
pandas	O
to	O
a	O
weekly	O
frequency	O
where	O
the	O
weeks	O
start	O
on	O
an	O
arbitrary	O
day	O
?	O

You	O
can	O
pass	O
anchored	O
offsets	O
to	O
`	O
resample	B-API
`	O
,	O
among	O
other	O
options	O
they	O
cover	O
this	O
case	O
.	O

Pandas	O
Drop	B-API
Rows	O
Outside	O
of	O
Time	O
Range	O

I	O
have	O
been	O
looking	O
for	O
solutions	O
but	O
none	O
of	O
them	O
separate	O
the	O
Date	O
from	O
the	O
Time	O
,	O
and	O
all	O
I	O
want	O
to	O
do	O
is	O
drop	B-API
the	O
rows	O
that	O
are	O
outside	O
of	O
a	O
Time	O
range	O
.	O

Note	O
:	O
the	O
same	O
syntax	O
(	O
using	O
`	O
ix	B-API
`	O
)	O
works	O
for	O
a	O
DataFrame	B-API
:	O
#CODE	O

@USER	O
I	O
think	O
it's	O
good	O
practice	O
to	O
use	O
ix	B-API
with	O
Series	O
as	O
well	O
,	O
and	O
that	O
way	O
the	O
syntax	O
is	O
identical	O
,	O
so	O
I	O
updated	O
the	O
first	O
part	O
.	O

I'm	O
trying	O
to	O
transform	B-API
a	O
(	O
well	O
,	O
many	O
)	O
column	O
of	O
return	O
data	O
to	O
a	O
column	O
of	O
closing	O
prices	O
.	O

If	O
abs	B-API
(	O
stuff	O
)	O
>	O
1	O
,	O
the	O
result	O
will	O
be	O
negative	O
.	O

If	O
you	O
can't	O
/	O
don't	O
want	O
to	O
replace	B-API
your	O
reading	O
with	O
`	O
pandas.read_csv	B-API
`	O
,	O
then	O
probably	O
my	O
`	O
numpy.delete	O
`	O
is	O
easiest	O
,	O
but	O
I	O
think	O
you're	O
better	O
off	O
with	O
his	O
answer	O
.	O

`	O
read_csv	B-API
`	O
is	O
much	O
simpler	O
,	O
harder	O
to	O
get	O
wrong	O
,	O
and	O
probably	O
faster	O
than	O
what	O
he	O
has	O
,	O
and	O
there's	O
no	O
good	O
reason	O
not	O
to	O
drop	B-API
the	O
column	O
in	O
`	O
pandas	O
`	O
instead	O
of	O
post-deleting	O
after	O
`	O
to_records	B-API
`	O
.	O

You	O
may	O
be	O
trying	O
to	O
force	O
the	O
use	O
of	O
`	O
hist	B-API
`	O
...	O
consider	O
taking	O
a	O
step	O
back	O
to	O
construct	O
a	O
bar	O
plot	O
.	O

I	O
need	O
to	O
apply	B-API
some	O
function	O
for	O
every	O
columns	O
and	O
create	O
new	O
columns	O
in	O
this	O
DataFrame	B-API
with	O
special	O
name	O
.	O

You	O
can	O
use	O
`	O
join	B-API
`	O
to	O
do	O
the	O
combining	O
:	O
#CODE	O

where	O
you	O
could	O
replace	B-API
`	O
df*2	O
`	O
with	O
`	O
df.apply	B-API
(	O
your_function	O
)`	O
if	O
you	O
liked	O
.	O

I	O
would	O
skip	O
the	O
`	O
apply	B-API
`	O
method	O
and	O
just	O
define	O
the	O
columns	O
directly	O
.	O

But	O
for	O
whatever	O
reason	O
I	O
avoid	O
`	O
apply	B-API
`	O
unless	O
I	O
really	O
need	O
it	O
.	O

BY	O
avoiding	O
the	O
`	O
join	B-API
`	O
this	O
also	O
has	O
the	O
nice	O
benefit	O
of	O
not	O
having	O
to	O
reassign	O
the	O
dataframe	B-API
.	O

straightfoward	O
disk	O
based	O
merge	B-API
,	O
with	O
all	O
tables	O
on	O
disk	O
.	O

For	O
your	O
merge_a_b	O
operation	O
I	O
think	O
you	O
can	O
use	O
a	O
standard	O
pandas	O
join	B-API

table	O
;	O
instead	O
of	O
storing	O
the	O
merge	B-API
results	O
per	O
se	O
,	O
store	O
the	O
row	O
index	O
;	O
later	O

Which	O
is	O
probably	O
like	O
a	O
inefficient	O
"	O
join	B-API
"	O
.	O

To	O
avoid	O
it	O
replace	B-API
last	O
line	O
with	O
:	O
#CODE	O

I	O
basically	O
replace	B-API
the	O
stars	O
in	O
my	O
example	O
code	O
above	O
with	O
`	O
`	O
.	O

`	O
df	O
`	O
was	O
created	O
by	O
concatenating	O
multiple	O
dataframes	O
together	O
using	O
the	O
`	O
concat	B-API
`	O
function	O
.	O

Let's	O
say	O
I	O
wanted	O
to	O
do	O
the	O
rolling	B-API
sum	O
over	O
a	O
1ms	O
window	O
to	O
get	O
this	O
:	O
#CODE	O

ugh	O
,	O
the	O
second	O
asof	B-API
(	O
s.asof	O
(	O
lag	O
))	O
is	O
wrong	O
.	O

What	O
you	O
really	O
need	O
are	O
the	O
indices	O
from	O
the	O
first	O
asof	B-API
.	O

I	O
have	O
tried	O
concat	B-API
:	O
#CODE	O

but	O
I	O
need	O
the	O
output	O
that	O
adds	O
values	O
of	O
existing	O
indices	O
and	O
keeps	O
new	O
indices	O
if	O
they	O
appear	O
,	O
so	O
a	O
mix	O
of	O
concat	B-API
and	O
'	O
+	O
'	O
.	O

Or	O
you	O
could	O
align	B-API
the	O
two	O
first	O
,	O
and	O
then	O
simply	O
add	O
them	O
with	O
`	O
+	O
`	O
:	O
#CODE	O

Why	O
not	O
just	O
take	O
the	O
[	O
transpose	B-API
]	O
(	O
#URL	O
)	O
??	O

You	O
could	O
replace	B-API
:	O
#CODE	O

I	O
wasn't	O
able	O
to	O
get	O
your	O
resample	B-API
suggestion	O
to	O
work	O
.	O

Here's	O
a	O
way	O
to	O
aggregate	B-API
the	O
data	O
at	O
the	O
business	O
day	O
level	O
and	O
compute	O
the	O
OHLC	O
stats	O
in	O
one	O
pass	O
:	O
#CODE	O

The	O
outer	O
key	O
references	O
the	O
columns	O
you	O
want	O
to	O
apply	B-API
the	O
functions	O
to	O
.	O

The	O
inner	O
key	O
contains	O
the	O
names	O
of	O
your	O
aggregation	O
functions	O
and	O
the	O
inner	O
values	O
are	O
the	O
functions	O
you	O
want	O
to	O
apply	B-API
:	O
#CODE	O

1	O
)	O
I	O
create	O
a	O
mask	B-API
and	O
mask	B-API
the	O
data	O
as	O
follows	O
:	O
#CODE	O

What	O
I	O
cannot	O
figure	O
out	O
how	O
to	O
do	O
is	O
filter	O
all	O
of	O
my	O
data	O
based	O
on	O
a	O
mask	B-API
without	O
a	O
for	O
loop	O
.	O

Assuming	O
that	O
Date	O
is	O
the	O
index	O
rather	O
than	O
a	O
column	O
then	O
you	O
can	O
do	O
an	O
"	O
outer	O
"	O
`	O
join	B-API
`	O
:	O
#CODE	O

How	O
to	O
drop	B-API
a	O
list	O
of	O
rows	O
from	O
Pandas	O
dataframe	B-API
?	O

Then	O
I	O
want	O
to	O
drop	B-API
rows	O
with	O
certain	O
sequence	O
numbers	O
which	O
indicated	O
in	O
a	O
list	O
,	O
suppose	O
here	O
is	O
`	O
[	O
1	O
,	O
2	O
,	O
4	O
]	O
,	O
`	O
then	O
left	O
:	O
#CODE	O

Using	O
the	O
`	O
map	B-API
`	O
lets	O
you	O
put	O
in	O
any	O
condition	O
you	O
want	O
,	O
in	O
this	O
case	O
you	O
can	O
do	O
this	O
more	O
simply	O
(	O
as	O
pointed	O
out	O
in	O
the	O
comments	O
by	O
DSM	O
)	O
#CODE	O

for	O
each	O
date	O
in	O
the	O
DataFrame	B-API
truncate	B-API
to	O
only	O
have	O
data	O
in	O
the	O

the	O
pandas	O
truncate	B-API
functions	O
only	O
allows	O
me	O
to	O
truncate	B-API
according	O
to	O
date	O
,	O
but	O
I	O
would	O
like	O
to	O
truncate	B-API
according	O
to	O
datetime.time	O
here	O
.	O

@USER	O
You	O
can	O
probably	O
create	O
a	O
two-level	O
index	O
`	O
[	O
'	O
date	O
'	O
,	O
'	O
time	O
']`	O
and	O
then	O
apply	B-API
time	O
filtering	O
for	O
the	O
second	O
level	O
,	O
but	O
that	O
is	O
beyond	O
my	O
current	O
level	O
of	O
pandas-fu	O
now	O
.	O

So	O
you	O
can	O
use	O
`	O
map	B-API
`	O
and	O
a	O
`	O
lambda	O
`	O
:	O
#CODE	O

When	O
I	O
do	O
df	O
[	O
'	O
tracking	O
']	O
=	O
pd.np.arange	O
(	O
len	B-API
(	O
df	O
))	O
I	O
get	O
'	O
tracking	O
not	O
in	O
this	O
series	O
!	O

To	O
pick	O
the	O
last	O
row	O
using	O
`	O
irow	B-API
`	O
:	O
#CODE	O

I	O
suppose	O
there	O
may	O
be	O
other	O
pandas	O
functions	O
that	O
call	O
'	O
isnull	B-API
'	O
and	O
act	O
based	O
on	O
the	O
answer	O
,	O
which	O
might	O
seem	O
to	O
partially	O
work	O
for	O
NA	O
timestamps	O
in	O
this	O
case	O
.	O

Pandas	O
append	B-API
data	O
frames	O
,	O
add	O
a	O
field	O
,	O
and	O
then	O
flood	O
the	O
field	O
with	O
a	O
default	O
value	O
?	O

I	O
want	O
to	O
append	B-API
them	O
into	O
a	O
master	O
data	O
frame	O
.	O

