Rolling	B-API
median	B-API
in	O
python	O

I	O
need	O
to	O
be	O
able	O
to	O
insert	B-API
these	O
values	O
into	O
a	O
python	O
list	O
and	O
get	O
a	O
median	B-API
for	O
the	O
last	O
30	O
closes	O
.	O

It	O
would	O
be	O
more	O
efficient	O
to	O
do	O
the	O
median	B-API
of	O
the	O
last	O
29	O
values	O
.	O

isn't	O
the	O
median	B-API
just	O
the	O
middle	O
value	O
in	O
a	O
sorted	O
range	O
?	O

For	O
an	O
list	O
with	O
an	O
even	O
number	O
of	O
values	O
the	O
median	B-API
is	O
the	O
mean	O
of	O
the	O
two	O
middle	O
values	O
.	O

so	O
you	O
could	O
grab	O
daily	O
close	O
prices	O
,	O
their	O
rolling	B-API
means	O
,	O
etc	O
...	O
then	O
timestamp	O
every	O
calculation	O
,	O
and	O
get	O
all	O
this	O
stored	O
in	O
something	O
similar	O
to	O
a	O
python	O
dictionary	O
(	O
see	O
the	O
`	O
pandas.DataFrame	B-API
`	O
class	O
)	O
...	O
then	O
you	O
access	O
slices	O
of	O
the	O
data	O
as	O
simply	O
as	O
:	O
#CODE	O

See	O
the	O
pandas	O
rolling	B-API
moments	O
doc	O
for	O
more	O
information	O
on	O
to	O
calculate	O
the	O
rolling	B-API
stdev	O
(	O
it's	O
a	O
one-liner	O
)	O
.	O

I	O
was	O
was	O
thinking	O
of	O
using	O
a	O
lambda	O
function	O
in	O
the	O
apply	B-API
method	O
of	O
DataMatrix	O
but	O
I'm	O
having	O
some	O
challenges	O
...	O

@USER	O
Pennington	O
:	O
couponded	O
is	O
an	O
array	O
in	O
this	O
case	O
and	O
has	O
no	O
shift	B-API
method	O
...	O

@USER	O
Pennington	O
:	O
Done	O
,	O
sorry	O
,	O
new	O
to	O
Stack	B-API
:)	O

b	O
)	O
strip	B-API
the	O
seconds	O
out	O
of	O
python	O
datetime	O
objects	O
(	O
Set	O
seconds	O
to	O
00	O
,	O
without	O
changing	O
minutes	O
)	O
.	O

You	O
have	O
a	O
number	O
of	O
options	O
using	O
pandas	O
,	O
but	O
you	O
have	O
to	O
make	O
a	O
decision	O
about	O
how	O
it	O
makes	O
sense	O
to	O
align	B-API
the	O
data	O
given	O
that	O
they	O
don't	O
occur	O
at	O
the	O
same	O
instants	O
.	O

The	O
`	O
reindex	B-API
`	O
function	O
enables	O
you	O
to	O
align	B-API
data	O
while	O
filling	O
forward	O
values	O
(	O
getting	O
the	O
"	O
as	O
of	O
"	O
value	O
):	O
#CODE	O

I	O
tested	O
with	O
apply	B-API
,	O
it	O
seems	O
that	O
when	O
there	O
are	O
many	O
sub	O
groups	O
,	O
it's	O
very	O
slow	O
.	O
the	O
groups	O
attribute	O
of	O
grouped	O
is	O
a	O
dict	O
,	O
you	O
can	O
choice	O
index	O
directly	O
from	O
it	O
:	O
#CODE	O

append	B-API
two	O
data	O
frame	O
with	O
pandas	O

I	O
try	O
to	O
merge	B-API
dataframes	O
by	O
rows	O
doing	O
:	O
#CODE	O

Also	O
post	O
what	O
keywords	O
you	O
used	O
when	O
you	O
performed	O
the	O
merge	B-API
.	O

The	O
`	O
append	B-API
`	O
function	O
has	O
an	O
optional	O
argument	O
`	O
ignore_index	O
`	O
which	O
you	O
should	O
use	O
here	O
to	O
join	B-API
the	O
records	O
together	O
,	O
since	O
the	O
index	O
isn't	O
meaningful	O
for	O
your	O
application	O
.	O

Just	O
as	O
a	O
small	O
addition	O
,	O
you	O
can	O
also	O
do	O
an	O
apply	B-API
if	O
you	O
have	O
a	O
complex	O
function	O
that	O
you	O
apply	B-API
to	O
a	O
single	O
column	O
:	O

probably	O
x	O
is	O
a	O
confusing	O
name	O
for	O
the	O
column	O
name	O
and	O
the	O
row	O
variable	O
,	O
though	O
I	O
agree	O
apply	B-API
is	O
easiest	O
way	O
to	O
do	O
it	O
:)	O

just	O
to	O
add	O
,	O
`	O
apply	B-API
`	O
can	O
also	O
be	O
applied	O
to	O
multiple	O
columns	O
:	O

Can	O
apply	B-API
take	O
in	O
a	O
function	O
defined	O
elsewhere	O
in	O
code	O
?	O

Is	O
it	O
possible	O
create	O
a	O
matching	O
panel	O
that	O
only	O
has	O
these	O
columns	O
and	O
then	O
somehow	O
merge	B-API
the	O
two	O
?	O

Here's	O
the	O
2nd	O
panel	O
I	O
would	O
like	O
to	O
append	B-API
:	O
#CODE	O

Could	O
you	O
have	O
a	O
look	O
at	O
the	O
new	O
concat	B-API
function	O
in	O
pandas	O
0.7.0	O
and	O
see	O
if	O
it	O
meets	O
your	O
needs	O
:	O

I	O
recently	O
spent	O
a	O
great	O
deal	O
of	O
time	O
on	O
the	O
join	B-API
and	O
concatenation	O
methods	O
.	O

I've	O
moved	O
on	O
from	O
this	O
problem	O
(	O
I	O
hacked	O
together	O
a	O
loop	O
)	O
but	O
looking	O
at	O
your	O
concat	B-API
documentation	O
this	O
does	O
appear	O
to	O
solve	O
the	O
issue	O
.	O

I	O
realize	O
the	O
map	B-API
function	O
can	O
only	O
output	O
lists	O
.	O

How	O
to	O
apply	B-API
slicing	O
on	O
pandas	O
Series	O
of	O
strings	O

I'm	O
playing	O
with	O
pandas	O
and	O
trying	O
to	O
apply	B-API
string	O
slicing	O
on	O
a	O
Series	O
of	O
strings	O
object	O
.	O

I	O
got	O
it	O
to	O
work	O
by	O
using	O
the	O
map	B-API
function	O
instead	O
,	O
but	O
I	O
think	O
I'm	O
missing	O
something	O
about	O
how	O
it's	O
supposed	O
to	O
work	O
.	O

`	O
apply	B-API
`	O
first	O
tries	O
to	O
apply	B-API
the	O
function	O
to	O
the	O
whole	O
series	O
.	O

`	O
apply	B-API
`'	O
s	O
source	O
code	O
for	O
reference	O
:	O
#CODE	O

also	O
,	O
how	O
can	O
I	O
then	O
reindex	B-API
things	O
so	O
that	O
the	O
first	O
indices	O
are	O
the	O
column	O
labels	O
of	O
each	O
file	O
and	O
the	O
second	O
is	O
the	O
filename	O
?	O

Suppose	O
there	O
are	O
many	O
columns	O
and	O
you	O
only	O
want	O
the	O
`	O
any	B-API
`	O
to	O
apply	B-API
to	O
a	O
subset	O
of	O
them	O
(	O
you	O
know	O
the	O
subset's	O
labels	O
)	O
.	O

There	O
are	O
at	O
least	O
a	O
few	O
approaches	O
to	O
shortening	O
the	O
syntax	O
for	O
this	O
in	O
Pandas	O
,	O
until	O
it	O
gets	O
a	O
full	O
query	O
API	O
down	O
the	O
road	O
(	O
perhaps	O
I'll	O
try	O
to	O
join	B-API
the	O
github	O
project	O
and	O
do	O
this	O
is	O
time	O
permits	O
and	O
if	O
no	O
one	O
else	O
already	O
has	O
started	O
)	O
.	O

Expanding	B-API
the	O
mini	O
domain-specific	O
language	O
I	O
made	O
above	O
for	O
expressing	O
logicals	O
to	O
have	O
this	O
option	O
with	O
simple	O
syntax	O
will	O
probably	O
be	O
an	O
uncomfortable	O
chore	O
.	O

Is	O
there	O
a	O
way	O
to	O
perform	O
inner	O
and	O
outer	O
joins	O
in	O
`	O
data.table	O
`	O
without	O
resorting	O
to	O
`	O
merge	B-API
(	O
X	O
,	O
Y	O
,	O
all=FALSE	O
)`	O
and	O
`	O
merge	B-API
(	O
X	O
,	O
Y	O
,	O
all=TRUE	O
)`	O
?	O

And	O
I	O
think	O
most	O
of	O
the	O
pandas	O
merge	B-API
code	O
is	O
in	O
Cython	O
.	O

In	O
this	O
case	O
(	O
database	O
joins	O
)	O
pandas	O
'	O
DataFrame	B-API
contains	O
no	O
pre-computed	O
information	O
that	O
is	O
being	O
used	O
for	O
the	O
merge	B-API
,	O
so	O
to	O
speak	O
it's	O
a	O
"	O
cold	O
"	O
merge	B-API
.	O

If	O
I	O
had	O
stored	O
the	O
factorized	O
versions	O
of	O
the	O
join	B-API
keys	O
,	O
the	O
join	B-API
would	O
be	O
significantly	O
faster	O
-	O
as	O
factorizing	O
is	O
the	O
biggest	O
bottleneck	O
for	O
this	O
algorithm	O
.	O

Of	O
course	O
,	O
now	O
that	O
you've	O
figured	O
it	O
all	O
out	O
in	O
python	O
,	O
it	O
should	O
be	O
easy	O
to	O
translate	B-API
into	O
R	O
;)	O

This	O
isn't	O
really	O
the	O
join	B-API
itself	O
(	O
the	O
algorithm	O
)	O
,	O
but	O
a	O
preliminary	O
step	O
.	O

Some	O
benchmark	O
results	O
are	O
already	O
reported	O
by	O
`	O
test.data.table()	O
`	O
but	O
that	O
code	O
isn't	O
hooked	O
up	O
yet	O
to	O
replace	B-API
the	O
levels	O
to	O
levels	O
match	O
.	O

Also	O
,	O
`	O
data.table	O
`	O
has	O
time	O
series	O
merge	B-API
in	O
mind	O
.	O

Two	O
aspects	O
to	O
that	O
:	O
i	O
)	O
multi	O
column	O
ordered	O
keys	O
such	O
as	O
(	O
id	O
,	O
datetime	O
)	O
ii	O
)	O
fast	O
prevailing	O
join	B-API
(	O
`	O
roll=TRUE	O
`)	O
a.k.a.	O
last	O
observation	O
carried	O
forward	O
.	O

`	O
data.table	O
`	O
has	O
time	O
series	O
merge	B-API
in	O
mind	O
.	O

join	B-API
(	O
`	O
roll=TRUE	O
`)	O
a.k.a.	O
last	O
observation	O
carried	O
forward	O
.	O

So	O
the	O
Pandas	O
equi	O
join	B-API
of	O
two	O
character	O
columns	O
is	O
probably	O
still	O
faster	O
than	O
data.table	O
.	O

I	O
actually	O
have	O
not	O
yet	O
optimized	O
the	O
code	O
for	O
the	O
integer	O
join	B-API
key	O
case	O
(	O
put	O
that	O
on	O
my	O
todo	O
list	O
!	O
)	O
,	O
but	O
you	O
can	O
expect	O
significantly	O
better	O
performance	O
than	O
the	O
string	O
case	O
given	O
the	O
hash	O
table	O
study	O
in	O
the	O
linked	O
presentation	O
.	O

Here's	O
some	O
Rprof	O
results	O
#URL	O
It	O
looks	O
like	O
20-40	O
%	O
of	O
the	O
time	O
is	O
spent	O
in	O
sortedmatch	O
depending	O
on	O
the	O
join	B-API
type	O
.	O

The	O
graph	O
depicted	O
there	O
shows	O
how	O
different	O
tools	O
and	O
packages	O
compare	O
in	O
terms	O
of	O
aggregation	O
and	O
join	B-API
speed	O
.	O

I	O
hope	O
someone	O
does	O
a	O
join	B-API
benchmark	O
soon	O
too	O
!	O

You	O
can	O
also	O
use	O
panels	O
to	O
help	O
you	O
do	O
this	O
pivot	B-API
.	O

I	O
am	O
trying	O
to	O
do	O
a	O
pivot	B-API
table	O
of	O
frequency	O
counts	O
using	O
Panda	O
.	O

Just	O
replace	B-API
`	O
rows	O
=[	O
'	O
Y	O
']`	O
with	O
`	O
rows	O
=[	O
'	O
X2	O
']`	O
#CODE	O

It	O
doesn't	O
have	O
the	O
GUI	O
tools	O
of	O
Enthought	O
but	O
otherwise	O
contains	O
a	O
full	O
scientific	O
python	O
stack	B-API
.	O

Debug	O
build	O
of	O
Python	O
(	O
python-dbg	O
)	O
in	O
tandem	O
with	O
gdb	O
allow	O
you	O
right	O
away	O
debug	O
your	O
extensions	O
while	O
inspecting	O
Python	O
stack	B-API
etc	O
.	O

I	O
would	O
also	O
be	O
interested	O
in	O
aligning	O
my	O
irregular	O
timestamp	O
intervals	O
to	O
one	O
second	O
resolution	O
,	O
I	O
would	O
still	O
wish	O
to	O
plot	O
multiple	O
events	O
for	O
a	O
given	O
second	O
,	O
but	O
maybe	O
I	O
could	O
introduce	O
a	O
unique	O
index	O
,	O
then	O
align	B-API
my	O
prices	O
to	O
it	O
?	O

I	O
will	O
join	B-API
pystatsmodels	O
--	O
if	O
you	O
are	O
looking	O
for	O
stumbling	O
noobs	O
with	O
use	O
cases	O
,	O
I	O
could	O
be	O
fertile	O
territory	O
.	O

I	O
have	O
a	O
SAS	O
background	O
and	O
was	O
thinking	O
it'd	O
replace	B-API
proc	O
freq	B-API
--	O
it	O
looks	O
like	O
it'll	O
scale	O
to	O
what	O
I	O
may	O
want	O
to	O
do	O
in	O
the	O
future	O
.	O

However	O
,	O
I	O
just	O
can't	O
seem	O
to	O
get	O
my	O
head	O
around	O
a	O
simple	O
task	O
(	O
I'm	O
not	O
sure	O
if	O
I'm	O
supposed	O
to	O
look	O
at	O
`	O
pivot	B-API
/	O
crosstab	B-API
/	O
indexing	O
`	O
-	O
whether	O
I	O
should	O
have	O
a	O
`	O
Panel	B-API
`	O
or	O
`	O
DataFrames	O
`	O
etc	O
...	O
)	O
.	O

I	O
can't	O
work	O
out	O
whether	O
I	O
should	O
be	O
using	O
`	O
pivot	B-API
/	O
crosstab	B-API
/	O
groupby	B-API
/	O
an	O
index	O
`	O

Then	O
,	O
using	O
the	O
ability	O
to	O
apply	B-API
multiple	O
aggregation	O
functions	O
following	O
a	O
groupby	B-API
,	O
you	O
can	O
say	O
:	O
#CODE	O

I	O
think	O
I	O
will	O
continue	O
converting	O
the	O
dataframe	B-API
after	O
loading	O
with	O
the	O
apply	B-API
method	O
.	O

Reason	O
I	O
put	O
table=True	O
is	O
that	O
I	O
want	O
to	O
*	O
append	B-API
*	O
to	O
existing	O
tables	O
for	O
very	O
large	O
data	O
sets	O
.	O

So	O
it	O
seems	O
the	O
combination	O
of	O
append	B-API
and	O
mixed-type	O
is	O
still	O
on	O
the	O
todo-list	O
?	O

suspect	O
with	O
some	O
unix	O
magic	O
you	O
can	O
transform	B-API
a	O
FWF	O
file	O
into	O
a	O
CSV	O

Pandas	O
rolling	B-API
median	B-API
for	O
duplicate	O
time	O
series	O
data	O

I	O
am	O
wondering	O
if	O
there	O
is	O
a	O
good	O
way	O
to	O
apply	B-API
rolling	B-API
window	O
means	O
to	O
a	O
dataset	O
with	O
duplicate	O
times	O
by	O
a	O
multi-index	O
tag	O
/	O
column	O

What	O
I	O
want	O
to	O
do	O
is	O
build	O
and	O
graph	O
rolling	B-API
means	O
with	O
varying	O
ms	O
windows	O
,	O
by	O
event	O
and	O
event+tag	O
.	O

join	B-API
or	O
merge	B-API
with	O
overwrite	O
in	O
pandas	O

I	O
want	O
to	O
perform	O
a	O
join	B-API
/	O
merge	B-API
/	O
append	B-API
operation	O
on	O
a	O
dataframe	B-API
with	O
datetime	O
index	O
.	O

Try	O
the	O
`	O
truncate	B-API
`	O
method	O
:	O
#CODE	O

I'm	O
on	O
#URL	O
and	O
I	O
haven't	O
found	O
the	O
truncate	B-API
function	O
.	O

@USER	O
:	O
here's	O
the	O
link	O
to	O
the	O
description	O
of	O
truncate	B-API
in	O
the	O
current	O
documentation	O
(	O
v0.7.2	O
):	O
#URL	O

See	O
my	O
answer	O
below	O
--	O
if	O
someone	O
would	O
contribute	O
some	O
docs	O
about	O
truncate	B-API
that	O
would	O
be	O
helpful	O
.	O

I	O
am	O
trying	O
to	O
insert	B-API
a	O
pandas	O
(	O
pandas.pydata.org	O
)	O
DataFrame	B-API
into	O
a	O
Postgresql	O
DB	O
(	O
9.1	O
)	O
in	O
the	O
most	O
efficient	O
way	O
(	O
using	O
Python	O
2.7	O
)	O
.	O

You	O
can	O
also	O
perform	O
aggregation	O
on	O
individual	O
columns	O
,	O
in	O
which	O
case	O
the	O
aggregate	B-API
function	O
works	O
on	O
a	O
Series	O
object	O
.	O

it	O
uses	O
numpys	O
"	O
argmax	B-API
"	O
function	O
to	O
find	O
the	O
rowindex	O
in	O
which	O
the	O
maximum	O
appears	O
.	O

i	O
tested	O
the	O
speed	O
on	O
a	O
dataframe	B-API
with	O
24735	O
rows	O
,	O
grouped	O
into	O
16	O
groups	O
(	O
btw	O
:	O
dataset	O
from	O
planethunter.org	O
)	O
and	O
got	O
12.5	O
ms	O
(	O
argmax	B-API
)	O
vs	O
17.5	O
ms	O
(	O
sort	O
)	O
as	O
a	O
result	O
of	O
%timeit	O
.	O

If	O
the	O
number	O
of	O
"	O
obj_id	O
"	O
s	O
is	O
very	O
high	O
you'll	O
want	O
to	O
sort	O
the	O
entire	O
dataframe	B-API
and	O
then	O
drop	B-API
duplicates	O
to	O
get	O
the	O
last	O
element	O
.	O

This	O
should	O
be	O
faster	O
(	O
sorry	O
I	O
didn't	O
test	O
it	O
)	O
because	O
you	O
don't	O
have	O
to	O
do	O
a	O
custom	O
agg	B-API
function	O
,	O
which	O
is	O
slow	O
when	O
there	O
is	O
a	O
large	O
number	O
of	O
keys	O
.	O

However	O
mine	O
uses	O
the	O
apply	B-API
function	O
of	O
a	O
dataframe	B-API
instead	O
of	O
the	O
aggregate	B-API
.	O

Yes	O
,	O
just	O
use	O
truncate	B-API
.	O

I	O
have	O
been	O
using	O
the	O
scikits.statsmodels	O
OLS	O
predict	O
function	O
to	O
forecast	O
fitted	O
data	O
but	O
would	O
now	O
like	O
to	O
shift	B-API
to	O
using	O
Pandas	O
.	O

I	O
have	O
tried	O
using	O
`	O
groupby	B-API
`	O
and	O
`	O
agg	B-API
`	O
but	O
to	O
no	O
avail	O
.	O

and	O
apply	B-API
agg()	B-API
with	O
it	O
:	O
#CODE	O

I	O
want	O
to	O
make	O
a	O
pivot_table	B-API
on	O
the	O
dataframe	B-API
using	O
counting	O
aggregate	B-API
per	O
month	O
for	O
each	O
location	O
.	O

to	O
pivot	B-API
the	O
values	O
.	O

It	O
wants	O
to	O
apply	B-API
the	O
to	O
strings	O
,	O
not	O
series	O
object	O
.	O

I	O
think	O
you	O
received	O
a	O
KeyError	O
because	O
``	O
df	O
``	O
was	O
indexed	O
before	O
joining	O
,	O
thus	O
'	O
first	O
'	O
was	O
no	O
longer	O
a	O
column	O
to	O
join	B-API
"	O
on	O
"	O
.	O

To	O
put	O
data	O
in	O
a	O
DataFrame	B-API
indexed	O
by	O
that	O
,	O
you	O
should	O
add	O
the	O
columns	O
and	O
reindex	B-API
them	O
to	O
the	O
date	O
range	O
above	O
using	O
`	O
method=	O
'	O
ffill	B-API
'`	O
:	O
#CODE	O

I	O
am	O
trying	O
do	O
use	O
a	O
pandas	O
multiindex	B-API
to	O
select	O
a	O
partial	O
slice	O
at	O
the	O
top	O
level	O
index	O
(	O
date	O
)	O
,	O
and	O
apply	B-API
a	O
list	O
to	O
the	O
second	O
level	O
index	O
(	O
stock	O
symbol	O
)	O
.	O

which	O
DOES	O
work	O
when	O
passed	O
to	O
ix	B-API
.	O

How	O
to	O
resample	B-API
a	O
dataframe	B-API
with	O
different	O
functions	O
applied	O
to	O
each	O
column	O
?	O

You	O
can	O
also	O
downsample	O
using	O
the	O
`	O
asof	B-API
`	O
method	O
of	O
`	O
pandas.DateRange	O
`	O
objects	O
.	O

@	O
Wes	O
McKinney	O
this	O
should	O
be	O
`	O
resample	B-API
`	O
in	O
0.8	O
,	O
isn't	O
it	O
?	O

Pandas	O
:	O
simple	O
'	O
join	B-API
'	O
not	O
working	O
?	O

I	O
can	O
achieve	O
the	O
desired	O
results	O
using	O
'	O
merge	B-API
'	O
.	O

But	O
I	O
eventually	O
need	O
to	O
join	B-API
multiple	O
`	O
pandas	O
`	O
`	O
DataFrames	O
`	O
so	O
I	O
need	O
to	O
get	O
this	O
method	O
working	O
.	O

Try	O
using	O
`	O
merge	B-API
`	O
(	O
#URL	O
):	O
#CODE	O

So	O
it	O
looks	O
like	O
in	O
order	O
to	O
get	O
what	O
I	O
want	O
I'll	O
have	O
to	O
perform	O
successive	O
merges	O
,	O
since	O
`	O
merge	B-API
`	O
only	O
take	O
two	O
DataFrames	O
?	O

From	O
the	O
0.16.2	O
docs	O
:	O
The	O
related	O
DataFrame.join	B-API
method	O
,	O
uses	O
merge	B-API
internally	O
for	O
the	O
index-on-index	O
and	O
index-on-column	O
(	O
s	O
)	O
joins	O
,	O
but	O
joins	O
on	O
indexes	O
by	O
default	O
rather	O
than	O
trying	O
to	O
join	B-API
on	O
common	O
columns	O
(	O
the	O
default	O
behavior	O
for	O
merge	B-API
)	O
.	O

Best	O
way	O
to	O
insert	B-API
a	O
new	O
value	O

My	O
question	O
is	O
,	O
how	O
can	O
I	O
group	O
/	O
transform	B-API
the	O
data	O
in	O
such	O
a	O
way	O
that	O
I	O
have	O
a	O
MultiIndex	B-API
with	O
(	O
Z	O
,	O
A	O
)	O
as	O
indexes	O
(	O
or	O
MultiIndexes	O
)	O
having	O
into	O
account	O
that	O
the	O
data	O
is	O
not	O
unique	O
?	O

Now	O
use	O
this	O
as	O
an	O
auxiliary	O
index	O
variable	O
and	O
unstack	B-API
:	O
#CODE	O

Is	O
there	O
a	O
way	O
to	O
index	O
`	O
series	B-API
`	O
by	O
the	O
mapping	O
of	O
result	O
/	O
frequency	O
defined	O
by	O
`	O
freq	B-API
`	O
?	O

Yes	O
,	O
use	O
the	O
`	O
map	B-API
`	O
Series	O
method	O
:	O
#CODE	O

Pandas	O
:	O
trouble	O
understading	O
how	O
merge	B-API
works	O

I'm	O
doing	O
something	O
wrong	O
with	O
merge	B-API
and	O
I	O
can't	O
understand	O
what	O
it	O
is	O
.	O

If	O
I	O
print	O
`	O
hist	B-API
`	O
and	O
`	O
freq	B-API
`	O
this	O
is	O
what	O
I	O
get	O
:	O
#CODE	O

They're	O
both	O
indexed	O
by	O
`"	O
series	O
"`	O
but	O
if	O
I	O
try	O
to	O
merge	B-API
:	O
#CODE	O

on	O
:	O
Columns	O
(	O
names	O
)	O
to	O
join	B-API
on	O
.	O

are	O
False	O
,	O
the	O
intersection	B-API
of	O
the	O
columns	O
in	O
the	O
DataFrames	O
will	O
be	O

inferred	O
to	O
be	O
the	O
join	B-API
keys	O

Alternatively	O
and	O
more	O
simply	O
,	O
`	O
DataFrame	B-API
`	O
has	O
`	O
join	B-API
`	O
method	O
which	O
does	O
exactly	O
what	O
you	O
want	O
:	O
#CODE	O

Time	O
to	O
improve	O
the	O
merge	B-API
docstring	O
!	O

I	O
would	O
like	O
to	O
use	O
pandas	O
to	O
create	O
a	O
HLOC	O
chart	O
of	O
data	O
for	O
every	O
one	O
minute	O
starting	O
with	O
time	O
zero	O
being	O
9:46	O
using	O
the	O
asof	B-API
method	O
....	O

Is	O
there	O
a	O
add	O
to	O
table	O
method	O
....	O
thinking	O
.....	O
take	O
new	O
data	O
,	O
process	O
(	O
ts.convert	O
)	O
.	O
append	B-API
table	O
..	O
numpy	O
add	O
to	O
array	O
.	O
any	O
help	O
here	O
.	O

You	O
can	O
append	B-API
data	O
(	O
yielding	O
a	O
new	O
object	O
)	O
with	O
df.append	B-API
(	O
new_data	O
)	O
but	O
that's	O
not	O
especially	O
efficient	O

"	O
Parameters	O
----------	O
key	O
:	O
object	O
Some	O
label	O
contained	O
in	O
the	O
index	O
,	O
or	O
partially	O
in	O
a	O
MultiIndex	B-API
axis	O
:	O
int	O
,	O
default	O
0	O
Axis	O
to	O
retrieve	O
cross-section	O
on	O
copy	O
:	O
boolean	O
,	O
default	O
True	O
Whether	O
to	O
make	O
a	O
copy	O
of	O
the	O
data	O
"	O

Color	O
each	O
alternative	O
cell	O
with	O
a	O
specific	O
color	O
(	O
like	O
a	O
chess	O
board	O
:	O
instead	O
of	O
black	O
/	O
white	O
I	O
will	O
use	O
some	O
other	O
color	O
combination	O
)	O
and	O
insert	B-API
value	O
for	O
each	O
cell	O
from	O
a	O
pandas	O
data	O
frame	O
or	O
python	O
dictionary	O
.	O

You	O
can	O
either	O
truncate	B-API
the	O
data	O
,	O
or	O
add	O
an	O
extra	O
column	O
.	O

This	O
function	O
was	O
updated	O
to	O
the	O
name	O
`	O
idxmax	B-API
`	O
in	O
the	O
Pandas	O
API	O
,	O
though	O
as	O
of	O
Pandas	O
0.16	O
,	O
`	O
argmax	B-API
`	O
still	O
exists	O
and	O
performs	O
the	O
same	O
function	O
(	O
though	O
appears	O
to	O
run	O
more	O
slowly	O
than	O
`	O
idxmax	B-API
`)	O
.	O

Previously	O
(	O
as	O
noted	O
in	O
the	O
comments	O
)	O
it	O
appeared	O
that	O
`	O
argmax	B-API
`	O
would	O
exist	O
as	O
a	O
separate	O
function	O
which	O
provided	O
the	O
integer	O
position	O
within	O
the	O
index	O
of	O
the	O
row	O
location	O
of	O
the	O
maximum	O
element	O
.	O

In	O
general	O
,	O
I	O
think	O
the	O
move	O
to	O
`	O
idxmax	B-API
`	O
-like	O
behavior	O
for	O
all	O
three	O
of	O
the	O
approaches	O
(	O
`	O
argmax	B-API
`	O
,	O
which	O
still	O
exists	O
,	O
`	O
idxmax	B-API
`	O
,	O
and	O
`	O
numpy.argmax	O
`)	O
is	O
a	O
bad	O
thing	O
,	O
since	O
it	O
is	O
very	O
common	O
to	O
require	O
the	O
positional	O
integer	O
location	O
of	O
a	O
maximum	O
,	O
perhaps	O
even	O
more	O
common	O
than	O
desiring	O
the	O
label	O
of	O
that	O
positional	O
location	O
within	O
some	O
index	O
,	O
especially	O
in	O
applications	O
where	O
duplicate	O
row	O
labels	O
are	O
common	O
.	O

So	O
here	O
a	O
naive	O
use	O
of	O
`	O
idxmax	B-API
`	O
is	O
not	O
sufficient	O
,	O
whereas	O
the	O
old	O
form	O
of	O
`	O
argmax	B-API
`	O
would	O
correctly	O
provide	O
the	O
positional	O
location	O
of	O
the	O
max	O
row	O
(	O
in	O
this	O
case	O
,	O
position	O
9	O
)	O
.	O

So	O
you're	O
left	O
with	O
hoping	O
that	O
your	O
unit	O
tests	O
covered	O
everything	O
(	O
they	O
didn't	O
,	O
or	O
more	O
likely	O
no	O
one	O
wrote	O
any	O
tests	O
)	O
--	O
otherwise	O
(	O
most	O
likely	O
)	O
you're	O
just	O
left	O
waiting	O
to	O
see	O
if	O
you	O
happen	O
to	O
smack	O
into	O
this	O
error	O
at	O
runtime	O
,	O
in	O
which	O
case	O
you	O
probably	O
have	O
to	O
go	O
drop	B-API
many	O
hours	O
worth	O
of	O
work	O
from	O
the	O
database	O
you	O
were	O
outputting	O
results	O
to	O
,	O
bang	O
your	O
head	O
against	O
the	O
wall	O
in	O
IPython	O
trying	O
to	O
manually	O
reproduce	O
the	O
problem	O
,	O
finally	O
figuring	O
out	O
that	O
it's	O
because	O
`	O
idxmax	B-API
`	O
can	O
only	O
report	O
the	O
label	O
of	O
the	O
max	O
row	O
,	O
and	O
then	O
being	O
disappointed	O
that	O
no	O
standard	O
function	O
automatically	O
gets	O
the	O
positions	O
of	O
the	O
max	O
row	O
for	O
you	O
,	O
writing	O
a	O
buggy	O
implementation	O
yourself	O
,	O
editing	O
the	O
code	O
,	O
and	O
praying	O
you	O
don't	O
run	O
into	O
the	O
problem	O
again	O
.	O

Per	O
#URL	O
argmax	B-API
is	O
now	O
idxmax	B-API
.	O

Based	O
on	O
the	O
second-to-last	O
comment	O
there	O
,	O
it	O
looks	O
like	O
`	O
argmin	B-API
`	O
and	O
`	O
argmax	B-API
`	O
will	O
remain	O
part	O
of	O
`	O
DataFrame	B-API
`	O
and	O
the	O
difference	O
is	O
just	O
whether	O
you	O
want	O
the	O
index	O
or	O
the	O
label	O
.	O

`	O
argmax	B-API
`	O
will	O
give	O
you	O
the	O
index	O
integer	O
itself	O
.	O

Note	O
that	O
you	O
need	O
to	O
be	O
careful	O
trying	O
to	O
use	O
the	O
output	O
of	O
`	O
idxmax	B-API
`	O
as	O
a	O
feeder	O
into	O
`	O
ix	B-API
`	O
or	O
`	O
loc	B-API
`	O
as	O
a	O
means	O
to	O
sub-slice	O
the	O
data	O
and	O
/	O
or	O
to	O
obtain	O
the	O
positional	O
location	O
of	O
the	O
max-row	O
.	O

Another	O
way	O
I	O
did	O
something	O
similar	O
was	O
create	O
a	O
pivot	B-API
table	O

In	O
this	O
case	O
I	O
want	O
to	O
convert	O
this	O
pivot	B-API
table	O
to	O
2d	O
numpy	O
array	O
.	O

AttributeError	O
:	O
Cannot	O
access	O
callable	O
attribute	O
'	O
reset_index	B-API
'	O
of	O
'	O
DataFrameGroupBy	B-API
'	O
objects	O
,	O
try	O
using	O
the	O
'	O
apply	B-API
'	O
method	O

Aggregating	O
functions	O
are	O
ones	O
that	O
reduce	O
the	O
dimension	O
of	O
the	O
returned	O
objects	O
,	O
for	O
example	O
:	O
`	O
mean	B-API
`	O
,	O
`	O
sum	B-API
`	O
,	O
`	O
size	B-API
`	O
,	O
`	O
count	B-API
`	O
,	O
`	O
std	B-API
`	O
,	O
`	O
var	B-API
`	O
,	O
`	O
sem	B-API
`	O
,	O
`	O
describe	B-API
`	O
,	O
`	O
first	B-API
`	O
,	O
`	O
last	B-API
`	O
,	O
`	O
nth	B-API
`	O
,	O
`	O
min	B-API
`	O
,	O
`	O
max	B-API
`	O
.	O

if	O
you	O
really	O
need	O
to	O
replace	B-API
the	O
version	O
provided	O
by	O
the	O
system	O
,	O
uninstall	O
it	O
.	O

The	O
`	O
reindex	B-API
`	O
method	O
can	O
accomplish	O
this	O
when	O
passed	O
a	O
reordered	O
array	O
of	O
tuples	O
matching	O
the	O
desired	O
order	O
.	O

let	O
me	O
try	O
to	O
answer	O
this	O
.	O
basically	O
i	O
will	O
pad	O
or	O
reindex	B-API
with	O
complete	O
weekdays	O
and	O
sample	O
every	O
5	O
days	O
while	O
drop	B-API
missing	O
data	O
due	O
to	O
holiday	O
or	O
suspension	O

There	O
may	O
be	O
cleaner	O
way	O
to	O
perform	O
the	O
next	O
step	O
,	O
but	O
the	O
goal	O
is	O
to	O
change	O
the	O
index	O
from	O
an	O
array	O
of	O
tuples	O
to	O
a	O
MultiIndex	B-API
object	O
.	O

The	O
final	O
step	O
is	O
to	O
"	O
unstack	B-API
"	O
weekday	B-API
from	O
the	O

MultiIndex	B-API
,	O
creating	O
columns	O
for	O
each	O
weekday	B-API
,	O
and	O
replace	B-API
the	O
weekday	B-API
numbers	O
with	O
an	O
abbreviation	O
,	O
to	O
improve	O
readability	O
.	O

To	O
create	O
a	O
line	O
plot	O
for	O
each	O
week	O
,	O
transpose	B-API
the	O
dataframe	B-API
,	O
so	O
the	O
columns	O
are	O
week	O
numbers	O
and	O
rows	O
are	O
weekdays	O
(	O
note	O
this	O
step	O
can	O
be	O
avoided	O
by	O
unstacking	O
week	O
number	O
,	O
in	O
place	O
of	O
weekday	B-API
,	O
in	O
the	O
previous	O
step	O
)	O
,	O
and	O
call	O
`	O
plot	B-API
`	O
.	O

I	O
think	O
the	O
same	O
concepts	O
apply	B-API
to	O
an	O
index	O
of	O
floats	O
.	O

I	O
can	O
reindex	B-API
but	O
how	O
do	O
i	O
deal	O
with	O
`	O
NaN	O
`	O
?	O

It	O
would	O
be	O
nice	O
to	O
have	O
a	O
convenience	O
function	O
for	O
this	O
where	O
you	O
can	O
pick	O
the	O
axes	O
to	O
interpolate	B-API
over	O

Could	O
also	O
use	O
DataFrame's	O
interpolate	B-API
method	O
?	O

but	O
it	O
would	O
work	O
if	O
the	O
csv	O
file	O
would	O
be	O
somehow	O
transpose	B-API
.	O

Obviously	O
you	O
may	O
need	O
to	O
clean	O
you	O
data	O
after	O
import	O
,	O
e.g.	O
you	O
chould	O
check	O
for	O
data	O
types	O
,	O
remove	O
empty	O
fields	O
(	O
or	O
replace	B-API
with	O
None	O
)	O
This	O
version	O
processes	O
the	O
entire	O
dataset	O
,	O
but	O
only	O
returns	O
one	O
line	O
,	O
so	O
you	O
could	O
use	O
break	O
at	O
that	O
point	O
or	O
perhaps	O
append	B-API
other	O
interesting	O
data	O
.	O

I'm	O
trying	O
to	O
align	B-API
my	O
index	O
values	O
between	O
multiple	O
DataFrames	O
or	O
Series	O
and	O
I'm	O
using	O

Series.interpolate	B-API
but	O
it	O
doesn't	O
seem	O
to	O
interpolate	B-API
correctly	O
.	O

I	O
don't	O
think	O
underlying	O
mathematics	O
apply	B-API
that	O
sum	O
of	O
interpolation	O
equal	O
to	O
interpolation	O
of	O
sum	O
.	O

It	O
assumes	O
they	O
are	O
equally	O
spaced	O
and	O
just	O
uses	O
`	O
len	B-API
(	O
serie	O
)`	O
for	O
indexes	O
.	O

I	O
modified	O
the	O
`	O
Series.interpolate	B-API
`	O
method	O
and	O
came	O
up	O
with	O
this	O
`	O
interpolate	B-API
`	O
function	O
.	O

I	O
don't	O
understand	O
why	O
the	O
join	B-API
has	O
created	O
a	O
tuple	O
.	O

When	O
I	O
export	O
the	O
csv	O
--	O
it	O
gives	O
back	O
the	O
*	O
original	O
*	O
data	O
set	O
df1	O
(	O
&	O
vice	O
versa	O
for	O
if	O
df1	O
and	O
df2	O
are	O
swapped	O
in	O
the	O
align	B-API
command	O
)	O
.	O

Is	O
there	O
a	O
reason	O
one	O
shouldn't	O
use	O
align	B-API
for	O
this	O
task	O
?	O

Using	O
join	B-API
works	O
for	O
what	O
I	O
needed	O
.	O

I'm	O
still	O
curious	O
about	O
the	O
align	B-API
...	O

@USER	O
Align	B-API
,	O
I	O
would	O
imagine	O
,	O
simply	O
arranges	O
the	O
data	O
.	O

`	O
align	B-API
`	O
returns	O
aligned	O
versions	O
of	O
the	O
left	O
and	O
right	O
DataFrames	O
(	O
as	O
a	O
tuple	O
):	O

Not	O
sure	O
whats	O
the	O
way	O
to	O
append	B-API
to	O
current	O
data	O
frame	O
in	O
pandas	O
or	O
is	O
there	O
a	O
way	O
for	O
pandas	O
to	O
suck	O
a	O
list	O
of	O
files	O
into	O
a	O
data	O
frame	O
.	O

Once	O
you	O
have	O
read	O
the	O
files	O
and	O
save	O
it	O
in	O
two	O
dataframes	O
,	O
you	O
could	O
merge	B-API
the	O
two	O
dataframes	O
or	O
add	O
additional	O
columns	O
to	O
one	O
of	O
the	O
two	O
dataframes	O
(	O
assuming	O
common	O
index	O
)	O
.	O

Why	O
not	O
use	O
read_csv	B-API
,	O
to	O
build	O
two	O
(	O
or	O
more	O
)	O
dataframes	O
,	O
then	O
use	O
join	B-API
to	O
put	O
them	O
together	O
?	O

The	O
pandas	O
`	O
concat	B-API
`	O
command	O
is	O
your	O
friend	O
here	O
.	O

`	O
dr	O
=	O
pd.date_range	B-API
(	O
dt	B-API
(	O
2009	O
,	O
1	O
,	O
1	O
)	O
,	O
dt	B-API
(	O
2010	O
,	O
12	O
,	O
31	O
)	O
,	O
freq=	O
'	O
H	O
')	O
;	O

dt	B-API
=	O
pd.DataFrame	B-API
(	O
rand	O
(	O
len	B-API
(	O
dr	O
)	O
,	O
2	O
)	O
,	O
dr	O
);	O

data	O
=	O
dt	B-API
[	O
selector	O
]`	O

there	O
is	O
conflict	O
of	O
dt	B-API
package	O
and	O
dt	B-API
variable	O

Python	O
Pandas	O
:	O
Aggregate	B-API
changed	O
from	O
0.7.1	O
to	O
0.7.3	O

The	O
problem	O
seems	O
to	O
be	O
with	O
the	O
aggregate	B-API
method	O
.	O

I'm	O
using	O
a	O
dictionary	O
of	O
different	O
aggregation	O
methods	O
to	O
`	O
agg	B-API
`	O
different	O
columns	O
(	O
`	O
np.mean	O
`	O
,	O
`	O
np.sum	O
`	O
...	O
etc	O
)	O
.	O

"	O
No	O
numeric	O
values	O
to	O
aggregate	B-API
"	O

Pandas	O
:	O
Sort	O
pivot	B-API
table	O

Just	O
trying	O
out	O
Pandas	O
for	O
the	O
first	O
time	O
,	O
and	O
I	O
am	O
trying	O
to	O
sort	O
a	O
pivot	B-API
table	O
first	O
by	O
an	O
index	O
,	O
then	O
by	O
the	O
values	O
in	O
a	O
series	O
.	O

What's	O
the	O
correct	O
way	O
to	O
sort	O
a	O
pivot	B-API
table	O
by	O
index	O
then	O
value	O
?	O

For	O
example	O
,	O
just	O
focus	O
on	O
the	O
ix	B-API
interface	O
.	O

using	O
the	O
ix	B-API

using	O
the	O
reindex	B-API
method	O

I'm	O
trying	O
to	O
do	O
shift	B-API
operations	O
...	O
but	O
this	O
also	O
happens	O
with	O
the	O
window	O
functions	O
like	O
`	O
rolling_mean	B-API
`	O
.	O

On	O
an	O
aside	O
:	O
does	O
truncate	B-API
need	O
to	O
be	O
existing	O
indexes	O
in	O
the	O
data	O
?	O

Note	O
this	O
is	O
a	O
very	O
inefficient	O
way	O
to	O
build	O
a	O
large	O
DataFrame	B-API
;	O
new	O
arrays	O
have	O
to	O
be	O
created	O
(	O
copying	O
over	O
the	O
existing	O
data	O
)	O
when	O
you	O
append	B-API
a	O
row	O
.	O

For	O
details	O
and	O
examples	O
,	O
see	O
Merge	B-API
,	O
join	B-API
,	O
and	O
concatenate	O
.	O

I	O
has	O
a	O
similar	O
problem	O
where	O
if	O
I	O
created	O
a	O
data	O
frame	O
for	O
each	O
row	O
and	O
append	B-API
it	O
to	O
the	O
main	O
data	O
frame	O
it	O
took	O
30	O
mins	O
.	O

Copying	O
from	O
pandas	O
docs	O
:	O
`	O
It	O
is	O
worth	O
noting	O
however	O
,	O
that	O
concat	B-API
(	O
and	O
therefore	O
append	B-API
)	O
makes	O
a	O
full	O
copy	O
of	O
the	O
data	O
,	O
and	O
that	O
constantly	O
reusing	O
this	O
function	O
can	O
create	O
a	O
significant	O
performance	O
hit	O
.	O

Add	O
rows	O
through	O
`	O
loc	B-API
`	O
on	O
non	O
existing	O
index	O
data	O
.	O

`	O
.loc	B-API
`	O
is	O
referencing	O
the	O
index	O
column	O
,	O
so	O
if	O
you're	O
working	O
with	O
a	O
pre-existing	O
DataFrame	B-API
with	O
an	O
index	O
that	O
isn't	O
a	O
continous	O
sequence	O
of	O
integers	O
starting	O
with	O
0	O
(	O
as	O
in	O
your	O
example	O
)	O
,	O
`	O
.loc	B-API
`	O
will	O
overwrite	O
existing	O
rows	O
,	O
or	O
insert	B-API
rows	O
,	O
or	O
create	O
gaps	O
in	O
your	O
index	O
.	O

I	O
would	O
like	O
to	O
print	O
the	O
intersection	B-API
between	O
them	O
removing	O
all	O
"	O
NaN's	O
"	O
,	O
but	O
without	O
loose	O
alignment	O
.	O

Do	O
you	O
mean	O
you	O
want	O
to	O
drop	B-API
rows	O
where	O
there	O
are	O
NaNs	O
in	O
either	O
of	O
the	O
S	O
or	O
JEXP	O
columns	O
only	O
?	O

numpy	O
function	O
to	O
aggregate	B-API
a	O
signal	O
for	O
time	O
?	O

I	O
know	O
about	O
apply	B-API
,	O
but	O
sometimes	O
it's	O
more	O
convenient	O
to	O
use	O
a	O
for	O
loop	O
.	O

Is	O
apply	B-API
more	O
efficient	O
than	O
iterrows	B-API
?	O

Returning	O
multiple	O
values	O
from	O
pandas	O
apply	B-API
on	O
a	O
DataFrame	B-API

This	O
is	O
fairly	O
trivial	O
with	O
pandas	O
,	O
using	O
`	O
apply	B-API
`	O
with	O
axis=1	O
.	O

However	O
,	O
I	O
can	O
either	O
return	O
a	O
DataFrame	B-API
of	O
the	O
same	O
shape	O
if	O
my	O
function	O
doesn't	O
aggregate	B-API
,	O
or	O
a	O
Series	O
if	O
it	O
aggregates	O
.	O

Is	O
this	O
possible	O
or	O
I	O
have	O
to	O
do	O
two	O
runs	O
for	O
the	O
two	O
calculations	O
,	O
then	O
merge	B-API
them	O
together	O
?	O

Why	O
are	O
you	O
using	O
`	O
apply	B-API
`	O
in	O
the	O
first	O
place	O
?	O

You	O
could	O
just	O
have	O
`	O
t_test_and_mean	O
`	O
accept	O
your	O
input	O
dataframe	B-API
(	O
and	O
the	O
columns	O
to	O
group	O
by	O
)	O
and	O
return	O
a	O
1-row-2-columns	O
dataframe	B-API
,	O
without	O
using	O
`	O
apply	B-API
`	O
.	O

Is	O
there	O
a	O
really	O
straight	O
forward	O
way	O
to	O
apply	B-API
a	O
css	O
to	O
an	O
IPython	O
Notebook	O
and	O
then	O
have	O
tables	O
rendered	O
using	O
the	O
style	O
sheet	O
?	O

If	O
you	O
just	O
stick	O
that	O
in	O
one	O
of	O
your	O
markdown	O
cells	O
,	O
then	O
it	O
will	O
apply	B-API
to	O
everything	O
on	O
the	O
page	O
.	O

b	O
)	O
now	O
do	O
a	O
left	O
join	B-API
on	O
this	O
on	O
the	O
data	O
set	O
A	O
.	O

It	O
also	O
does	O
a	O
`	O
sort	B-API
`	O
of	O
the	O
output	O
index	O
,	O
so	O
finally	O
the	O
complexity	O
is	O
something	O
like	O
O	O
(	O
m	O
lg	O
m	O
)	O
with	O
m	O
=	O
len	B-API
(	O
B.index	O
)	O
...	O

I	O
have	O
two	O
pandas	O
DataFrames	O
and	O
I	O
want	O
to	O
join	B-API
them	O
together	O
such	O
that	O
I	O
get	O
the	O
outer	O
join	B-API
with	O
the	O
duplicates	O
removed	O
.	O

And	O
then	O
join	B-API
all	O
the	O
pieces	O
together	O
with	O
`	O
pandas.concat	B-API
`	O
or	O
similar	O
.	O

Is	O
there	O
a	O
way	O
to	O
perform	O
something	O
similar	O
by	O
a	O
clever	O
use	O
of	O
`	O
crosstab	B-API
`	O
or	O
`	O
pivot_table	B-API
`	O
or	O
`	O
stack	B-API
`	O
or	O
something	O
similar	O
?	O

Note	O
that	O
I	O
have	O
implemented	O
new	O
`	O
cut	B-API
`	O
and	O
`	O
qcut	B-API
`	O
functions	O
for	O
discretizing	O
continuous	O
data	O
:	O

How	O
to	O
optimally	O
apply	B-API
a	O
function	O
on	O
all	O
items	O
of	O
a	O
dataframe	B-API
using	O
inputs	O
from	O
another	O
dataframe	B-API
?	O

I	O
would	O
like	O
to	O
apply	B-API
the	O
same	O
function	O
to	O
each	O
item	O
of	O
a	O
given	O
dataset	O
but	O
using	O
a	O
time-dependent	O
parameter	O
.	O

One	O
way	O
to	O
do	O
it	O
is	O
to	O
use	O
the	O
`	O
map	B-API
`	O
function	O
,	O
or	O
`	O
numpy.vectorize	O
`	O
;	O
it's	O
also	O
possible	O
to	O
do	O
it	O
with	O
lambda	O
functions	O
.	O

Again	O
,	O
`	O
read_table	B-API
`	O
can	O
be	O
used	O
,	O
for	O
example	O
:	O
`	O
pandas.read_table	B-API
(	O
buf	O
,	O
sep=	O
'	O
'	O
,	O
index_col	O
=[	O
0	O
,	O
1	O
]	O
,	O
header=None	O
)`	O
will	O
create	O
a	O
table	O
with	O
multiple	O
columns	O
and	O
a	O
`	O
multiindex	B-API
`	O
made	O
of	O
2	O
levels	O
:	O
first	O
level	O
the	O
year-month-day	O
,	O
second	O
level	O
the	O
time	O
.	O

If	O
you	O
wish	O
,	O
you	O
can	O
then	O
merge	B-API
the	O
multiindex	B-API
in	O
a	O
normal	O
index	O
(	O
for	O
example	O
:	O
`	O
df.index	O
=	O
[	O
'	O
%s	O
%s	O
'	O
%	O
(	O
a	O
,	O
b	O
)	O
for	O
a	O
,	O
b	O
in	O
zip	O
(	O
df.index.get_level_values	O
(	O
0	O
)	O
,	O
df.index.get_level_values	O
(	O
1	O
))]`	O
.	O

One	O
more	O
thing	O
:	O
the	O
grouping	O
with	O
multiindex	B-API
works	O
.	O

date_to	O
=	O
df.index	O
[	O
len	B-API
(	O
df.index	O
)	O
-1	O
]	O
#last	O
datetime	O
entry	O
in	O
date	O
frame	O

You	O
can	O
fix	O
it	O
with	O
:	O
`	O
df.index	O
=	O
map	B-API
(	O
dateutil.parser.parse	O
,	O
df.index	O
)`	O
and	O
then	O
date-ranges	O
are	O
:	O
`	O
pandas.DateRange	O
(	O
df.index	O
[	O
0	O
]	O
,	O
df.index	O
[	O
-1	O
])`	O
.	O

You	O
can	O
use	O
`	O
aggregate	B-API
`	O
to	O
define	O
your	O
aggregate	B-API
function	O
,	O
which	O
will	O
just	O
keep	O
the	O
first	O
element	O
of	O
a	O
column	O
and	O
drop	B-API
the	O
others	O
.	O

Pandas	O
:	O
List	O
of	O
Column	O
names	O
in	O
a	O
pivot	B-API
table	O

I	O
got	O
stuck	O
trying	O
to	O
get	O
the	O
resulting	O
names	O
of	O
a	O
pivot	B-API
table	O
.	O

I'm	O
having	O
a	O
bit	O
of	O
trouble	O
altering	O
a	O
duplicated	O
pandas	O
DataFrame	B-API
and	O
not	O
having	O
the	O
edits	O
apply	B-API
to	O
both	O
the	O
duplicate	O
and	O
the	O
original	O
DataFrame	B-API
.	O

Then	O
I	O
assign	O
the	O
'	O
d	O
'	O
dataframe	B-API
to	O
variable	O
'	O
e	O
'	O
and	O
apply	B-API
some	O
arbitrary	O
math	O
to	O
column	O
'	O
a	O
'	O
using	O
apply	B-API
:	O
#CODE	O

The	O
problem	O
arises	O
in	O
that	O
the	O
apply	B-API
function	O
apparently	O
applies	O
to	O
both	O
the	O
duplicate	O
DataFrame	B-API
'	O
e	O
'	O
and	O
original	O
DataFrame	B-API
'	O
d	O
'	O
,	O
which	O
I	O
cannot	O
for	O
the	O
life	O
of	O
me	O
figure	O
out	O
:	O
#CODE	O

can	O
you	O
specify	O
the	O
'	O
dropna	B-API
'	O
value	O
?	O
for	O
example	O
could	O
you	O
drop	B-API
rows	O
that	O
are	O
all	O
zeros	O
?	O

[	O
Documentation	O
]	O
(	O
#URL	O
)	O
for	O
read_csv	B-API
now	O
offers	O
both	O
`	O
na_values	O
`	O
(	O
list	O
or	O
dict	O
indexed	O
by	O
columns	O
)	O
and	O
`	O
keep_default_na	O
`	O
(	O
bool	B-API
)	O
.	O

Essentially	O
my	O
question	O
would	O
then	O
boil	O
down	O
to	O
:	O
how	O
to	O
join	B-API
several	O
unaligned	O
time	O
series	O
,	O
where	O
each	O
series	O
has	O
a	O
date	O
column	O
,	O
and	O
column	O
for	O
the	O
series	O
itself	O
(	O
.CSV	O
file	O
exported	O
from	O
Excel	O
)	O

the	O
thing	O
is	O
you	O
have	O
to	O
make	O
sure	O
that	O
there	O
is	O
case	O
like	O
date	O
exists	O
but	O
not	O
rate	O
.	O
because	O
dropna()	B-API
will	O
shift	B-API
records	O
and	O
mismatch	O
with	O
index	O

Now	O
,	O
to	O
join	B-API
then	O
together	O
and	O
align	B-API
the	O
data	O
in	O
a	O
DataFrame	B-API
,	O
you	O
can	O
do	O
:	O
#CODE	O

This	O
will	O
form	O
the	O
union	O
of	O
the	O
dates	O
in	O
`	O
ts1	O
`	O
and	O
`	O
ts2	O
`	O
and	O
align	B-API
all	O
of	O
the	O
data	O
(	O
inserting	O
NA	O
values	O
where	O
appropriate	O
)	O
.	O

So	O
,	O
apply	B-API
this	O
function	O
to	O
each	O
of	O
those	O
3	O
columns	O
:	O
#CODE	O

To	O
transform	B-API
to	O
strings	O
,	O
use	O
table.rename	O
:	O
#CODE	O

The	O
ix	B-API
[	O
,	O
]	O
construct	O
doesn't	O
check	O
if	O
column	O
exists	O
.	O

pandas	O
reindex	B-API
DataFrame	B-API
with	O
datetime	O
objects	O

Is	O
it	O
possible	O
to	O
reindex	B-API
a	O
pandas	O
DataFrame	B-API
using	O
a	O
column	O
made	O
up	O
of	O
datetime	O
objects	O
?	O

I	O
can	O
reindex	B-API
the	O
`	O
df	O
`	O
easily	O
along	O
`	O
DOYtimestamp	O
`	O
with	O
:	O
`	O
df.reindex	B-API
(	O
index	O
=d	O
f.dtstamp	O
)`	O

but	O
I'd	O
like	O
to	O
reindex	B-API
the	O
DataFrame	B-API
along	O
`	O
dtstamp	O
`	O
which	O
is	O
made	O
up	O
of	O
datetime	O
objects	O
so	O
that	O
I	O
generate	O
different	O
timestamps	O
directly	O
from	O
the	O
index	O
.	O

When	O
I	O
try	O
and	O
reindex	B-API
`	O
df	O
`	O
along	O
`	O
dtstamp	O
`	O
I	O
get	O
the	O
following	O
:	O
#CODE	O

It	O
sounds	O
like	O
you	O
don't	O
want	O
reindex	B-API
.	O

Somewhat	O
confusingly	O
`	O
reindex	B-API
`	O
is	O
not	O
for	O
defining	O
a	O
new	O
index	O
,	O
exactly	O
;	O
rather	O
,	O
it	O
looks	O
for	O
rows	O
that	O
have	O
the	O
specified	O
indices	O
.	O

So	O
if	O
you	O
have	O
a	O
DataFrame	B-API
with	O
index	O
`	O
[	O
0	O
,	O
1	O
,	O
2	O
]`	O
,	O
then	O
doing	O
a	O
`	O
reindex	B-API
([	O
2	O
,	O
1	O
,	O
0	O
])`	O
will	O
return	O
the	O
rows	O
in	O
reverse	O
order	O
.	O

Doing	O
something	O
like	O
`	O
reindex	B-API
([8	O
,	O
9	O
,	O
10	O
])`	O
does	O
not	O
make	O
a	O
new	O
index	O
for	O
the	O
rows	O
;	O
rather	O
,	O
it	O
will	O
return	O
a	O
DataFrame	B-API
with	O
`	O
NaN	O
`	O
values	O
,	O
since	O
there	O
are	O
no	O
rows	O
with	O
indices	O
8	O
,	O
9	O
,	O
or	O
10	O
.	O

To	O
do	O
that	O
i	O
could	O
loop	O
through	O
the	O
file	O
using	O
beautiful	O
soup	O
and	O
insert	B-API
the	O
values	O
row	O
by	O
row	O
or	O
create	O
lists	O
to	O
be	O
inserted	O
as	O
columns	O
.	O

Pandas	O
DataFrame	B-API
aggregate	B-API
function	O
using	O
multiple	O
columns	O

It	O
may	O
be	O
more	O
efficient	O
to	O
break	O
this	O
up	O
into	O
a	O
few	O
operations	O
as	O
follows	O
:	O
(	O
1	O
)	O
create	O
a	O
column	O
of	O
weights	O
,	O
(	O
2	O
)	O
normalize	B-API
the	O
observations	O
by	O
their	O
weights	O
,	O
(	O
3	O
)	O
compute	O
grouped	O
sum	O
of	O
weighted	O
observations	O
and	O
a	O
grouped	O
sum	O
of	O
weights	O
,	O
(	O
4	O
)	O
normalize	B-API
weighted	O
sum	O
of	O
observations	O
by	O
the	O
sum	O
of	O
weights	O
.	O

I	O
am	O
not	O
seeing	O
`	O
concat	B-API
`	O
as	O
a	O
function	O
in	O
the	O
pandas	O
namespace	O
;	O
I'm	O
not	O
sure	O
what	O
I	O
am	O
missing	O
.	O

I	O
was	O
running	O
pandas	O
ver	O
0.6.1	O
which	O
doesn't	O
have	O
the	O
concat	B-API
function	O
included	O
.	O

An	O
upgrade	O
to	O
v	O
0.7.3	O
brings	O
concat	B-API
into	O
the	O
namespace	O
.	O

How	O
to	O
shift	B-API
a	O
column	O
in	O
Pandas	O
DataFrame	B-API

I	O
would	O
like	O
to	O
shift	B-API
a	O
column	O
in	O
a	O
Pandas	O
DataFrame	B-API
,	O
but	O
I	O
havent	O
been	O
able	O
to	O
find	O
a	O
method	O
to	O
do	O
it	O
from	O
the	O
documentation	O
without	O
rewriting	O
the	O
whole	O
DF	O
.	O

How	O
to	O
aggregate	B-API
duplicate	O
timestamps	O
with	O
pandas	O
?	O

@USER	O
-	O
you	O
have	O
to	O
aggregate	B-API
them	O
somehow	O
.	O

You	O
want	O
to	O
use	O
the	O
apply	B-API
function	O
and	O
a	O
lambda	O
:	O
#CODE	O

You'll	O
first	O
need	O
to	O
split	O
the	O
data	O
by	O
timestamp	O
,	O
then	O
from	O
there	O
if	O
you	O
were	O
to	O
treat	O
it	O
as	O
an	O
array	O
shift	B-API
an	O
element	O
from	O
the	O
array	O
to	O
use	O
as	O
comparison	O
if	O
the	O
quote	O
type	O
is	O
equal	O
then	O
continue	O
and	O
shift	B-API
a	O
new	O
element	O
repeat	O
until	O
!	O

i	O
did	O
groupby	B-API
first	O
but	O
an	O
array	O
shift	B-API
to	O
compare	O
is	O
going	O
to	O
be	O
extremely	O
slow	O
.	O

You	O
can	O
possibly	O
duplicate	O
the	O
`	O
quote	O
`	O
column	O
twice	O
shifting	O
it	O
by	O
one	O
each	O
direction	O
and	O
apply	B-API
it	O
to	O
your	O
dataset	O
to	O
create	O
a	O
pivot	B-API
table	O
based	O
on	O
entries	O
where	O
`	O
quote	O
`	O
is	O
!	O

For	O
example	O
,	O
when	O
I	O
try	O
to	O
aggregate	B-API
(	O
using	O
'	O
mean	O
')	O
10min	O
values	O
to	O
monthly	O
values	O
,	O
the	O
function	O
seems	O
to	O
use	O
the	O
last	O
day	O
of	O
data	O
from	O
one	O
month	O
in	O
the	O
mean	O
of	O
the	O
next	O
month	O
...	O

Looking	O
at	O
the	O
documentation	O
,	O
it	O
may	O
be	O
that	O
using	O
the	O
`	O
MultiIndex	B-API
`	O
may	O
solve	O
my	O
problem	O
,	O
but	O
I'm	O
not	O
sure	O
how	O
to	O
apply	B-API
it	O
to	O
my	O
situation	O
-	O
the	O
documentation	O
shows	O
examples	O
of	O
creating	O
MultiIndexes	O
with	O
random	O
data	O
and	O
DataFrames	O
,	O
but	O
not	O
Series	O
with	O
pre-existing	O
timeseries	O
data	O
.	O

When	O
I	O
iterate	O
over	O
these	O
composite	O
objects	O
,	O
I	O
have	O
an	O
`	O
iterseries	O
`	O
routine	O
for	O
the	O
frame	O
and	O
`	O
iterframes	O
`	O
routine	O
for	O
the	O
panel	O
that	O
reconstruct	O
the	O
appropriate	O
metadata	O
/	O
data	O
pairing	O
as	O
I	O
drop	B-API
one	O
dimension	O
(	O
i.e.	O
the	O
series	O
from	O
the	O
frame	O
with	O
lead	O
time	O
varying	O
across	O
the	O
columns	O
will	O
have	O
all	O
the	O
metadata	O
of	O
its	O
parent	O
plus	O
the	O
`	O
Lead	O
Time	O
`	O
field	O
restored	O
with	O
the	O
value	O
taken	O
from	O
the	O
column	O
label	O
)	O
.	O

I've	O
tried	O
the	O
examples	O
given	O
in	O
the	O
documentation	O
,	O
but	O
I'm	O
still	O
a	O
little	O
unclear	O
how	O
to	O
apply	B-API
it	O
to	O
my	O
situation	O
.	O

Once	O
I	O
have	O
the	O
frame	O
given	O
by	O
this	O
routine	O
,	O
I	O
can	O
easily	O
apply	B-API
the	O
various	O
operations	O
suggested	O
below	O
-	O
of	O
particular	O
utility	O
is	O
being	O
able	O
to	O
use	O
the	O
`	O
names	B-API
`	O
field	O
when	O
I	O

call	O
`	O
concat	B-API
`	O
-	O
this	O
eliminates	O
the	O
need	O
to	O
store	O
the	O
name	O
of	O
the	O
column	O
key	O
internally	O

I	O
might	O
suggest	O
using	O
`	O
pandas.concat	B-API
`	O
along	O
with	O
its	O
`	O
keys	B-API
`	O
argument	O
to	O
glue	O
together	O
Series	O
DataFrames	O
to	O
create	O
a	O
MultiIndex	B-API
in	O
the	O
columns	O
:	O
#CODE	O

We	O
added	O
an	O
`	O
append	B-API
`	O
option	O
to	O
`	O
set_index	B-API
`	O
.	O

As	O
I	O
mentioned	O
above	O
,	O
if	O
you	O
know	O
beorehand	O
that	O
your	O
TSV	O
file	O
header	O
represents	O
a	O
`	O
MultiIndex	B-API
`	O
then	O
you	O
can	O
do	O
the	O
following	O
to	O
fix	O
this	O
:	O
#CODE	O

How	O
can	O
I	O
iterate	O
and	O
apply	B-API
a	O
function	O
over	O
a	O
single	O
level	O
of	O
a	O
DataFrame	B-API
with	O
MultiIndex	B-API
?	O

However	O
,	O
I	O
see	O
that	O
this	O
doesn't	O
drop	B-API
the	O
top	O
level	O
as	O
you're	O
looking	O
for	O
.	O

How	O
do	O
I	O
apply	B-API
it	O
to	O
a	O
pandas	O
DataFrame	B-API
?	O

`	O
df.resample	B-API
(	O
'	O
Min	O
')`	O
is	O
too	O
high	O
level	O
and	O
wants	O
to	O
aggregate	B-API
.	O

NumPy	O
by	O
itself	O
is	O
a	O
fairly	O
low-level	O
tool	O
,	O
and	O
will	O
be	O
very	O
much	O
similar	O
to	O
using	O
MATLAB	O
.	O
pandas	O
on	O
the	O
other	O
hand	O
provides	O
rich	O
time	O
series	O
functionality	O
,	O
data	O
alignment	O
,	O
NA-friendly	O
statistics	O
,	O
groupby	B-API
,	O
merge	B-API
and	O
join	B-API
methods	O
,	O
and	O
lots	O
of	O
other	O
conveniences	O
.	O

Data	O
alignment	O
,	O
join	B-API
,	O
etc	O
all	O
become	O
*	O
possible	O
*	O
due	O
to	O
this	O
,	O
but	O
for	O
people	O
who	O
don't	O
grok	O
that	O
underlying	O
difference	O
it's	O
not	O
even	O
clear	O
what	O
those	O
mean	O
(	O
e.g.	O
,	O
what	O
is	O
"	O
data	O
alignment	O
"	O
of	O
two	O
numpy	O
arrays	O
?	O
)	O
.	O

Other	O
thing	O
that	O
is	O
great	O
in	O
pandas	O
is	O
the	O
Panel	O
class	O
that	O
you	O
can	O
join	B-API
series	O
of	O
layers	O
with	O
different	O
properties	O
and	O
combine	O
it	O
using	O
groupby	B-API
function	O
.	O

This	O
isn't	O
quite	O
what's	O
suggested	O
in	O
the	O
documentation	O
for	O
pivot	B-API
--	O
there	O
,	O
it	O
shows	O
results	O
without	O
the	O
1	O
and	O
0	O
in	O
the	O
upper-left-hand	O
corner	O
.	O

Is	O
there	O
a	O
way	O
to	O
get	O
pivot	B-API
to	O
give	O
me	O
a	O
DataFrame	B-API
object	O
without	O
that	O
additional	O
information	O
in	O
the	O
upper-left	O
corner	O
?	O

to	O
build	O
on	O
@USER	O
,	O
it	O
would	O
be	O
really	O
helpful	O
if	O
you	O
could	O
convert	O
the	O
pandas	O
output	O
to	O
either	O
a	O
list	O
of	O
lists	O
or	O
a	O
list	O
of	O
dicts	O
and	O
then	O
show	O
the	O
result	O
of	O
the	O
conversion	O
e.g.	O
with	O
`	O
map	B-API
(	O
list	O
,	O
B_p	O
)`	O
.	O

I'm	O
just	O
confused	O
because	O
in	O
the	O
documentation	O
(	O
help	O
(	O
B_p.to_csv	O
))	O
it	O
doesn't	O
show	O
anything	O
in	O
the	O
upper-left-hand	O
corner	O
when	O
you	O
pivot	B-API
a	O
table	O
.	O

For	O
making	O
more	O
general	O
the	O
answer	O
...	O
first	O
I	O
will	O
take	O
the	O
common	O
index	O
for	O
synchronizing	O
both	O
dataframes	O
,	O
then	O
I	O
will	O
join	B-API
each	O
of	O
them	O
to	O
my	O
pattern	O
(	O
dates	O
)	O
and	O
I	O
will	O
sum	O
the	O
columns	O
of	O
the	O
same	O
name	O
and	O
finally	O
join	B-API
both	O
dataframes	O
(	O
deleting	O
added	O
columns	O
in	O
one	O
of	O
them	O
)	O
,	O

The	O
solution	O
I	O
have	O
come	O
up	O
with	O
is	O
to	O
exclude	O
dates	O
for	O
which	O
valuation	O
(	O
actually	O
price	O
)	O
data	O
doesn't	O
exist	O
for	O
a	O
given	O
holding	O
and	O
then	O
aggregate	B-API
on	O
these	O
dates	O
where	O
I	O
have	O
complete	O
data	O
.	O

It	O
seems	O
like	O
some	O
combination	O
of	O
resample	B-API
and	O
/	O
or	O
fillna	B-API
is	O
going	O
to	O
get	O
you	O
what	O
you're	O
looking	O
for	O
(	O
realize	O
this	O
is	O
coming	O
a	O
little	O
late	O
!	O
)	O
.	O

We	O
now	O
need	O
to	O
drop	B-API
the	O
`	O
DataRange	O
`	O
type	O
of	O
your	O
`	O
Index	B-API
`	O
and	O
make	O
it	O
a	O
list	O
of	O
`	O
str	B-API
`	O
to	O
simulate	O
how	O
you	O
would	O
parse	O
in	O
your	O
data	O
:	O
#CODE	O

I	O
would	O
like	O
to	O
roll	O
through	O
my	O
data	O
by	O
date	O
and	O
on	O
each	O
date	O
take	O
a	O
time	O
slice	O
in	O
the	O
past	O
apply	B-API
a	O
function	O
to	O
every	O
time	O
series	O
so	O
I	O
get	O
a	O
result	O
such	O
as	O
this	O
where	O
X	O
is	O
the	O
output	O
of	O
the	O
function	O
of	O
timeslice	O
.	O

Also	O
is	O
there	O
some	O
other	O
way	O
to	O
do	O
the	O
following.Using	O
Apply	B-API
function	O
seems	O
to	O
be	O
very	O
slow	O
for	O
large	O
dataset	O
.	O

pandas	O
row	O
specific	O
apply	B-API

Similar	O
to	O
this	O
R	O
question	O
,	O
I'd	O
like	O
to	O
apply	B-API
a	O
function	O
to	O
each	O
item	O
in	O
a	O
Series	O
(	O
or	O
each	O
row	O
in	O
a	O
DataFrame	B-API
)	O
using	O
Pandas	O
,	O
but	O
want	O
to	O
use	O
as	O
an	O
argument	O
to	O
this	O
function	O
the	O
index	O
or	O
id	O
of	O
that	O
row	O
.	O

In	O
reality	O
,	O
I'm	O
not	O
worried	O
(	O
in	O
this	O
case	O
)	O
about	O
returning	O
anything	O
meaningful	O
,	O
but	O
more	O
for	O
the	O
efficiency	O
of	O
something	O
like	O
'	O
apply	B-API
'	O
.	O

If	O
you	O
use	O
the	O
apply	B-API
method	O
with	O
a	O
function	O
what	O
happens	O
is	O
that	O
every	O
item	O
in	O
the	O
Series	O
will	O
be	O
mapped	O
with	O
such	O
a	O
function	O
.	O

A	O
more	O
complex	O
usage	O
of	O
apply	B-API
would	O
be	O
this	O
one	O
:	O
#CODE	O

However	O
you	O
can	O
include	O
indices	O
in	O
your	O
function	O
by	O
creating	O
a	O
new	O
series	O
(	O
apply	B-API
wont	O
give	O
you	O
any	O
information	O
about	O
the	O
current	O
index	O
):	O
#CODE	O

When	O
you	O
read	O
in	O
your	O
files	O
,	O
you	O
can	O
use	O
`	O
concat	B-API
`	O
to	O
join	B-API
the	O
resulting	O
DataFrames	O
into	O
one	O
,	O
then	O
just	O
use	O
normal	O
pandas	O
averaging	O
techniques	O
to	O
average	O
them	O
.	O

The	O
problem	O
disappears	O
if	O
I	O
change	O
window_type	O
to	O
`	O
expanding	B-API
`	O
and	O
I	O
get	O
about	O
500	O
output	O
points	O
as	O
expected	O
,	O
but	O
I	O
don't	O
want	O
to	O
do	O
an	O
expanding	B-API
regression	O
.	O

issue	O
with	O
pandas	O
and	O
semilog	O
for	O
boxplot	B-API

For	O
some	O
reason	O
,	O
when	O
I	O
use	O
semilogy	O
and	O
boxplot	B-API
with	O
the	O
video	O
series	O
,	O
I	O
get	O
the	O
error	O
#CODE	O

but	O
when	O
I	O
do	O
it	O
on	O
the	O
'	O
link	O
'	O
series	O
I	O
can	O
draw	O
the	O
boxplot	B-API
correctly	O
.	O

and	O
I	O
am	O
able	O
to	O
draw	O
the	O
boxplot	B-API
.	O

You	O
could	O
create	O
a	O
semi-log	O
boxplot	B-API
,	O
for	O
example	O
,	O
by	O
:	O
#CODE	O

Or	O
,	O
more	O
generally	O
,	O
modify	O
/	O
transform	B-API
to	O
you	O
heart's	O
content	O
,	O
and	O
then	O
boxplot	B-API
.	O

Pandas	O
pivot	B-API
warning	O
about	O
repeated	O
entries	O
on	O
index	O

On	O
Pandas	O
documentation	O
of	O
the	O
`	O
pivot	B-API
`	O
method	O
,	O
we	O
have	O
:	O
#CODE	O

But	O
when	O
I	O
run	O
the	O
`	O
pivot	B-API
`	O
method	O
,	O
it	O
is	O
saying	O
:	O
#CODE	O

I'm	O
using	O
the	O
`	O
name	B-API
`	O
column	O
as	O
the	O
index	O
of	O
the	O
pivot	B-API
,	O
the	O
first	O
argument	O
of	O
the	O
`	O
pivot	B-API
`	O
method	O
call	O
.	O

Can	O
you	O
post	O
the	O
exact	O
pivot	B-API
method	O
call	O
you're	O
using	O
?	O

If	O
you	O
have	O
duplicates	O
you	O
may	O
need	O
to	O
aggregate	B-API
first	O
.	O

It	O
would	O
be	O
nice	O
to	O
add	O
an	O
option	O
to	O
pivot	B-API
to	O
take	O
either	O
the	O
first	O
or	O
last	O
observed	O
entry	O
:	O
#URL	O

I	O
fixed	O
the	O
parser	O
bug	O
shown	O
in	O
the	O
stack	B-API
trace	O
that	O
you	O
pasted	O
.	O

Find	O
all	O
elements	O
in	O
dataframe	B-API
column	O
that	O
startswith	B-API
string	O

I	O
am	O
currently	O
rolling	B-API
up	O
numbers	O
with	O
the	O
following	O
code	O
.	O

Try	O
saving	O
that	O
to	O
a	O
temporary	O
variable	O
and	O
using	O
the	O
temp	O
variable	O
inside	O
`	O
startswith	B-API
`	O
.	O

`	O
df	O
=	O
df.index.drop	O
(	O
'	O
L	O
')`	O
removes	O
L	O
completely	O
from	O
the	O
DataFrame	B-API
(	O
unlike	O
`	O
df=	O
df.reset_index()	B-API
`	O
which	O
has	O
a	O
drop	B-API
argument	O
)	O
.	O

The	O
bit	O
about	O
the	O
copy	O
was	O
only	O
for	O
use	O
of	O
`	O
ix	B-API
[	O
]`	O
if	O
you	O
*	O
prefer	O
*	O
to	O
use	O
`	O
ix	B-API
[	O
]`	O
for	O
any	O
reason	O
.	O

`	O
ix	B-API
`	O
indexes	O
rows	O
,	O
not	O
columns	O
.	O

`	O
ix	B-API
`	O
accepts	O
slice	O
arguments	O
,	O
so	O
you	O
can	O
also	O
get	O
columns	O
.	O

It	O
is	O
incorrect	O
to	O
say	O
that	O
`	O
ix	B-API
`	O
indexes	O
rows	O
.	O

So	O
,	O
`	O
ix	B-API
`	O
is	O
perfectly	O
general	O
for	O
this	O
question	O
.	O

Never	O
knew	O
about	O
that	O
feature	O
of	O
`	O
ix	B-API
`	O
.	O

That	O
said	O
,	O
you	O
can	O
easily	O
convert	O
a	O
column-slicing	O
problem	O
into	O
a	O
row-slicing	O
problem	O
by	O
just	O
applying	O
a	O
transpose	B-API
operation	O
,	O
`	O
df.T	B-API
`	O
.	O

The	O
`	O
drop	B-API
`	O
method	O
is	O
documented	O
here	O
.	O

You're	O
correct	O
that	O
this	O
would	O
be	O
wrong	O
for	O
most	O
types	O
;	O
however	O
`	O
pandas.DataFrame	B-API
`	O
has	O
special	O
support	O
for	O
setting	O
values	O
using	O
a	O
Boolean	O
mask	B-API
;	O
it	O
will	O
select	O
the	O
corresponding	O
values	O
from	O
the	O
RHS	O
with	O
the	O
corresponding	O
time	O
value	O
.	O

My	O
worry	O
is	O
that	O
in	O
the	O
original	O
code	O
,	O
the	O
first	O
N	O
values	O
of	O
cap_level	O
will	O
be	O
taken	O
and	O
used	O
,	O
where	O
N	O
is	O
the	O
number	O
of	O
True	O
values	O
in	O
the	O
Boolean	O
mask	B-API
.	O

I	O
have	O
several	O
Series	O
indexed	O
by	O
dates	O
that	O
I	O
would	O
like	O
to	O
concat	B-API
into	O
a	O
single	O
DataFrame	B-API
,	O
but	O
the	O
Series	O
are	O
of	O
different	O
lengths	O
because	O
of	O
missing	O
dates	O
etc	O
.	O

grouped	O
pandas	O
DataFrames	O
:	O
how	O
do	O
I	O
apply	B-API
scipy.stats.sem	O
to	O
them	O
?	O

I	O
know	O
that	O
I	O
can	O
apply	B-API
numpy	O
methods	O
by	O
doing	O
the	O
following	O
:	O

However	O
,	O
what	O
if	O
I	O
want	O
to	O
compute	O
the	O
standard	O
error	O
of	O
the	O
mean	O
(	O
sem	B-API
)	O
?	O

Oddly	O
,	O
the	O
results	O
of	O
the	O
method	O
I	O
used	O
before	O
to	O
compute	O
sem	B-API
,	O
`	O
std	O
/	O
sqrt	O
(	O
#	O
replicates	O
)`	O
,	O
varies	O
_slightly_	O
from	O
`	O
sem()	B-API
`	O
results	O
,	O
but	O
we're	O
only	O
talking	O
~	O
4e-11	O
difference	O
max	O
.	O

I'm	O
not	O
sure	O
why	O
Pandas	O
thinks	O
this	O
is	O
a	O
"	O
bool	B-API
"	O
type	O
column	O
.	O

Doesn't	O
the	O
true	O
/	O
false	O
part	O
of	O
QRY	O
explain	O
the	O
bool	B-API
nature	O
of	O
i	O
for	O
your	O
example	O
?	O

I	O
have	O
a	O
data	O
table	O
using	O
pandas	O
and	O
column	O
labels	O
that	O
I	O
need	O
to	O
edit	O
to	O
replace	B-API
the	O
original	O
column	O
labels	O
.	O

I	O
have	O
the	O
edited	O
column	O
names	O
stored	O
it	O
in	O
a	O
list	O
,	O
but	O
I	O
don't	O
know	O
how	O
to	O
replace	B-API
the	O
column	O
names	O
.	O

This	O
will	O
put	O
them	O
into	O
dictionary	O
form	O
,	O
including	O
the	O
earlier	O
defined	O
class	O
and	O
subject	O
variables	O
,	O
and	O
append	B-API
them	O
to	O
an	O
outputList	O
.	O

The	O
trick	O
here	O
is	O
to	O
use	O
the	O
`	O
axis=1	O
`	O
option	O
in	O
the	O
`	O
apply	B-API
`	O
to	O
pass	O
elements	O
to	O
the	O
lambda	O
function	O
row	O
by	O
row	O
,	O
as	O
opposed	O
to	O
column	O
by	O
column	O
.	O

once	O
sorted	O
I	O
replace	B-API
the	O
df.index	O
with	O
a	O
numerical	O
index	O
#CODE	O

Is	O
it	O
possible	O
to	O
customize	O
Serie	O
(	O
in	O
a	O
simple	O
way	O
,	O
and	O
DataFrame	B-API
by	O
the	O
way	O
:p	O
)	O
from	O
pandas	O
to	O
append	B-API
extras	O
informations	O
on	O
the	O
display	O
and	O
in	O
the	O
plots	O
?	O

A	O
great	O
thing	O
will	O
be	O
to	O
have	O
the	O
possibility	O
to	O
append	B-API
informations	O
like	O
"	O
unit	O
"	O
,	O
"	O
origin	O
"	O
or	O
anything	O
relevant	O
for	O
the	O
user	O
that	O
will	O
not	O
be	O
lost	O
during	O
computations	O
,	O
like	O
the	O
"	O
name	O
"	O
parameter	O
.	O

We'd	O
welcome	O
any	O
additional	O
feedback	O
you	O
have	O
(	O
see	O
pandas	O
on	O
github	O
)	O
and	O
would	O
love	O
to	O
accept	O
a	O
pull-request	O
if	O
you're	O
interested	O
in	O
rolling	B-API
your	O
own	O
.	O

Why	O
map	B-API
instead	O
of	O
apply	B-API
?	O

Using	O
the	O
dt	B-API
option	O
playing	O
around	O
with	O
weekofyear	B-API
,	O
dayofweek	B-API
etc	O
.	O
becomes	O
a	O
easier	O

Is	O
there	O
a	O
way	O
to	O
"	O
merge	B-API
"	O
multiple	O
DataFrames	O
,	O
but	O
what	O
is	O
done	O
at	O
dates	O
that	O
occur	O
only	O
in	O
one	O
of	O
the	O
underlying	O
DataFrames	O
?	O

making	O
things	O
continuous	O
:	O
you	O
should	O
just	O
be	O
able	O
to	O
use	O
resample	B-API
directly	O

Basically	O
,	O
I'm	O
trying	O
to	O
pivot	B-API
on	O
location	O
to	O
end	O
up	O
with	O
a	O
dataframe	B-API
like	O
:	O
#CODE	O

Unfortunately	O
when	O
I	O
pivot	B-API
,	O
the	O
index	O
,	O
which	O
is	O
equivalent	O
to	O
the	O
original	O
dates	O
column	O
,	O
does	O
not	O
change	O
and	O
I	O
get	O
:	O
#CODE	O

because	O
I	O
have	O
a	O
#	O
of	O
data	O
columns	O
I	O
want	O
to	O
pivot	B-API
(	O
don't	O
want	O
to	O
list	O
each	O
one	O
as	O
an	O
argument	O
)	O
.	O

I	O
believe	O
by	O
default	O
pivot	B-API
pivots	O
the	O
rest	O
of	O
the	O
columns	O
in	O
the	O
dataframe	B-API
.	O

I'm	O
actually	O
calling	O
df.pivot	B-API
without	O
the	O
third	O
argument	O
as	O
in	O
my	O
actual	O
data	O
,	O
i	O
have	O
a	O
#	O
of	O
data	O
columns	O
and	O
I	O
want	O
to	O
pivot	B-API
all	O
of	O
them	O
.	O

If	O
you	O
have	O
multiple	O
data	O
columns	O
,	O
calling	O
pivot	B-API
without	O
the	O
values	O
columns	O
should	O
give	O
you	O
a	O
pivoted	O
frame	O
with	O
a	O
MultiIndex	B-API
as	O
the	O
columns	O
:	O
#CODE	O

Yeah	O
I'm	O
seeing	O
the	O
information	O
come	O
out	O
as	O
a	O
multiindex	B-API
,	O
but	O
again	O
,	O
I	O
get	O
the	O
same	O
issue	O
where	O
pandas	O
seems	O
to	O
recognize	O
all	O
the	O
dates	O
as	O
unique	O
and	O
I	O
get	O
a	O
bunch	O
of	O
Nans	O
.	O

Even	O
if	O
I	O
set	O
the	O
pivot	B-API
argument	O
values	O
to	O
say	O
column	O
C	O
,	O
I	O
still	O
get	O
the	O
same	O
#	O
of	O
rows	O
as	O
in	O
my	O
original	O
table	O
,	O
just	O
with	O
Nans	O
for	O
all	O
the	O
repeated	O
dates	O
.	O

Hence	O
the	O
dataframe	B-API
pivot	B-API
treated	O
each	O
column	O
value	O
as	O
unique	O
in	O
the	O
index	O
.	O

I'm	O
trying	O
to	O
drop	B-API
the	O
last	O
row	O
in	O
a	O
dataframe	B-API
created	O
by	O
pandas	O
in	O
python	O
and	O
seem	O
to	O
be	O
having	O
trouble	O
.	O

I	O
tried	O
the	O
drop	B-API
method	O
like	O
this	O
:	O
#CODE	O

I	O
also	O
tried	O
to	O
drop	B-API
by	O
index	O
name	O
and	O
it	O
still	O
doesn't	O
seem	O
to	O
be	O
working	O
.	O

I	O
can	O
use	O
sin	O
and	O
DataFrame.prod	B-API
to	O
create	O
a	O
boolean	O
mask	B-API
:	O
#CODE	O

Then	O
use	O
the	O
mask	B-API
to	O
select	O
from	O
the	O
DataFrame	B-API
:	O
#CODE	O

better	O
method	O
to	O
aggregate	B-API
pandas	O
dataframe	B-API
by	O
non	O
matching	O
criteria	O

I	O
have	O
a	O
dataframe	B-API
of	O
species	O
survey	O
counts	O
and	O
need	O
to	O
aggregate	B-API
the	O
rows	O
by	O
multiple	O
criteria	O
.	O

Is	O
there	O
a	O
vectorised	O
way	O
to	O
aggregate	B-API
data	O
in	O
this	O
way	O
?	O

What's	O
the	O
right	O
way	O
for	O
me	O
to	O
aggregate	B-API
these	O
stock	O
prices	O
into	O
Monthly	O
?	O

The	O
error	O
message	O
is	O
"	O
GroupByError	O
(	O
'	O
No	O
numeric	O
types	O
to	O
aggregate	B-API
')"	O
.	O

EDIT	O
:	O
I	O
just	O
realized	O
that	O
most	O
of	O
the	O
other	O
functions	O
(	O
min	O
,	O
max	O
,	O
median	B-API
,	O
etc	O
.	O
)	O
work	O
fine	O
but	O
not	O
the	O
mean	O
function	O
that	O
i	O
desperately	O
need	O
:-(	O
.	O

Also	O
,	O
you	O
don't	O
really	O
need	O
the	O
lambda	O
here	O
,	O
just	O
feeding	O
`	O
np.mean	O
`	O
would	O
work	O
too	O
,	O
but	O
I	O
left	O
the	O
lambda	O
in	O
to	O
illustrate	O
how	O
you	O
would	O
solve	O
this	O
when	O
more	O
general	O
functions	O
that	O
you	O
want	O
to	O
apply	B-API
aren't	O
working	O
in	O
their	O
default	O
ways	O
.	O

You	O
can	O
replace	B-API
the	O
`	O
[	O
0:4	O
]`	O
with	O
`	O
[	O
df.index.values	O
[	O
i	O
]:	O
df.index.values	O
[	O
j	O
]]`	O
or	O
`	O
[	O
df.index.values	O
[	O
i	O
]	O
for	O
i	O
in	O
range	O
(	O
N	O
)]`	O
or	O
even	O
with	O
logical	O
values	O
such	O
as	O
`	O
[	O
df	O
[	O
'	O
a	O
']	O
5	O
]`	O
to	O
only	O
get	O
rows	O
where	O
the	O
'	O
a	O
'	O
column	O
exceeds	O
5	O
,	O
for	O
example	O
.	O

I	O
am	O
trying	O
to	O
use	O
the	O
agg	B-API
fn	O
but	O
without	O
doing	O
a	O
groupby	B-API
.	O

I	O
think	O
it	O
uses	O
`	O
patsy	O
`	O
in	O
the	O
backend	O
to	O
translate	B-API
the	O
formula	O
expression	O
,	O
and	O
intercept	O
is	O
added	O
automatically	O
.	O

dalejung	O
on	O
GitHub	O
has	O
done	O
quite	O
a	O
bit	O
of	O
work	O
recently	O
in	O
creating	O
a	O
tighter	O
pandas-xts	O
interface	O
with	O
rpy2	O
,	O
you	O
might	O
get	O
in	O
touch	O
with	O
him	O
or	O
join	B-API
the	O
PyData	O
mailing	O
list	O

Length	O
:	O
3	O
,	O
Freq	B-API
:	O
3H	O
,	O
Timezone	O
:	O
None	O

Length	O
:	O
3	O
,	O
Freq	B-API
:	O
H	O
,	O
Timezone	O
:	O
None	O

We	O
run	O
into	O
issues	O
that	O
join	B-API
columns	O
are	O
converted	O
into	O
either	O
ints	O
or	O
floats	O
,	O
based	O
on	O
the	O
existence	O
of	O
a	O
NA	O
value	O
in	O
the	O
original	O
list	O
.	O

(	O
Creating	O
issues	O
later	O
on	O
when	O
trying	O
to	O
merge	B-API
these	O
dataframes	O
)	O

I	O
haven't	O
done	O
time	O
benchmarking	O
,	O
but	O
I	O
am	O
skeptical	O
of	O
the	O
following	O
immediately	O
obvious	O
way	O
that	O
comes	O
to	O
mind	O
(	O
and	O
variants	O
that	O
might	O
use	O
`	O
map	B-API
`	O
or	O
`	O
filter	O
`)	O
.	O

First	O
is	O
for	O
`	O
vtype	O
`	O
above	O
,	O
then	O
for	O
the	O
`	O
apply	B-API
`	O
route	O
.	O

Can	O
you	O
post	O
a	O
stack	B-API
trace	O
and	O
/	O
or	O
what	O
merged2	O
looks	O
like	O
?	O

Collapse	O
a	O
Pandas	O
multiindex	B-API
or	O
run	O
OLS	O
regression	O
on	O
a	O
multiindexed	O
dataframe	B-API

I	O
used	O
pivot	B-API
to	O
reshape	O
my	O
data	O
and	O
now	O
have	O
a	O
column	O
multiindex	B-API
.	O

Collapse	O
the	O
multiindex	B-API
.	O

Is	O
there	O
some	O
way	O
to	O
run	O
a	O
regression	O
with	O
a	O
multiindex	B-API
?	O

I	O
can	O
create	O
a	O
new	O
dataframe	B-API
,	O
loop	O
over	O
both	O
column	O
indexes	O
,	O
and	O
insert	B-API
new	O
columns	O
into	O
the	O
new	O
dataframe	B-API
with	O
the	O
same	O
name	O
,	O
but	O
with	O
names	O
as	O
strings	O
instead	O
of	O
tuples	O
.	O

I.e.	O
how	O
easy	O
is	O
it	O
for	O
me	O
to	O
cvs	O
checkout	O
the	O
code	O
,	O
test	O
my	O
changes	O
in	O
iPython	O
rather	O
than	O
with	O
the	O
prod	B-API
version	O
then	O
creating	O
a	O
pull	O
request	O
?	O

So	O
in	O
this	O
case	O
I	O
would	O
replace	B-API
that	O
missing	O
value	O
with	O
the	O
average	O
rating	O
given	O
to	O
that	O
artist	O
(	O
a	O
bad	O
first	O
approximation	O
,	O
better	O
to	O
use	O
the	O
SVD	O
)	O

It	O
depends	O
on	O
the	O
size	O
of	O
your	O
DataFrame	B-API
,	O
but	O
potentially	O
you	O
could	O
repeat	O
the	O
mean	O
rating	O
so	O
it's	O
the	O
same	O
size	O
as	O
the	O
ratings	O
matrix	O
and	O
then	O
use	O
the	O
NA	O
mask	B-API
to	O
replace	B-API
the	O
missing	O
values	O
?	O

I	O
built	O
the	O
features	O
by	O
using	O
the	O
pandas	O
group	O
operations	O
,	O
then	O
applied	O
the	O
mean()	O
on	O
the	O
group	O
,	O
and	O
finally	O
did	O
a	O
merge	B-API
back	O
onto	O
the	O
main	O
dataframe	B-API
.	O

This	O
supersedes	O
the	O
`	O
irow	B-API
`	O
approach	O
.	O

If	O
you	O
want	O
to	O
remove	O
the	O
old	O
10-based	O
indices	O
,	O
you	O
can	O
insert	B-API
the	O
flag	O
`	O
drop=True	O
`	O
into	O
the	O
parenthesis	O
of	O
the	O
reset_index	B-API
function	O
.	O

I	O
think	O
it	O
is	O
`	O
df	O
[	O
'	O
A	O
']	O
.iget	B-API
(	O
0	O
)`	O
because	O
`	O
df	O
[	O
'	O
A	O
']`	O
is	O
a	O
`	O
Series	B-API
`	O
,	O
which	O
has	O
no	O
`	O
irow	B-API
`	O
.	O

Say	O
I	O
can	O
read	O
the	O
file	O
and	O
concat	B-API
all	O
of	O
them	O
together	O
into	O
one	O
DataFrame	B-API
.	O

what	O
if	O
the	O
values	O
are	O
strings	O
or	O
categorical	B-API
-	O
i	O
am	O
getting	O
the	O
error	O
:	O
incompatible	O
categories	O
in	O
categorical	B-API
concat	B-API

Pandas	O
join	B-API
/	O
merge	B-API
/	O
concat	B-API
two	O
dataframes	O

should	O
I	O
be	O
able	O
to	O
join	B-API
it	O
with	O
y	O
on	O
index	O
with	O
a	O
simple	O
join	B-API
command	O
where	O
y	O
=	O
x	O
except	O
colnames	O
have	O
+2	O
.	O

I	O
tried	O
merge	B-API
as	O
well	O
but	O
I	O
have	O
the	O
same	O
issue	O
.	O

If	O
you	O
are	O
having	O
issues	O
with	O
join	B-API
,	O
read	O
Wes's	O
answer	O
below	O
.	O

`	O
merge	B-API
`	O
and	O
`	O
join	B-API
`	O
do	O
,	O
well	O
,	O
joins	O
,	O
which	O
means	O
they	O
will	O
give	O
you	O
something	O
based	O
around	O
the	O
Cartesian	O
product	O
of	O
the	O
two	O
inputs	O
,	O
but	O
it	O
sounds	O
like	O
you	O
just	O
want	O
to	O
paste	O
them	O
together	O
into	O
one	O
big	O
table	O
.	O

Edit	O
:	O
did	O
you	O
try	O
concat	B-API
with	O
`	O
axis=1	O
`	O
?	O

here	O
is	O
what	O
concat	B-API
looks	O
like	O
:	O

Perhaps	O
`	O
concat	B-API
([	O
x	O
,	O
y	O
]	O
,	O
axis=1	O
)`	O
?	O

Pandas	O
:	O
pivot	B-API
a	O
dataframe	B-API

The	O
sensor	O
timeseries	O
data	O
is	O
then	O
also	O
rounded	O
to	O
the	O
nearest	O
minute	O
and	O
I	O
use	O
numpy.in1d	O
and	O
take	O
the	O
timestamps	O
from	O
the	O
above	O
'	O
minutes_array	O
'	O
and	O
the	O
'	O
sensor_data	O
'	O
array	O
and	O
create	O
a	O
mask	B-API
for	O
the	O
records	O
relating	O
to	O
that	O
sensor	O
.	O

I	O
then	O
wish	O
to	O
modify	O
the	O
records	O
in	O
minutes_array	O
which	O
are	O
true	O
for	O
that	O
mask	B-API
and	O
place	O
the	O
sensor_data	O
value	O
into	O
the	O
first	O
column	O
following	O
the	O
timestamp	O
in	O
minutes_array	O
.	O

From	O
my	O
attempts	O
it	O
does	O
not	O
seem	O
possible	O
to	O
alter	O
the	O
original	O
'	O
minutes_array	O
'	O
when	O
a	O
mask	B-API
is	O
applied	O
to	O
it	O
,	O
is	O
there	O
a	O
way	O
to	O
achieve	O
this	O
outcome	O
in	O
numpy	O
without	O
using	O
for	O
loops	O
and	O
matching	O
timestamps	O
individually	O
?	O

concat	B-API
pandas	O
DataFrame	B-API
along	O
timeseries	O
indexes	O

I	O
have	O
two	O
largish	O
(	O
snippets	O
provided	O
)	O
pandas	O
DateFrames	O
with	O
unequal	O
dates	O
as	O
indexes	O
that	O
I	O
wish	O
to	O
concat	B-API
into	O
one	O
:	O
#CODE	O

Not	O
sure	O
what	O
your	O
`	O
concat	B-API
`	O
line	O
will	O
do	O

Try	O
to	O
join	B-API
on	O
outer	O
.	O

I	O
often	O
need	O
to	O
apply	B-API
a	O
function	O
to	O
the	O
groups	O
of	O
a	O
very	O
large	O
`	O
DataFrame	B-API
`	O
(	O
of	O
mixed	O
data	O
types	O
)	O
and	O
would	O
like	O
to	O
take	O
advantage	O
of	O
multiple	O
cores	O
.	O

I	O
do	O
something	O
like	O
that	O
but	O
using	O
UWSGI	O
,	O
Flask	O
and	O
preforking	O
:	O
I	O
load	O
the	O
pandas	O
dataframe	B-API
into	O
a	O
process	O
,	O
fork	O
it	O
x	O
times	O
(	O
making	O
it	O
a	O
shared	O
memory	O
object	O
)	O
and	O
then	O
call	O
those	O
processes	O
from	O
another	O
python	O
process	O
where	O
I	O
concat	B-API
the	O
results	O
.	O
atm	O
I	O
use	O
JSON	O
as	O
a	O
communication	O
process	O
,	O
but	O
this	O
is	O
coming	O
(	O
yet	O
highly	O
experimental	O
still	O
):	O
#URL	O

pandas	O
concat	B-API
(	O
'	O
outer	O
')	O
not	O
doing	O
union	O
?	O

It	O
looks	O
pandas.concat	B-API
is	O
doing	O
'	O
left	O
outer	O
'	O
join	B-API
instead	O
of	O
just	O
union	O
the	O
indexes	O
.	O

How	O
to	O
resample	B-API
a	O
python	O
pandas	O
TimeSeries	O
containing	O
dytpe	O
Decimal	O
values	O
?	O

I'd	O
like	O
to	O
use	O
the	O
new	O
pandas	O
0.8	O
function	O
to	O
resample	B-API
the	O
decimal	O
time	O
series	O
like	O
this	O
:	O
#CODE	O

When	O
trying	O
this	O
i	O
get	O
an	O
"	O
GroupByError	O
:	O
No	O
numeric	O
types	O
to	O
aggregate	B-API
"	O
error	O
.	O

I	O
assume	O
the	O
problem	O
is	O
that	O
np.mean	O
is	O
used	O
internaly	O
to	O
resample	B-API
the	O
values	O
and	O
np.mean	O
expects	O
floats	O
instead	O
of	O
Decimals	O
.	O

Thanks	O
to	O
the	O
help	O
of	O
this	O
forum	O
i	O
managed	O
to	O
solve	O
a	O
similar	O
question	O
using	O
groupBy	B-API
and	O
the	O
apply	B-API
function	O
but	O
i	O
would	O
love	O
to	O
also	O
use	O
the	O
cool	O
resample	B-API
function	O
.	O

It	O
is	O
possible	O
to	O
provide	O
a	O
function	O
to	O
the	O
'	O
how	O
'	O
argument	O
of	O
resample	B-API
:	O
#CODE	O

Currently	O
i'm	O
using	O
string	O
replace	B-API
which	O
i	O
consider	O
to	O
be	O
a	O
significant	O
perfomance	O
penalty	O
.	O

Unexpected	O
result	O
when	O
upsampling	O
hourly	O
values	O
using	O
the	O
pandas	O
resample	B-API
function	O

I	O
try	O
to	O
upsample	O
daily	O
TimeSeries	O
values	O
using	O
the	O
pandas	O
resample	B-API
function	O
.	O

If	O
it	O
is	O
a	O
feature	O
how	O
can	O
i	O
set	O
the	O
resample	B-API
arguments	O
to	O
achieve	O
my	O
goal	O
?	O

Given	O
the	O
"	O
circular	O
"	O
dependency	O
(	O
not	O
really	O
circular	O
given	O
the	O
lags	O
)	O
,	O
I'm	O
not	O
sure	O
how	O
I	O
could	O
do	O
either	O
regular	O
series	O
math	O
or	O
use	O
normal	O
shift	B-API
operations	O
(	O
e.g	O
as	O
I	O
do	O
with	O
`	O
Cash	O
Return	O
`)	O
.	O

A	O
combination	O
of	O
boolean	O
indexing	O
and	O
apply	B-API
can	O
do	O
the	O
trick	O
.	O

However	O
,	O
I	O
think	O
that	O
you	O
can	O
get	O
away	O
with	O
`	O
.max	B-API
(	O
axis=1	O
)`	O
instead	O
of	O
`	O
apply	B-API
(	O
...	O
)`	O
.	O

`	O
max()	O
`	O
is	O
ok	O
too	O
of	O
course	O
,	O
i	O
think	O
i	O
got	O
biased	O
towards	O
`	O
apply	B-API
`	O
by	O
the	O
way	O
you	O
asked	O
the	O
question	O
:-)	O

Simplest	O
way	O
is	O
probably	O
`	O
list	O
(	O
dt.T.itertuples()	O
)`	O
(	O
where	O
`	O
dt	B-API
`	O
is	O
your	O
dataframe	B-API
)	O
.	O

The	O
problem	O
in	O
your	O
code	O
is	O
that	O
you	O
want	O
to	O
apply	B-API
the	O
operation	O
on	O
every	O
row	O
.	O

Most	O
operations	O
in	O
`	O
pandas	O
`	O
can	O
be	O
accomplished	O
with	O
operator	O
chaining	O
(	O
`	O
groupby	B-API
`	O
,	O
`	O
aggregate	B-API
`	O
,	O
`	O
apply	B-API
`	O
,	O
etc	O
)	O
,	O
but	O
the	O
only	O
way	O
I've	O
found	O
to	O
filter	O
rows	O
is	O
via	O
normal	O
bracket	O
indexing	O
#CODE	O

If	O
you	O
want	O
to	O
chain	O
methods	O
,	O
you	O
can	O
add	O
your	O
own	O
mask	B-API
method	O
and	O
use	O
that	O
one	O
.	O

I	O
would	O
extend	O
it	O
by	O
generalizing	O
the	O
mask	B-API
function	O
as	O
:	O
#CODE	O

If	O
you	O
would	O
like	O
to	O
apply	B-API
all	O
of	O
the	O
common	O
boolean	O
masks	O
as	O
well	O
as	O
a	O
general	O
purpose	O
mask	B-API
you	O
can	O
chuck	O
the	O
following	O
in	O
a	O
file	O
and	O
then	O
simply	O
assign	O
them	O
all	O
as	O
follows	O
:	O
#CODE	O

But	O
I	O
found	O
that	O
,	O
if	O
you	O
wrap	O
each	O
condition	O
in	O
`	O
(	O
...	O
==	O
True	O
)`	O
and	O
join	B-API
the	O
criteria	O
with	O
a	O
pipe	O
,	O
the	O
criteria	O
are	O
combined	O
in	O
an	O
OR	O
condition	O
,	O
satisfied	O
whenever	O
either	O
of	O
them	O
is	O
true	O
:	O
#CODE	O

pandas	O
:	O
stacking	O
DataFrames	O
generated	O
by	O
apply	B-API

1	O
)	O
"	O
join	B-API
"	O
the	O
results	O
back	O
to	O
the	O
initial	O
DataFrame	B-API

1	O
)	O
join	B-API
this	O
back	O
to	O
the	O
original	O
DataFrame	B-API
`	O
df	O
`	O

transform	B-API
(	O
#URL	O
)	O
and	O
agg	B-API
(	O
#URL	O
)	O
can	O
be	O
used	O
.	O

Just	O
use	O
the	O
aggregate	B-API
method	O
of	O
the	O
groupby	B-API
object	O
:	O
#CODE	O

If	O
you	O
want	O
different	O
operations	O
on	O
each	O
column	O
,	O
according	O
to	O
the	O
docs	O
you	O
can	O
pass	O
a	O
`	O
dict	O
`	O
to	O
`	O
aggregate	B-API
`	O
.	O

and	O
than	O
apply	B-API
it	O
by	O
passing	O
the	O
function	O
and	O
the	O
args	O
to	O
`	O
agg	B-API
`	O
:	O
#CODE	O

Excel	O
considers	O
1900	O
a	O
leap	O
year	O
,	O
so	O
be	O
careful	O
with	O
exactly	O
what	O
you	O
want	O
to	O
translate	B-API
:	O

Minor	O
bug	O
:	O
my_colors	O
=	O
[	O
cycle	O
([	O
'	O
b	O
'	O
,	O
'	O
r	O
'	O
,	O
'	O
g	O
'	O
,	O
'	O
y	O
'	O
,	O
'	O
k	O
'])	O
.next()	O
for	O
i	O
in	O
range	O
(	O
len	B-API
(	O
df	O
))]	O
will	O
give	O
'	O
b	O
'	O
every	O
time	O
in	O
python	O
2.7	O
.	O

You	O
should	O
use	O
list	O
(	O
islice	O
(	O
cycle	O
([	O
'	O
b	O
'	O
,	O
'	O
r	O
'	O
,	O
'	O
g	O
'	O
,	O
'	O
y	O
'	O
,	O
'	O
k	O
'])	O
,	O
None	O
,	O
len	B-API
(	O
df	O
)))	O
instead	O
.	O

it	O
=	O
cycle	O
([	O
'	O
b	O
'	O
,	O
'	O
r	O
'	O
,	O
'	O
g	O
'	O
,	O
'	O
y	O
'	O
,	O
'	O
k	O
'])	O
;	O
my_colors	O
=[	O
next	O
(	O
it	O
)	O
for	O
i	O
in	O
xrange	O
(	O
len	B-API
(	O
df	O
))]	O
would	O
cut	B-API
it	O
as	O
well	O
...	O

This	O
creates	O
a	O
boolean	O
mask	B-API
which	O
is	O
then	O
used	O
for	O
the	O
subsetting	O
.	O

I	O
have	O
a	O
relatively	O
simple	O
python	O
multiprocessing	O
script	O
that	O
sets	O
up	O
a	O
pool	O
of	O
workers	O
that	O
append	B-API
output	O
to	O
a	O
pandas	O
dataframe	B-API
by	O
way	O
of	O
a	O
custom	O
manager	O
.	O

The	O
correct	O
solution	O
is	O
to	O
wait	O
use	O
the	O
results	O
objects	O
to	O
get	O
the	O
results	O
and	O
then	O
append	B-API
all	O
of	O
them	O
in	O
the	O
main	O
thread	O
.	O

Where	O
has	O
`	O
unstack	B-API
`	O
been	O
hiding	O
???	O

Filtering	O
and	O
selecting	O
from	O
pivot	B-API
tables	O
made	O
with	O
python	O
pandas	O

Is	O
there	O
a	O
way	O
to	O
do	O
this	O
directly	O
within	O
the	O
pivot	B-API
table	O
structure	O
,	O
or	O
do	O
I	O
need	O
to	O
convert	O
this	O
back	O
in	O
to	O
a	O
panda	O
data	O
frame	O
?	O

Is	O
there	O
a	O
way	O
to	O
get	O
a	O
list	O
of	O
values	O
in	O
a	O
pivot	B-API
table	O
column	O
by	O
specifying	O
the	O
header	O
?	O

I	O
can	O
do	O
this	O
on	O
the	O
dataframe	B-API
with	O
'	O
df	O
[	O
'	O
A	O
']	O
.values	B-API
'	O
but	O
I'm	O
struggling	O
to	O
obtain	O
something	O
similar	O
from	O
the	O
pivot	B-API
table	O

the	O
result	O
of	O
the	O
pivot	B-API
table	O
is	O
a	O
DataFrame	B-API
.	O

How	O
to	O
keep	O
index	O
when	O
using	O
pandas	O
merge	B-API

I	O
would	O
like	O
to	O
merge	B-API
two	O
data	O
frames	O
,	O
and	O
keep	O
the	O
index	O
from	O
the	O
first	O
frame	O
as	O
the	O
index	O
on	O
the	O
merged	O
dataset	O
.	O

However	O
,	O
when	O
I	O
do	O
the	O
merge	B-API
,	O
the	O
resulting	O
DataFrame	B-API
has	O
integer	O
index	O
.	O

But	O
for	O
many	O
merge	B-API
operations	O
,	O
the	O
resulting	O
frame	O
has	O
not	O
the	O
same	O
number	O
of	O
rows	O
than	O
of	O
the	O
original	O
`	O
a	O
`	O
frame	O
.	O

reset_index	B-API
moves	O
the	O
index	O
to	O
a	O
regular	O
column	O
and	O
set_index	B-API
from	O
this	O
column	O
after	O
merge	B-API
also	O
takes	O
care	O
when	O
rows	O
of	O
a	O
are	O
duplicated	O
/	O
removed	O
due	O
to	O
the	O
merge	B-API
operation	O
.	O

There	O
are	O
some	O
places	O
where	O
pandas	O
is	O
not	O
as	O
careful	O
as	O
it	O
could	O
be	O
about	O
memory	O
usage	O
when	O
it	O
comes	O
to	O
MultiIndex	B-API
--	O
if	O
you	O
do	O
find	O
a	O
case	O
that	O
reproduces	O
the	O
issue	O
please	O
do	O
post	O
it	O
on	O
the	O
issue	O
tracker	O
.	O

I	O
can	O
loop	O
over	O
the	O
list	O
of	O
TimeStamps	O
and	O
get	O
the	O
relevant	O
rows	O
from	O
the	O
`	O
DataFrame	B-API
`	O
but	O
this	O
is	O
a	O
lengthy	O
process	O
and	O
I	O
thought	O
that	O
`	O
ix	B-API
[	O
]`	O
should	O
accept	O
a	O
list	O
of	O
values	O
according	O
to	O
the	O
docs	O
?	O

Ok	O
,	O
I	O
can	O
create	O
an	O
empty	O
dict	O
,	O
insert	B-API
values	O
and	O
create	O
a	O
DataFrame	B-API
.	O

Just	O
for	O
completeness	O
,	O
though	O
,	O
you	O
could	O
--	O
inefficiently	O
--	O
use	O
`	O
join	B-API
`	O
or	O
`	O
concat	B-API
`	O
to	O
get	O
a	O
column-by-column	O
approach	O
to	O
work	O
:	O
#CODE	O

In	O
this	O
example	O
I	O
get	O
an	O
Attribute	O
error	O
related	O
to	O
the	O
map	B-API
function	O
.	O

note	O
that	O
support	O
for	O
`	O
filter	O
(	O
None	O
,	O
iterable	O
)`	O
ceased	O
in	O
Python	O
3	O
,	O
need	O
to	O
do	O
`	O
filter	O
(	O
bool	B-API
,	O
iterable	O
)`	O
there	O

I'm	O
trying	O
to	O
unstack	B-API
a	O
dataframe	B-API
perform	O
operations	O
on	O
it	O
(	O
over	O
time	O
only	O
)	O
and	O
then	O
stack	B-API
it	O
back	O
together	O
like	O
this	O
:	O
#CODE	O

The	O
problem	O
is	O
that	O
multiindex	B-API
is	O
getting	O
reversed	O
after	O
the	O
operation	O
,	O
is	O
there	O
any	O
easy	O
way	O
to	O
make	O
this	O
work	O
?	O

Perhaps	O
I'm	O
misusing	O
the	O
stack	B-API
from	O
the	O
start	O
?	O

`	O
stack	B-API
`	O
and	O
`	O
unstack	B-API
`	O
add	O
level	O
(	O
s	O
)	O
to	O
the	O
end	O
of	O
the	O
MultiIndex	B-API
,	O
this	O
is	O
not	O
controllable	O
.	O

You	O
can	O
change	O
the	O
order	O
of	O
the	O
levels	O
in	O
a	O
MultiIndex	B-API
with	O
`	O
reorder_levels()	B-API
`	O
:	O
`	O
stacked.reorder_levels	O
([	O
2	O
,	O
1	O
,	O
0	O
])`	O
will	O
give	O
you	O
the	O
same	O
MultiIndex	B-API
levels	O
order	O
as	O
in	O
`	O
df	O
`	O

thanks	O
almost	O
works	O
,	O
you	O
have	O
to	O
add	O
an	O
`	O
.sortlevel	B-API
(	O
0	O
)`	O
to	O
get	O
a	O
correct	O
multiindex	B-API
.	O

As	O
noted	O
below	O
,	O
pandas	O
now	O
uses	O
SQLAlchemy	O
to	O
both	O
read	O
from	O
(	O
read_sql	B-API
)	O
and	O
insert	B-API
into	O
(	O
to_sql	B-API
)	O
a	O
database	O
.	O

How	O
do	O
I	O
really	O
use	O
the	O
`	O
ix	B-API
`	O
method	O
of	O
a	O
pandas	O
DataFrame	B-API
?	O

Having	O
read	O
the	O
docs	O
one	O
the	O
`	O
ix	B-API
`	O
method	O
of	O
DataFrames	O
,	O
I'm	O
a	O
bit	O
confused	O
by	O
the	O
following	O
behavior	O
with	O
my	O
MultiIndexed	O
DataFrame	B-API
(	O
specifying	O
select	O
columns	O
of	O
the	O
index	O
)	O
.	O

Why	O
does	O
the	O
`	O
ix	B-API
`	O
method	O
behave	O
like	O
this	O
?	O

If	O
you	O
want	O
to	O
select	O
rows	O
/	O
columns	O
based	O
on	O
MultiIndex	B-API
level	O
values	O
i	O
suggest	O
using	O
the	O
'	O
.xs()	B-API
'	O
method	O
.	O

Is	O
there	O
a	O
direct	O
way	O
to	O
do	O
this	O
on	O
one	O
level	O
of	O
a	O
multiindex	B-API
(	O
i.e.	O
without	O
the	O
reset_index	B-API
?	O
)	O

We	O
can	O
join	B-API
these	O
strings	O
with	O
the	O
regex	O
'	O
or	O
'	O
character	O
`	O
|	O
`	O
and	O
pass	O
the	O
string	O
to	O
`	O
str.contains	B-API
`	O
to	O
filter	O
the	O
DataFrame	B-API
:	O
#CODE	O

You	O
mention	O
in	O
your	O
question	O
that	O
the	O
red	O
line	O
is	O
the	O
mean	O
-	O
it	O
is	O
actually	O
the	O
median	B-API
.	O

with	O
a	O
line	O
at	O
the	O
median	B-API
.	O

The	O
set_value	B-API
approach	O
also	O
works	O
for	O
multiindex	B-API
DataFrames	O
by	O
putting	O
the	O
multiple	O
levels	O
of	O
the	O
index	O
in	O
as	O
a	O
tuple	O
(	O
e.g.	O
replacing	O
column	O
with	O
(	O
col	O
,	O
subcol	O
)	O
)	O

I	O
want	O
to	O
normalize	B-API
this	O
data	O
,	O
by	O
splitting	O
it	O
into	O
tables	O
.	O

In	O
case	O
of	O
fixed	O
width	O
file	O
,	O
no	O
need	O
to	O
do	O
anything	O
special	O
to	O
strip	B-API
white	O
space	O
,	O
or	O
handle	O
missing	O
fields	O
.	O

Python	O
pandas	O
equivalent	O
for	O
replace	B-API

In	O
R	O
,	O
there	O
is	O
a	O
rather	O
useful	O
`	O
replace	B-API
`	O
function	O
.	O

`	O
replace	B-API
(	O
df$column	O
,	O
df$column	O
==	O
1	O
,	O
'	O
Type	O
1	O
')	O
;	O
`	O

Should	O
I	O
use	O
a	O
lambda	O
with	O
`	O
apply	B-API
`	O
?	O

`	O
pandas	O
`	O
has	O
a	O
`	O
replace	B-API
`	O
method	O
too	O
:	O
#CODE	O

In	O
my	O
defence	O
,	O
the	O
replace	B-API
function	O
is	O
not	O
listed	O
[	O
here	O
]	O
(	O
#URL	O
)	O

How	O
to	O
broadcast	O
to	O
a	O
multiindex	B-API

If	O
B	O
is	O
the	O
one	O
with	O
a	O
MultiIndex	B-API
then	O
you	O
can	O
do	O
A.reindex	O
(	O
B.index	O
,	O
level=0	O
)	O
,	O
compute	O
the	O
result	O
,	O
and	O
then	O
do	O
result.groupby	O
(	O
level=0	O
)	O
to	O
compute	O
an	O
aggregate	B-API
result	O
.	O

After	O
this	O
,	O
I	O
think	O
I	O
should	O
insert	B-API
a	O
column	O
in	O
the	O
dataframe	B-API
that	O
labels	O
all	O
my	O
data	O
with	O
Monday	O
through	O
Friday	O
--	O
for	O
all	O
the	O
dates	O
in	O
the	O
file	O
(	O
there	O
are	O
6	O
years	O
of	O
data	O
)	O
.	O

And	O
then	O
,	O
I	O
need	O
to	O
join	B-API
these	O
.	O

Does	O
there	O
exist	O
in	O
pandas	O
methods	O
to	O
perform	O
a	O
similar	O
array	O
calculation	O
to	O
obtain	O
a	O
datetime	O
(	O
64	O
)	O
date	O
/	O
time	O
stamp	O
with	O
which	O
I	O
can	O
replace	B-API
the	O
current	O
sequential	O
dataframe	B-API
index	O
?	O

python	O
pandas	O
:	O
apply	B-API
a	O
function	O
with	O
arguments	O
to	O
a	O
series	O

I	O
want	O
to	O
apply	B-API
a	O
function	O
with	O
arguments	O
to	O
a	O
series	O
in	O
python	O
pandas	O
:	O
#CODE	O

The	O
documentation	O
describes	O
support	O
for	O
an	O
apply	B-API
method	O
,	O
but	O
it	O
doesn't	O
accept	O
any	O
arguments	O
.	O

The	O
apply	B-API
method	O
accept	O
a	O
python	O
function	O
which	O
should	O
have	O
a	O
single	O
parameter	O
.	O

For	O
a	O
DataFrame	B-API
apply	B-API
method	O
accepts	O
`	O
args	O
`	O
argument	O
,	O
which	O
is	O
a	O
tuple	O
holding	O
additional	O
positional	O
arguments	O
or	O
**	O
kwds	O
for	O
named	O
ones	O
.	O

@USER	O
:	O
I	O
notice	O
that	O
`	O
np.random.permutation	O
`	O
would	O
strip	B-API
the	O
column	O
names	O
from	O
the	O
DataFrame	B-API
,	O
because	O
`	O
np.random.permutation	O
`	O
.	O

pandas	O
merge	B-API
timeseries	O
,	O
concat	B-API
/	O
append	B-API
/	O
...	O

I	O
would	O
like	O
to	O
merge	B-API
the	O
existing	O
series	O
with	O
the	O
new	O
ones	O
subsequently	O
in	O
every	O
loop	O
,	O
while	O
preserving	O
their	O
(	O
different	O
)	O
indices	O
.	O

I	O
tried	O
concat	B-API
,	O
but	O
somehow	O
I	O
cannot	O
add	O
another	O
series	O
after	O
the	O
first	O
one	O
...	O

so	O
I	O
really	O
need	O
to	O
append	B-API
the	O
time	O
series	O
after	O
every	O
loop	O
...	O

I	O
do	O
something	O
like	O
this	O
all	O
the	O
time	O
but	O
I	O
use	O
`	O
append	B-API
`	O
like	O
this	O
:	O
#CODE	O

I	O
want	O
to	O
apply	B-API
a	O
groupby	B-API
operation	O
that	O
computes	O
cap-weighted	O
average	O
return	O
across	O
everything	O
,	O
per	O
each	O
date	O
in	O
the	O
"	O
yearmonth	O
"	O
column	O
.	O

The	O
join	B-API
example	O
at	O
the	O
bottom	O
does	O
work	O
,	O
but	O
it's	O
not	O
presented	O
clearly	O
.	O

Then	O
you	O
reindex	B-API
this	O
result	O
according	O
to	O
the	O
original	O
DataFrame	B-API
,	O
matching	O
their	O
indices	O
on	O
the	O
2	O
values	O
in	O
your	O
example	O
.	O

While	O
I'm	O
still	O
exploring	O
all	O
of	O
the	O
incredibly	O
smart	O
ways	O
that	O
`	O
apply	B-API
`	O
concatenates	O
the	O
pieces	O
it's	O
given	O
,	O
here's	O
another	O
way	O
to	O
add	O
a	O
new	O
column	O
in	O
the	O
parent	O
after	O
a	O
groupby	B-API
operation	O
.	O

May	O
I	O
suggest	O
the	O
`	O
transform	B-API
`	O
method	O
(	O
instead	O
of	O
aggregate	B-API
)	O
?	O

My	O
understanding	O
was	O
that	O
transform	B-API
produces	O
an	O
object	O
that	O
looks	O
like	O
the	O
one	O
it	O
was	O
passed	O
.	O

So	O
if	O
you	O
transform	B-API
a	O
DataFrame	B-API
,	O
you	O
don't	O
just	O
get	O
back	O
a	O
column	O
,	O
you	O
get	O
back	O
a	O
DataFrame	B-API
.	O

Whereas	O
in	O
my	O
case	O
,	O
I	O
want	O
to	O
append	B-API
a	O
new	O
result	O
to	O
the	O
original	O
data	O
frame	O
.	O

Or	O
are	O
you	O
saying	O
that	O
I	O
should	O
write	O
a	O
separate	O
function	O
that	O
takes	O
a	O
data	O
frame	O
,	O
computes	O
the	O
new	O
column	O
,	O
and	O
appends	O
the	O
new	O
column	O
,	O
and	O
*	O
then	O
*	O
transform	B-API
with	O
that	O
function	O
?	O

I	O
agree	O
,	O
transform	B-API
is	O
a	O
better	O
choice	O
,	O
df	O
[	O
'	O
A-month-sum	O
']	O
=	O
df.groupby	B-API
(	O
'	O
month	O
')	O
[	O
'	O
A	O
']	O
.transform	B-API
(	O
sum	O
)	O

IMHO	O
,	O
`	O
transform	B-API
`	O
looks	O
cleaner	O
.	O

Very	O
weird	O
bug	O
here	O
:	O
I'm	O
using	O
pandas	O
to	O
merge	B-API
several	O
dataframes	O
.	O

As	O
part	O
of	O
the	O
merge	B-API
,	O
I	O
have	O
to	O
call	O
reset_index	B-API
several	O
times	O
.	O

Inspecting	O
frame.py	O
,	O
it	O
looks	O
like	O
pandas	O
tries	O
to	O
insert	B-API
a	O
column	O
'	O
index	O
'	O
or	O
'	O
level_0	O
'	O
.	O

Fortunately	O
,	O
there's	O
a	O
"	O
drop	B-API
"	O
option	O
.	O

And	O
now	O
I	O
want	O
to	O
replace	B-API
the	O
element	O
of	O
df_a	O
by	O
element	O
of	O
df_b	O
which	O
have	O
the	O
same	O
(	O
index	O
,	O
column	O
)	O
coordinate	O
,	O
and	O
attach	O
df_b's	O
elements	O
whose	O
(	O
index	O
,	O
column	O
)	O
coordinate	O
beyond	O
the	O
scope	O
of	O
df_a	O
.	O

They	O
have	O
2	O
index	O
columns	O
and	O
the	O
reindex	B-API
operation	O
results	O
in	O
NaN	O
values	O
in	O
strange	O
places	O
(	O
I'll	O
post	O
the	O
dataframe	B-API
contents	O
if	O
anyone	O
is	O
willing	O
do	O
debug	O
it	O
)	O
.	O

Is	O
there	O
an	O
efficient	O
way	O
to	O
apply	B-API
this	O
disaggregation	O
map	B-API
to	O
get	O
a	O
new	O
dataframe	B-API
at	O
a	O
State	O
level	O
?	O

Building	O
on	O
that	O
,	O
you	O
can	O
create	O
a	O
boolean	O
array	O
from	O
a	O
MultiIndex	B-API
with	O
df.index.map()	O
and	O
use	O
the	O
result	O
to	O
filter	O
the	O
frame	O
.	O

And	O
if	O
I	O
want	O
to	O
filter	O
the	O
Q1	O
,	O
Q3	O
,	O
Q4	O
together	O
,	O
which	O
is	O
"	O
NOT	O
endswith	B-API
(	O
'	O
0630	O
')"	O
,	O
how	O
to	O
add	O
the	O
'	O
NOT	O
'	O
to	O
the	O
command	O
of	O
"	O
df	O
[	O
df.index.map	O
(	O
lambda	O
x	O
:	O
x	O
[	O
1	O
]	O
.endswith	B-API
(	O
"	O
0630	O
"))]	O
"	O
?	O

I	O
think	O
the	O
first	O
thing	O
I	O
should	O
do	O
should	O
be	O
to	O
'	O
unstack	B-API
'	O
the	O
values	O
in	O
the	O
csv	O
,	O
in	O
order	O
to	O
have	O
an	O
aligned	O
index	O
first	O
,	O
and	O
then	O
create	O
a	O
DataFrame	B-API
,	O
but	O
really	O
don't	O
how	O
...	O

There	O
might	O
be	O
a	O
slick	O
vectorized	O
way	O
to	O
do	O
this	O
,	O
but	O
I'd	O
just	O
apply	B-API
the	O
obvious	O
per-entry	O
function	O
to	O
the	O
values	O
and	O
get	O
on	O
with	O
my	O
day	O
:	O
#CODE	O

Reindex	B-API
time-stamped	O
data	O
with	O
date_range	B-API

If	O
you	O
would	O
use	O
the	O
timestamps	O
of	O
the	O
events	O
as	O
index	O
of	O
the	O
series	O
instead	O
of	O
the	O
data	O
,	O
resample	B-API
can	O
do	O
this	O
.	O

resample	B-API
(	O
this	O
method	O
can	O
also	O
be	O
used	O
on	O
a	O
DataFrame	B-API
)	O
will	O
give	O
a	O
new	O
series	O
with	O
in	O
this	O
case	O
15min	O
periods	O
,	O
the	O
end	O
time	O
of	O
a	O
bucket	O
(	O
period	O
)	O
is	O
used	O
to	O
refer	O
to	O
it	O
(	O
you	O
can	O
control	O
this	O
with	O
the	O
label	O
arg	O
)	O
.	O

Definitely	O
pay	O
attention	O
to	O
the	O
`	O
closed	O
`	O
and	O
`	O
label	O
`	O
options	O
to	O
`	O
resample	B-API
`	O
!	O

You	O
can	O
also	O
use	O
this	O
to	O
transform	B-API
a	O
subset	O
of	O
a	O
column	O
,	O
e.g.	O
:	O
#CODE	O

However	O
,	O
it	O
says	O
[	O
here	O
]	O
(	O
#URL	O
)	O
that	O
setting	O
works	O
with	O
ix	B-API
.	O

I	O
didn't	O
realize	O
@USER	O
B	O
.	O
was	O
asking	O
about	O
`	O
ix	B-API
`	O
in	O
general	O
.	O

The	O
section	O
after	O
'	O
Assignment	O
/	O
setting	O
values	O
is	O
possible	O
when	O
using	O
ix	B-API
:	O
'	O
will	O
explain	O
exactly	O
what	O
you	O
need	O
!	O

KDB+	O
like	O
asof	B-API
join	B-API
for	O
timeseries	O
data	O
in	O
pandas	O
?	O

kdb+	O
has	O
an	O
aj	O
function	O
that	O
is	O
usually	O
used	O
to	O
join	B-API
tables	O
along	O
time	O
columns	O
.	O

I	O
see	O
that	O
pandas	O
has	O
an	O
asof	B-API
function	O
but	O
that	O
is	O
not	O
defined	O
on	O
the	O
DataFrame	B-API
,	O
only	O
on	O
the	O
Series	O
object	O
.	O

I	O
guess	O
one	O
could	O
loop	O
through	O
each	O
of	O
the	O
Series	O
and	O
align	B-API
them	O
one	O
by	O
one	O
,	O
but	O
I	O
am	O
wondering	O
if	O
there	O
is	O
a	O
better	O
way	O
?	O

this	O
is	O
also	O
called	O
*	O
rolling	B-API
join	B-API
*	O

It	O
could	O
be	O
easily	O
(	O
well	O
,	O
for	O
someone	O
who	O
is	O
familiar	O
with	O
the	O
code	O
)	O
extended	O
to	O
be	O
a	O
"	O
left	O
join	B-API
"	O
mimicking	O
KDB	O
.	O

I	O
was	O
getting	O
`	O
ValueError	O
:	O
Index	O
contains	O
duplicate	O
entries	O
,	O
cannot	O
reshape	O
`	O
when	O
doing	O
`	O
unstack	B-API
`	O
on	O
a	O
MultIndex	O
but	O
this	O
solution	O
works	O
for	O
that	O
only	O
I	O
had	O
to	O
do	O
`	O
df_unique	O
=	O
df.groupby	B-API
(	O
level	O
=[	O
0	O
,	O
1	O
])	O
.first()	B-API
`	O

You	O
need	O
to	O
reset_index	B-API
if	O
you	O
want	O
to	O
drop	B-API
on	O
index	O
and	O
values	O
or	O
just	O
work	O
with	O
the	O
index	O
if	O
you	O
want	O
to	O
have	O
a	O
unique	O
index	O
.	O

Add	O
parse_dates=True	O
,	O
otherwise	O
your	O
index	O
will	O
be	O
plain	O
strings	O
and	O
resample	B-API
does	O
not	O
like	O
that	O
.	O

Date	O
=	O
range	O
(	O
len	B-API
(	O
df2	O
))	O

Volume	O
=	O
np.zeros	O
(	O
len	B-API
(	O
df2	O
))	O

EDIT	O
:	O
I	O
have	O
just	O
read	O
the	O
help	O
on	O
`	O
pandas.Series.diff()	B-API
`	O
,	O
but	O
still	O
I'd	O
like	O
to	O
"	O
replace	B-API
"	O
the	O
subtraction	O
used	O
on	O
diff	B-API
by	O
another	O
function	O
,	O
say	O
`	O
euclidean_distance()	O
'	O
.	O

I	O
would	O
suggest	O
you	O
just	O
write	O
a	O
function	O
to	O
do	O
what	O
you're	O
saying	O
probably	O
using	O
`	O
drop	B-API
`	O
(	O
to	O
delete	O
columns	O
)	O
and	O
`	O
insert	B-API
`	O
to	O
insert	B-API
columns	O
at	O
a	O
position	O
.	O

I	O
have	O
a	O
Pandas	O
dataframe	B-API
'	O
dt	B-API
=	O
myfunc()	O
'	O
,	O
and	O
copy	O
the	O
screen	O
output	O
from	O
IDLE	O
as	O
below	O
:	O
#CODE	O

The	O
function	O
to	O
apply	B-API
is	O
like	O
:	O
#CODE	O

I	O
would	O
use	O
transpose	B-API
and	O
the	O
sort	O
method	O
(	O
which	O
works	O
on	O
columns	O
):	O
#CODE	O

Duplicate	O
entries	O
for	O
index	O
in	O
pandas	O
pivot	B-API
function	O

My	O
goal	O
is	O
to	O
have	O
data	O
grouped	O
by	O
date	O
,	O
mat	O
and	O
strike	O
(	O
I	O
can	O
drop	B-API
the	O
'	O
3m	O
'	O
and	O
'	O
dataframe	B-API
name	O
'	O
columns	O
since	O
they're	O
common	O
to	O
all	O
data	O
)	O
.	O

Can	O
anyone	O
help	O
me	O
with	O
this	O
issue	O
,	O
or	O
propose	O
an	O
alternative	O
approach	O
to	O
the	O
pivot	B-API
function	O
?	O

`	O
pivot	B-API
`	O
is	O
a	O
reshape	O
operation	O
:	O
#CODE	O

Now	O
for	O
the	O
strides	B-API
.	O

Basic	O
problem	O
:	O
how	O
do	O
I	O
map	B-API
the	O
function	O
to	O
the	O
column	O
,	O
specifically	O
where	O
I	O
would	O
like	O
to	O
reference	O
more	O
than	O
one	O
other	O
column	O
or	O
the	O
whole	O
row	O
or	O
whatever	O
?	O

Then	O
you	O
can	O
use	O
map	B-API
:	O
#CODE	O

I	O
don't	O
suppose	O
you	O
have	O
nny	O
ideas	O
on	O
the	O
second	O
part	O
,	O
viz	O
referencing	O
neighbouring	O
rows	O
in	O
the	O
dataframe	B-API
from	O
within	O
the	O
map	B-API
/	O
apply	B-API
function	O
?	O

The	O
exact	O
code	O
will	O
vary	O
for	O
each	O
of	O
the	O
columns	O
you	O
want	O
to	O
do	O
,	O
but	O
it's	O
likely	O
you'll	O
want	O
to	O
use	O
the	O
`	O
map	B-API
`	O
and	O
`	O
apply	B-API
`	O
functions	O
.	O

If	O
you	O
need	O
to	O
use	O
operations	O
like	O
max	O
and	O
min	O
within	O
a	O
row	O
,	O
you	O
can	O
use	O
`	O
apply	B-API
`	O
with	O
`	O
axis=1	O
`	O
to	O
apply	B-API
any	O
function	O
you	O
like	O
to	O
each	O
row	O
.	O

For	O
the	O
second	O
part	O
of	O
your	O
question	O
,	O
you	O
can	O
also	O
use	O
`	O
shift	B-API
`	O
,	O
for	O
example	O
:	O
#CODE	O

Then	O
groupby	B-API
the	O
pattern	O
and	O
apply	B-API
the	O
appropriate	O
function	O
to	O
each	O
group	O
.	O

Generating	O
a	O
boolean	O
mask	B-API
indexing	O
one	O
array	O
into	O
another	O
array	O

Note	O
that	O
as	O
suggested	O
in	O
a	O
comment	O
by	O
@USER	O
,	O
you	O
should	O
use	O
`	O
np.eye	O
(	O
len	B-API
(	O
x	O
))`	O
instead	O
of	O
`	O
np.diag	O
([	O
1	O
]	O
*len	O
(	O
x	O
))`	O
.	O

Now	O
I	O
really	O
don't	O
know	O
why	O
you	O
want	O
a	O
boolean	O
mask	B-API
,	O
these	O
indices	O
can	O
be	O
applied	O
to	O
z	O
to	O
give	O
back	O
x	O
already	O
and	O
are	O
more	O
compact	O
.	O

Python	O
Pandas	O
:	O
how	O
to	O
add	O
a	O
totally	O
new	O
column	O
to	O
a	O
data	O
frame	O
inside	O
of	O
a	O
groupby	B-API
/	O
transform	B-API
operation	O

Now	O
,	O
the	O
real	O
question	O
is	O
how	O
to	O
use	O
`	O
transform	B-API
`	O
to	O
add	O
a	O
new	O
column	O
to	O
the	O
data	O
.	O

Note	O
that	O
a	O
simple	O
`	O
apply	B-API
`	O
will	O
not	O
work	O
here	O
,	O
since	O
it	O
won't	O
know	O
how	O
to	O
make	O
sense	O
of	O
the	O
possibly	O
differently-sized	O
result	O
arrays	O
for	O
each	O
group	O
.	O

can	O
you	O
not	O
use	O
`	O
map	B-API
`	O
?	O

What	O
problems	O
are	O
you	O
running	O
into	O
with	O
`	O
apply	B-API
`	O
?	O

You	O
need	O
to	O
construct	O
your	O
full	O
index	O
,	O
and	O
then	O
use	O
the	O
`	O
reindex	B-API
`	O
method	O
of	O
the	O
dataframe	B-API
.	O

In	O
the	O
current	O
version	O
of	O
pandas	O
,	O
there	O
is	O
a	O
function	O
to	O
build	O
`	O
MultiIndex	B-API
`	O
from	O
the	O
Cartesian	O
product	O
of	O
iterables	O
.	O

Python	O
Pandas	O
:	O
How	O
to	O
broadcast	O
an	O
operation	O
using	O
apply	B-API
without	O
writing	O
a	O
secondary	O
function	O

It	O
seems	O
logical	O
to	O
use	O
the	O
`	O
apply	B-API
`	O
function	O
for	O
this	O
,	O
but	O
it	O
doesn't	O
work	O
like	O
expected	O
.	O

It	O
does	O
not	O
even	O
seem	O
to	O
be	O
consistent	O
with	O
other	O
uses	O
of	O
`	O
apply	B-API
`	O
.	O

Based	O
on	O
this	O
,	O
it	O
appears	O
that	O
`	O
apply	B-API
`	O
does	O
nothing	O
but	O
perform	O
the	O
NumPy	O
equivalent	O
of	O
whatever	O
is	O
called	O
inside	O
.	O

That	O
is	O
,	O
`	O
apply	B-API
`	O
seems	O
to	O
execute	O
the	O
same	O
thing	O
as	O
`	O
arr	O
+	O
"	O
cat	O
"`	O
in	O
the	O
first	O
example	O
.	O

But	O
this	O
seems	O
to	O
break	O
from	O
what	O
`	O
apply	B-API
`	O
promises	O
in	O
the	O
docs	O
.	O

Is	O
there	O
some	O
way	O
of	O
using	O
`	O
apply	B-API
`	O
that	O
I	O
am	O
missing	O
here	O
?	O

and	O
I	O
verified	O
that	O
this	O
version	O
does	O
work	O
with	O
Pandas	O
`	O
apply	B-API
`	O
.	O

Isn't	O
this	O
specifically	O
what	O
`	O
apply	B-API
`	O
is	O
supposed	O
to	O
abstract	O
away	O
from	O
the	O
user	O
?	O

and	O
use	O
this	O
in	O
`	O
apply	B-API
`	O
:	O
#CODE	O

This	O
works	O
,	O
but	O
I	O
consider	O
it	O
a	O
workaround	O
as	O
well	O
,	O
since	O
it	O
doesn't	O
address	O
the	O
fact	O
that	O
`	O
apply	B-API
`	O
isn't	O
working	O
as	O
promised	O
.	O

Can	O
you	O
verify	O
that	O
`	O
map	B-API
`	O
will	O
work	O
in	O
all	O
the	O
same	O
situations	O
where	O
`	O
apply	B-API
`	O
will	O
work	O
?	O

I	O
also	O
don't	O
like	O
the	O
inconsistency	O
in	O
going	O
from	O
`	O
map	B-API
`	O
for	O
a	O
Series	O
to	O
`	O
applymap	B-API
`	O
for	O
a	O
DataFrame	B-API
.	O

That	O
contradicts	O
the	O
docs	O
for	O
`	O
apply	B-API
`	O
,	O
as	O
well	O
as	O
its	O
0.8.1	O
behavior	O
,	O
in	O
which	O
it	O
successfully	O
performs	O
the	O
elementwise	O
version	O
of	O
my	O
example	O
above	O
,	O
whereas	O
version	O
0.7.3	O
seems	O
to	O
use	O
the	O
logic	O
you	O
describe	O
.	O

Since	O
`	O
apply	B-API
`	O
should	O
work	O
in	O
0.7.3	O
as	O
it	O
does	O
in	O
0.8.1	O
(	O
according	O
to	O
the	O
docs	O
)	O
,	O
that's	O
why	O
I	O
think	O
it's	O
a	O
workaround	O
.	O

`	O
map	B-API
`	O
is	O
fine	O
,	O
but	O
`	O
apply	B-API
`	O
should	O
work	O
.	O

`	O
apply	B-API
`	O
is	O
designed	O
so	O
that	O
you	O
can	O
apply	B-API
a	O
ufunc	O
and	O
get	O
back	O
a	O
Series	O
with	O
the	O
index	O
intact	O
.	O

Though	O
I	O
do	O
agree	O
with	O
you	O
the	O
docstring	O
for	O
apply	B-API
is	O
very	O
unclear	O
about	O
this	O
aspect	O
.	O

We	O
can	O
improve	O
the	O
documentation	O
for	O
apply	B-API
.	O

In	O
fact	O
,	O
by	O
saying	O
that	O
`	O
apply	B-API
`	O
can	O
take	O
any	O
function	O
that	O
expect	O
a	O
*	O
single	O
*	O
argument	O
,	O
it's	O
not	O
just	O
unclear	O
,	O
but	O
plain	O
misleading	O
.	O

So	O
to	O
be	O
clear	O
,	O
we	O
should	O
use	O
`	O
apply	B-API
`	O
whenever	O
we	O
have	O
a	O
vectorized	O
/	O
ufunc	O
already	O
,	O
and	O
`	O
map	B-API
`	O
when	O
we	O
literally	O
want	O
to	O
apply	B-API
an	O
elementwise	O
operation	O
to	O
a	O
series	O
?	O

Yup	O
,	O
that's	O
exactly	O
right	O
on	O
`	O
apply	B-API
`	O
vs	O
`	O
map	B-API
`	O
.	O

Stepping	O
the	O
trace	O
in	O
the	O
case	O
of	O
date	O
column	O
,	O
shows	O
that	O
matplotlib	O
tries	O
to	O
do	O
x	O
[	O
0	O
]	O
on	O
the	O
dates	O
to	O
retrieve	O
tz	B-API
info	O
,	O
which	O
throws	O
a	O
KeyError	O
.	O

I	O
decided	O
to	O
change	O
date	O
to	O
first	O
day	O
of	O
each	O
month	O
using	O
a	O
lamdba	O
function	O
that	O
calls	O
replace	B-API
(	O
day=1	O
)	O
.	O

You're	O
producing	O
an	O
aggregate	B-API
r	O
and	O
s	O
value	O
per	O
group	O
,	O
so	O
you	O
should	O
be	O
using	O
`	O
Series	B-API
`	O
here	O
:	O
#CODE	O

You'd	O
have	O
to	O
map	B-API
that	O
to	O
the	O
columns	O
using	O
`	O
map	B-API
`	O
or	O
`	O
apply	B-API
`	O
or	O
something	O
.	O

@USER	O
:	O
To	O
avoid	O
the	O
error	O
,	O
replace	B-API
`	O
int	O
(	O
x	O
)`	O
with	O
the	O
expression	O
`	O
int	O
(	O
text	O
)	O
if	O
x.isdigit()	O
else	O
x	O
`	O
.	O

Now	O
I	O
want	O
to	O
merge	B-API
the	O
data	O
frame	O
with	O
the	O
series	O
,	O
such	O
that	O
the	O
values	O
from	O
the	O
series	O
are	O
broadcasted	O
along	O
the	O
second	O
level	O
index	O
.	O

How	O
to	O
groupby	B-API
the	O
first	O
level	O
index	O
and	O
apply	B-API
function	O
to	O
the	O
second	O
index	O
in	O
Pandas	O

And	O
I	O
want	O
to	O
apply	B-API
a	O
function	O
`	O
func	O
`	O
(	O
exp	O
:	O
`'	O
lambda	O
x	O
:	O
x*10	O
'`)	O
to	O
`	O
second	B-API
`	O
,	O
somewhat	O
like	O
:	O
#CODE	O

This	O
way	O
,	O
the	O
index	O
column	O
is	O
not	O
dropped	O
and	O
still	O
accessible	O
for	O
your	O
`	O
apply	B-API
`	O
.	O

I	O
want	O
to	O
drop	B-API
duplicates	O
,	O
keeping	O
the	O
row	O
with	O
the	O
highest	O
value	O
in	O
column	O
B	O
.	O

Wes	O
has	O
added	O
some	O
nice	O
functionality	O
to	O
drop	B-API
duplicates	O
:	O
#URL	O
.	O

D'you	O
know	O
the	O
best	O
idiom	O
to	O
reindex	B-API
this	O
to	O
look	O
like	O
the	O
original	O
DataFrame	B-API
?	O

There's	O
some	O
code	O
to	O
reindex	B-API
the	O
grouped	O
dataframe	B-API
.	O

PS	O
:	O
but	O
if	O
you	O
really	O
just	O
want	O
the	O
last	O
column	O
,	O
`	O
apply	B-API
`	O
would	O
suffice	O
:	O
#CODE	O

@USER	O
It	O
seems	O
to	O
work	O
for	O
me	O
,	O
with	O
your	O
example	O
(	O
without	O
the	O
`	O
skiprows	O
`)	O
...	O
perhaps	O
you	O
need	O
to	O
`	O
myData.T	O
`	O
(	O
transpose	B-API
)	O
.	O

I've	O
tried	O
using	O
rename	O
to	O
change	O
the	O
columns	O
on	O
one	O
df	O
first	O
,	O
but	O
(	O
1	O
)	O
I'd	O
rather	O
not	O
do	O
that	O
and	O
(	O
2	O
)	O
my	O
real	O
data	O
has	O
a	O
multiindex	B-API
on	O
the	O
columns	O
(	O
where	O
only	O
one	O
layer	O
of	O
the	O
multiindex	B-API
is	O
differently	O
labeled	O
)	O
,	O
and	O
rename	O
seems	O
tricky	O
for	O
that	O
case	O
...	O

So	O
to	O
try	O
and	O
generalize	O
my	O
question	O
,	O
how	O
can	O
I	O
get	O
`	O
df1	O
*	O
df2	O
`	O
using	O
`	O
map	B-API
`	O
to	O
define	O
the	O
columns	O
to	O
multiply	O
together	O
?	O

Assuming	O
the	O
index	O
is	O
already	O
aligned	O
,	O
you	O
probably	O
just	O
want	O
to	O
align	B-API
the	O
columns	O
in	O
both	O
DataFrame	B-API
in	O
the	O
right	O
order	O
and	O
divide	O
the	O
`	O
.values	B-API
`	O
of	O
both	O
DataFrames	O
.	O

Suppose	O
we	O
want	O
to	O
multiply	O
several	O
columns	O
with	O
other	O
serveral	O
columns	O
in	O
the	O
same	O
dataframe	B-API
and	O
append	B-API
these	O
results	O
into	O
the	O
original	O
dataframe	B-API
.	O

(	O
I	O
think	O
it	O
can	O
be	O
some	O
problem	O
with	O
`	O
lambda	O
`	O
When	O
I	O
want	O
to	O
apply	B-API
my	O
function	O
to	O
the	O
column	O
I	O
have	O
an	O
error	O
:	O
`	O
TypeError	O
:	O
only	O
length-1	O
arrays	O
can	O
be	O
converted	O
to	O
Python	O
scalars	O
`)	O

On	O
top	O
of	O
a	O
dodgy	O
converter	O
,	O
i	O
think	O
you	O
apply	B-API
the	O
converter	O
to	O
the	O
wrong	O
column	O
(	O
look	O
at	O
the	O
exception	O
you	O
get	O
)	O
.	O

Is	O
there	O
a	O
way	O
to	O
do	O
this	O
if	O
you	O
want	O
to	O
normalize	B-API
a	O
subset	O
?	O

Say	O
that	O
row	O
`	O
A	O
`	O
and	O
`	O
B	O
`	O
are	O
part	O
of	O
a	O
larger	O
grouping	O
factor	O
that	O
you	O
want	O
to	O
normalize	B-API
separately	O
from	O
`	O
C	O
`	O
and	O
`	O
D	O
`	O
.	O

You	O
can	O
use	O
`	O
apply	B-API
`	O
for	O
this	O
,	O
and	O
it's	O
a	O
bit	O
neater	O
:	O
#CODE	O

If	O
you	O
want	O
that	O
done	O
on	O
every	O
row	O
in	O
the	O
dataframe	B-API
,	O
you	O
can	O
use	O
apply	B-API
(	O
with	O
axis=1	O
to	O
select	O
rows	O
instead	O
of	O
columns	O
):	O
#CODE	O

I	O
tried	O
with	O
various	O
attempts	O
of	O
'	O
unstack	B-API
'	O
,	O
'	O
groupby	B-API
'	O
and	O
'	O
pivot	B-API
'	O
but	O
with	O
no	O
success	O
.	O

At	O
the	O
moment	O
for	O
conversion	O
I	O
use	O
as	O
below	O
,	O
but	O
need	O
remove	O
unwanted	O
rows	O
first	O
to	O
apply	B-API
it	O
to	O
all	O
df	O
.	O

(	O
The	O
series	O
always	O
got	O
the	O
same	O
length	O
as	O
a	O
dataframe	B-API
.	O
)	O
I	O
tried	O
different	O
versions	O
of	O
`	O
join	B-API
`	O
,	O
`	O
append	B-API
`	O
,	O
`	O
merge	B-API
`	O
,	O
but	O
I	O
did	O
not	O
get	O
it	O
as	O
what	O
I	O
want	O
,	O
only	O
errors	O
at	O
the	O
most	O
.	O

Note	O
my	O
original	O
(	O
very	O
old	O
)	O
suggestion	O
was	O
to	O
use	O
`	O
map	B-API
`	O
(	O
which	O
is	O
much	O
slower	O
):	O
#CODE	O

@USER	O
if	O
you	O
already	O
have	O
`	O
e	O
`	O
as	O
a	O
Series	O
then	O
you	O
don't	O
need	O
to	O
use	O
`	O
map	B-API
`	O
,	O
use	O
`	O
df	O
[	O
'	O
e	O
']	O
=e	O
`	O
(	O
@USER	O
answer	O
)	O
.	O

this	O
will	O
effectively	O
be	O
a	O
left	O
join	B-API
on	O
the	O
df1.index	O
.	O

So	O
if	O
you	O
want	O
to	O
have	O
an	O
outer	O
join	B-API
effect	O
,	O
my	O
probably	O
imperfect	O
solution	O
is	O
to	O
create	O
a	O
dataframe	B-API
with	O
index	O
values	O
covering	O
the	O
universe	O
of	O
your	O
data	O
,	O
and	O
then	O
use	O
the	O
code	O
above	O
.	O

This	O
worked	O
fine	O
to	O
insert	B-API
the	O
column	O
at	O
the	O
end	O
.	O

Then	O
,	O
since	O
you	O
extend	O
the	O
base	O
class	O
,	O
you	O
have	O
to	O
replace	B-API
the	O
methods	O
with	O
a	O
suitable	O
descriptor	O
:	O
#CODE	O

I	O
want	O
to	O
resample	B-API
a	O
TimeSeries	O
in	O
daily	O
(	O
exactly	O
24	O
hours	O
)	O
frequence	O
starting	O
at	O
a	O
certain	O
hour	O
.	O

Some	O
weeks	O
ago	O
you	O
could	O
pass	O
`'	O
24H	O
'`	O
to	O
the	O
`	O
freq	B-API
`	O
argument	O
and	O
it	O
worked	O
totally	O
fine	O
.	O

is	O
there	O
an	O
existing	O
built-in	O
way	O
to	O
apply	B-API
two	O
different	O
aggregating	O
functions	O
to	O
the	O
same	O
column	O
,	O
without	O
having	O
to	O
call	O
`	O
agg	B-API
`	O
multiple	O
times	O
?	O

Is	O
there	O
any	O
other	O
manner	O
for	O
expressing	O
the	O
input	O
to	O
`	O
agg	B-API
`	O
?	O

If	O
you	O
look	O
at	O
the	O
doc	O
string	O
for	O
`	O
aggregate	B-API
`	O
it	O
explicitly	O
says	O
that	O
when	O
a	O
`	O
dict	O
`	O
is	O
passed	O
,	O
the	O
keys	O
must	O
be	O
column	O
names	O
.	O

So	O
this	O
is	O
the	O
Series	O
version	O
of	O
aggregate	B-API
?	O

I'm	O
looking	O
to	O
do	O
the	O
DataFrame	B-API
version	O
of	O
aggregate	B-API
,	O
and	O
I	O
want	O
to	O
apply	B-API
several	O
different	O
aggregations	O
to	O
each	O
column	O
all	O
at	O
once	O
.	O

I	O
would	O
just	O
use	O
the	O
transpose	B-API
of	O
the	O
array	O
because	O
that's	O
much	O
faster	O
,	O
but	O
then	O
I	O
would	O
have	O
a	O
`	O
MultiIndex	B-API
`	O
on	O
the	O
columns	O
,	O
and	O
I	O
haven't	O
yet	O
found	O
any	O
documentation	O
in	O
Pandas	O
showing	O
how	O
to	O
use	O
`	O
MultiIndex	B-API
`	O
s	O
as	O
columns	O
.	O

To	O
get	O
all	O
shank	O
1's	O
(	O
i.e.	O
where	O
the	O
first	O
level	O
of	O
the	O
MultiIndex	B-API
is	O
equal	O
to	O
1	O
)	O
.	O

This	O
is	O
pretty	O
flexible	O
if	O
you	O
need	O
to	O
cross-section	O
by	O
a	O
different	O
level	O
of	O
the	O
MultiIndex	B-API
as	O
well	O
.	O

An	O
alternative	O
slightly	O
more	O
flexible	O
way	O
,	O
might	O
be	O
to	O
use	O
`	O
apply	B-API
`	O
(	O
or	O
equivalently	O
`	O
map	B-API
`	O
)	O
to	O
do	O
this	O
:	O
#CODE	O

I	O
think	O
it	O
wight	O
be	O
simpler	O
to	O
completely	O
drop	B-API
this	O
column	O
,	O
and	O
then	O
add	O
a	O
new	O
one	O
with	O
the	O
year	O
,	O
or	O
completely	O
replace	B-API
the	O
values	O
by	O
the	O
year	O
.	O

First	O
,	O
I	O
think	O
you	O
have	O
to	O
either	O
specify	O
named	O
parameters	O
or	O
use	O
`	O
args	O
`	O
to	O
pass	O
additional	O
arguments	O
to	O
`	O
apply	B-API
`	O
.	O

because	O
`	O
apply	B-API
`	O
doesn't	O
act	O
elementwise	O
,	O
it	O
acts	O
on	O
entire	O
Series	O
objects	O
.	O

Is	O
there	O
a	O
grep	O
like	O
built-in	O
function	O
in	O
Pandas	O
to	O
drop	B-API
a	O
row	O
if	O
it	O
has	O
some	O
string	O
or	O
value	O
?	O

Below	O
example	O
will	O
drop	B-API
all	O
rows	O
where	O
column	O
A	O
holds	O
'	O
a	O
'	O
character	O
and	O
'	O
B	O
'	O
equals	O
20	O
.	O

@USER	O
:	O
to	O
drop	B-API
the	O
unmatched	O
condition	O
.	O

Generally	O
,	O
I	O
find	O
myself	O
using	O
boolean	O
indexing	O
and	O
the	O
tilde	O
operator	O
when	O
obtaining	O
the	O
inverse	O
of	O
a	O
selection	O
,	O
rather	O
than	O
df.drop()	B-API
,	O
though	O
the	O
same	O
concept	O
applies	O
to	O
df.drop	B-API
when	O
boolean	O
indexing	O
is	O
used	O
to	O
form	O
the	O
array	O
of	O
labels	O
to	O
drop	B-API
.	O

You	O
can	O
transform	B-API
the	O
tuple	O
to	O
list	O
with	O
`	O
list	O
(	O
tup	O
)`	O
and	O
do	O
the	O
switch	O
.	O

One	O
way	O
to	O
do	O
this	O
is	O
to	O
use	O
apply	B-API
:	O
#CODE	O

If	O
you	O
want	O
to	O
change	O
the	O
values	O
in	O
only	O
one	O
column	O
you	O
can	O
still	O
use	O
`	O
apply	B-API
`	O
:	O
#CODE	O

Note	O
:	O
since	O
`	O
my_fun2	O
`	O
returns	O
a	O
single	O
value	O
,	O
this	O
time	O
`	O
apply	B-API
`	O
return	O
a	O
Series	O
,	O
so	O
we	O
need	O
to	O
slightly	O
change	O
the	O
way	O
we	O
apply	B-API
apply	B-API
.	O

`	O
agg	B-API
`	O
is	O
just	O
a	O
shorthand	O
for	O
`	O
aggregate	B-API
`	O
,	O
you	O
are	O
however	O
forcing	O
it	O
to	O
work	O
on	O
single	O
columns	O
always	O
,	O
which	O
works	O
around	O
the	O
issue	O
.	O

median	B-API
median	B-API

`	O
agg	B-API
([	O
np.median	O
])`	O
:)	O
yes	O
.	O

This	O
means	O
aggregate	B-API
passes	O
first	O
the	O
2D	O
series	O
in	O
.	O

Thank	O
you	O
,	O
I	O
suspected	O
the	O
problem	O
was	O
about	O
pandas	O
-	O
numpy	O
interface	O
and	O
numpy's	O
array	O
treatment	O
,	O
inspected	O
`	O
aggregate	B-API
`	O
docstring	O
,	O
but	O
could	O
not	O
draw	O
the	O
conclusion	O
you	O
did	O
;)	O

For	O
things	O
like	O
sum	O
,	O
mean	O
,	O
median	B-API
,	O
max	O
,	O
min	O
,	O
first	O
,	O
last	O
,	O
std	O
,	O
you	O
can	O
call	O
the	O
method	O
directly	O
and	O
not	O
have	O
to	O
worry	O
about	O
the	O
apply-to-DataFrame-but-failover-to-each-column	O
mechanism	O
in	O
the	O
GroupBy	B-API
engine	O
.	O

(	O
what	O
is	O
`	O
pd	O
`	O
and	O
what	O
is	O
`	O
dt	B-API
`)	O
?	O

>>>	O
import	O
datetime	O
as	O
dt	B-API

I	O
replace	B-API
2	O
by	O
1	O
in	O
the	O
isocalendar	O
.	O
the	O
propriety	O
week	O
of	O
TimeStamp	O
is	O
very	O
strange	O
.	O

In	O
general	O
,	O
though	O
,	O
is	O
there	O
a	O
prefered	O
approach	O
to	O
Split-Apply-Combine	O
where	O
Apply	B-API
returns	O
a	O
dataframe	B-API
of	O
arbitrary	O
size	O
(	O
but	O
consistent	O
for	O
all	O
chunks	O
)	O
,	O
and	O
Combine	O
just	O
vstacks	O
the	O
returned	O
DFs	O
?	O

Use	O
`	O
join	B-API
`	O
:	O
#CODE	O

I	O
do	O
not	O
want	O
to	O
join	B-API
them	O
)	O

I	O
would	O
like	O
to	O
drop	B-API
all	O
non-numeric	O
columns	O
in	O
one	O
fell	O
swoop	O
,	O
without	O
knowing	O
their	O
names	O
or	O
indices	O
,	O
since	O
this	O
could	O
be	O
doable	O
reading	O
their	O
dtype	B-API
.	O

pyPandas	O
:	O
mess	O
with	O
join	B-API
/	O
append	B-API
/	O
concat	B-API
two	O
dataframes	O

I	O
would	O
like	O
to	O
join	B-API
them	O
side	O
by	O
side	O
resulting	O
in	O
a	O
21	O
cols	O
dataframe	B-API
with	O
the	O
same	O
624	O
number	O
of	O
rows	O
.	O

I	O
have	O
tried	O
several	O
things	O
join	B-API
them	O
by	O
axis=1	O
ignoring	O
index	O
or	O
not	O
.	O

I	O
also	O
tried	O
concat	B-API
and	O
append	B-API
,	O
but	O
with	O
no	O
success	O
.	O

One	O
alternative	O
is	O
to	O
merge	B-API
on	O
'	O
Name	O
'	O
and	O
'	O
L1	O
'	O
:	O
#CODE	O

Another	O
is	O
to	O
call	O
DataFrame.reset_index	B-API
first	O
before	O
you	O
call	O
merge	B-API
:	O
#CODE	O

I	O
had	O
realized	O
that	O
reset	O
would	O
work	O
,	O
however	O
,	O
why	O
to	O
reset	O
index	O
to	O
concat	B-API
dfs	O
ignoring	O
them	O
?	O

At	O
least	O
in	O
`	O
concat	B-API
`	O
,	O
you	O
have	O
to	O
declare	O
axis	O
.	O

Pandas	O
DataFrame	B-API
:	O
apply	B-API
function	O
to	O
all	O
columns	O

Is	O
there	O
a	O
more	O
pythonic	O
way	O
to	O
apply	B-API
a	O
function	O
to	O
all	O
columns	O
or	O
the	O
entire	O
frame	O
(	O
without	O
a	O
loop	O
)	O
?	O

Pandas	O
transpose	B-API
concat()	B-API

How	O
to	O
transpose	B-API
a	O
DataFrame	B-API
returned	O
by	O
concat()	B-API
?	O

I	O
have	O
been	O
attempting	O
to	O
use	O
the	O
merge	B-API
,	O
concat	B-API
and	O
join	B-API
functions	O
to	O
no	O
avail	O
.	O

You	O
can	O
use	O
the	O
keys	O
argument	O
for	O
concat	B-API
,	O
this	O
will	O
result	O
in	O
a	O
MultiIndex	B-API
and	O
will	O
allow	O
you	O
to	O
uniquely	O
select	O
data	O
:	O
concat	B-API
(	O
pieces	O
,	O
keys	O
=[	O
'	O
left	O
'	O
,	O
'	O
middle	O
'	O
,	O
'	O
right	O
']	O
.	O

Note	O
that	O
basic	O
backfill	B-API
and	O
forward	O
fill	O
would	O
not	O
be	O
sufficient	O
to	O
fill	O
every	O
daily	O
observation	O
in	O
the	O
month	O
with	O
the	O
monthly	O
value	O
.	O

you	O
can	O
fill	O
the	O
resampled	O
series	O
sr	O
as	O
following	O
:	O
sr.groupby	O
(	O
sr.index.month	O
)	O
.transform	B-API
(	O
lambda	O
x	O
:	O
x.fillna	O
(	O
method=	O
'	O
backfill	B-API
'))	O

Using	O
your	O
guidance	O
,	O
I	O
was	O
also	O
able	O
to	O
implement	O
the	O
daily	O
average	O
I	O
mentioned	O
:	O
sr.groupby	O
(	O
sr.index.month	O
)	O
.transform	B-API
(	O
lambda	O
x	O
:	O
x.fillna	O
(	O
method=	O
'	O
backfill	B-API
')	O
/	O
len	B-API
(	O
x	O
))	O

I	O
don't	O
think	O
you	O
need	O
the	O
groupby	B-API
here	O
if	O
you	O
use	O
resample	B-API
,	O
there	O
is	O
a	O
`	O
fill_method	O
`	O
parameter	O
in	O
`	O
resample	B-API
`	O
that	O
just	O
fills	O
the	O
time	O
bin	O
.	O

@USER	O
She	O
-	O
I	O
was	O
able	O
to	O
use	O
s.resample	O
(	O
'	O
D	O
'	O
,	O
fill_method=	O
'	O
backfill	B-API
')	O
to	O
fill	O
in	O
data	O
,	O
however	O
,	O
I	O
couldn't	O
figure	O
out	O
how	O
to	O
use	O
resample	B-API
to	O
get	O
data	O
starting	O
from	O
2012-01-01	O
as	O
opposed	O
to	O
2012-01-31	O
.	O

Accessing	O
pandas	O
Multiindex	B-API
Dataframe	B-API
using	O
integer	O
indexes	O

No	O
numeric	O
types	O
to	O
aggregate	B-API
-	O
change	O
in	O
groupby()	B-API
behaviour	O
?	O

On	O
0.9	O
,	O
I	O
get	O
No	O
numeric	O
types	O
to	O
aggregate	B-API
errors	O
.	O

I	O
can	O
understand	O
why	O
this	O
might	O
happen	O
,	O
as	O
the	O
weekly	O
dates	O
don't	O
exactly	O
align	B-API
with	O
the	O
monthly	O
dates	O
,	O
and	O
weeks	O
can	O
overlap	O
months	O
.	O

As	O
for	O
the	O
resample	B-API
example	O
given	O
,	O
unfortunately	O
it	O
doesn't	O
return	O
quite	O
what	O
I	O
was	O
looking	O
for	O
.	O

I	O
believe	O
you	O
can	O
use	O
the	O
append	B-API
#CODE	O

Python	O
Pandas	O
:	O
pivot	B-API
table	O
with	O
aggfunc	O
=	O
count	O
unique	O
distinct	O

How	O
do	O
I	O
get	O
a	O
Pivot	B-API
Table	O
with	O
counts	O
of	O
unique	O
values	O
of	O
one	O
DataFrame	B-API
column	O
for	O
two	O
other	O
columns	O
?	O

I	O
am	O
aware	O
of	O
'	O
Series	O
'	O
`	O
values_counts()	O
`	O
however	O
I	O
need	O
a	O
pivot	B-API
table	O
.	O

Note	O
that	O
using	O
`	O
len	B-API
`	O
assumes	O
you	O
don't	O
have	O
`	O
NA	O
`	O
s	O
in	O
your	O
DataFrame	B-API
.	O

You	O
can	O
do	O
`	O
x.value_counts()	O
.count()	B-API
`	O
or	O
`	O
len	B-API
(	O
x.dropna()	O
.unique()	B-API
)`	O
otherwise	O
.	O

You	O
can	O
construct	O
a	O
pivot	B-API
table	O
for	O
each	O
distinct	O
value	O
of	O
`	O
X	O
`	O
.	O

will	O
construct	O
a	O
pivot	B-API
table	O
for	O
each	O
value	O
of	O
`	O
X	O
`	O
.	O

You	O
could	O
also	O
do	O
an	O
inner	O
join	B-API
on	O
stations.id	O
:	O

the	O
merge	B-API
complains	O
that	O
there's	O
'	O
no	O
item	O
named	O
start_station_id	O
'	O
.	O

It	O
was	O
my	O
bad	O
:	O
"	O
on	O
"	O
is	O
only	O
to	O
be	O
used	O
when	O
the	O
columns	O
occur	O
in	O
both	O
DataFrames	O
(	O
so	O
my	O
code	O
was	O
referring	O
to	O
a	O
join	B-API
on	O
both	O
id	O
and	O
start_station_id	O
which	O
is	O
wrong	O
here	O
)	O
.	O

For	O
the	O
reindex	B-API
:	O
non-unique	O
indices	O
are	O
rather	O
new	O
in	O
pandas	O
.	O

I	O
filed	O
an	O
issue	O
because	O
of	O
the	O
reindex	B-API
error	O
:	O
#URL	O

Can	O
you	O
load	O
2	O
separate	O
data	O
frames	O
and	O
do	O
join	B-API
/	O
groupby	B-API
on	O
the	O
datetime	O
?	O

Using	O
the	O
same	O
basic	O
loop	O
as	O
above	O
,	O
just	O
append	B-API
the	O
set	O
of	O
every	O
forth	O
row	O
starting	O
at	O
0	O
to	O
3	O
after	O
you	O
run	O
your	O
code	O
above	O
.	O

If	O
it	O
is	O
just	O
formatting	O
and	O
the	O
time	O
is	O
recorded	O
to	O
a	O
precision	O
that	O
all	O
entries	O
are	O
unique	O
,	O
then	O
stack	B-API
and	O
merge	B-API
would	O
do	O
it	O
.	O

Here	O
is	O
a	O
solution	O
based	O
on	O
numpy's	O
repeat	O
and	O
array	O
indexing	O
to	O
build	O
de-stacked	O
values	O
,	O
and	O
pandas	O
'	O
merge	B-API
to	O
output	O
the	O
concatenated	O
result	O
.	O

Then	O
build	O
a	O
de-stacked	O
vector	O
of	O
TDRs	O
and	O
merge	B-API
it	O
with	O
the	O
original	O
data	O
frame	O
#CODE	O

I	O
have	O
two	O
time	O
series	O
I	O
need	O
to	O
join	B-API
:	O

How	O
do	O
I	O
join	B-API
these	O
time	O
series	O
together	O
in	O
pandas	O
as	O
to	O
express	O
adjusted	O
prices	O
in	O
expression	O
#CODE	O

i	O
had	O
figured	O
out	O
that	O
i	O
need	O
to	O
pivot	B-API
the	O
first	O
point-in-time	O
timeseries	O
for	O
tickers	O
go	O
into	O
the	O
columns	O
and	O
date	O
into	O
rows	O
and	O
for	O
the	O
second	O
timeseries	O
expand	O
the	O
interval	O
into	O
daily	O
granularity	O
and	O
also	O
pivot	B-API
it	O
(	O
through	O
dataframe.pivot	B-API
function	O
.	O
by	O
combining	O
the	O
two	O
dataframes	O
one	O
can	O
write	O
function	O
i	O
need	O
.	O

You	O
can	O
simply	O
join	B-API
the	O
dataFrame	B-API
with	O
your	O
daily	O
bar	O
and	O
use	O
fillna	B-API
(	O
method=	O
"	O
ffill	B-API
")	O
to	O
forward	O
fill	O
the	O
previous	O
value	O
.	O
in	O
your	O
example	O
you	O
have	O
adjustment	O
factors	O
for	O
a	O
range	O
.	O

I	O
was	O
hoping	O
to	O
get	O
this	O
to	O
work	O
but	O
a	O
pyTable	O
table	O
where	O
does	O
not	O
provide	O
a	O
len	B-API

`	O
reindex	B-API
`	O
realigns	O
the	O
existing	O
index	O
to	O
the	O
given	O
index	O
rather	O
than	O
changing	O
the	O
index	O
.	O

If	O
there	O
are	O
no	O
blanks	O
some	O
columns	O
convert	O
to	O
`	O
TRUE	O
/	O
FALSE	O
`	O
,	O
others	O
leave	O
as	O
`	O
Yes	O
/	O
No	O
`	O
but	O
dtype	B-API
is	O
bool	B-API
.	O

`	O
fhs	O
=	O
fhs.drop	O
([	O
1002	O
])`	O
to	O
drop	B-API
that	O
row	O
and	O
data	O
types	O
are	O
still	O
good	O
.	O

first	O
column	O
comes	O
into	O
df	O
as	O
Yes	O
,	O
No	O
,	O
Yes	O
,	O
Yes	O
type	O
bool	B-API
xxxx	O
below	O

3rd	O
column	O
comes	O
into	O
df	O
as	O
FALSE	O
,	O
FALSE	O
,	O
TRUE	O
,	O
TRUE	O
type	O
bool	B-API

first	O
column	O
comes	O
into	O
df	O
as	O
Yes	O
,	O
No	O
,	O
Yes	O
,	O
Yes	O
type	O
bool	B-API
xxxx	O
below	O

3rd	O
column	O
comes	O
into	O
df	O
as	O
FALSE	O
,	O
FALSE	O
,	O
TRUE	O
,	O
TRUE	O
type	O
bool	B-API

The	O
apply	B-API
or	O
transform	B-API
function	O
on	O
a	O
group	O
seems	O
like	O
the	O
right	O
way	O
to	O
go	O
but	O
after	O
hours	O
of	O
trying	O
i	O
still	O
do	O
not	O
succeed	O
.	O

Using	O
the	O
same	O
function	O
with	O
transform	B-API
would	O
work	O
if	O
the	O
'	O
new	O
'	O
column	O
already	O
exists	O
in	O
the	O
df	O
,	O
but	O
how	O
do	O
you	O
add	O
a	O
new	O
column	O
at	O
a	O
specific	O
level	O
'	O
on	O
the	O
fly	O
'	O
or	O
before	O
grouping	O
?	O

Creating	O
a	O
new	O
column	O
based	O
on	O
grouped	O
values	O
is	O
a	O
task	O
for	O
transform	B-API
,	O
but	O
i	O
`	O
m	O
not	O
aware	O
if	O
tranform	O
can	O
output	O
multiple	O
columns	O
.	O

BTW	O
under	O
the	O
hood	O
,	O
transform	B-API
also	O
creates	O
a	O
new	O
frame	O
for	O
each	O
group	O
and	O
concats	O
them	O
all	O
at	O
the	O
end	O
.	O

Having	O
the	O
apply	B-API
/	O
transform	B-API
mechanism	O
be	O
able	O
to	O
output	O
structured	O
values	O
and	O
those	O
broadcast	O
into	O
colums	O
(	O
i.e.	O
if	O
a	O
tuple	O
is	O
produced	O
by	O
the	O
applied	O
function	O
,	O
the	O
components	O
go	O
in	O
separate	O
columns	O
instead	O
of	O
the	O
tuple	O
becoming	O
an	O
atomic	O
element	O
in	O
a	O
single	O
column	O
)	O
would	O
be	O
a	O
fantastic	O
feature	O
,	O
even	O
if	O
it	O
is	O
only	O
syntactic	O
sugar	O
.	O

Probably	O
with	O
another	O
method	O
name	O
,	O
to	O
make	O
intent	O
clear	O
(	O
applyfork	O
or	O
something	O
like	O
that	O
,	O
or	O
a	O
keyword	O
splitseq=True	O
in	O
apply	B-API
)	O
.	O

Pandas	O
DataFrame	B-API
reindex	B-API
column	O
issue	O

I	O
want	O
to	O
reindex	B-API
all	O
the	O
data	O
frames	O
according	O
to	O
totalColumns	O
.	O

So	O
I	O
used	O
the	O
reindex	B-API
method	O
:	O
#CODE	O

If	O
yes	O
,	O
try	O
to	O
resolve	O
that	O
to	O
have	O
unique	O
column	O
names	O
in	O
the	O
two	O
frames	O
,	O
and	O
execute	O
the	O
reindex	B-API
again	O
.	O

How	O
can	O
I	O
join	B-API
the	O
two	O
columns	O
with	O
the	O
same	O
label	O
together	O
and	O
sum	O
up	O
their	O
numbers	O
according	O
to	O
the	O
respective	O
row	O
index	O
?	O

After	O
implementing	O
a	O
custom	O
frequency	O
in	O
pandas	O
by	O
subclassing	O
`	O
DateOffset	O
`	O
,	O
is	O
it	O
possible	O
to	O
"	O
register	O
"	O
an	O
offset	O
alias	O
for	O
that	O
frequency	O
so	O
that	O
the	O
alias	O
can	O
be	O
used	O
in	O
built-in	O
pandas	O
functions	O
such	O
as	O
`	O
date_range	B-API
`	O
and	O
`	O
resample	B-API
`	O
?	O

Given	O
the	O
df	O
below	O
I	O
am	O
trying	O
to	O
do	O
a	O
stack	B-API
bar	O
plot	O
for	O
'	O
stats_value	O
'	O
and	O
'	O
read1_length	O
'	O
v	O
/	O
s	O
'	O
lib_name	O
'	O
.	O

Basically	O
,	O
I	O
want	O
to	O
mimic	O
R's	O
melt	B-API
/	O
cast	O
without	O
getting	O
into	O
hierarchical	O
indexing	O
or	O
stacked	O
dataframes	O
.	O

I	O
can't	O
seem	O
to	O
to	O
get	O
exactly	O
the	O
above	O
playing	O
with	O
stack	B-API
/	O
unstack	B-API
,	O
melt	B-API
,	O
or	O
pivot	B-API
/	O
pivot_table	B-API
--	O
Is	O
there	O
a	O
good	O
way	O
to	O
do	O
this	O
?	O

There	O
is	O
a	O
`	O
melt	B-API
`	O
in	O
`	O
pandas.core.reshape	O
`	O
:	O
#CODE	O

The	O
columns	O
end	O
up	O
being	O
a	O
MultiIndex	B-API
,	O
but	O
if	O
that's	O
a	O
deal	O
breaker	O
for	O
you	O
just	O
concat	B-API
the	O
names	O
and	O
make	O
it	O
a	O
regular	O
Index	O
.	O

How	O
might	O
you	O
concat	B-API
the	O
names	O
,	O
that	O
is	O
where	O
I	O
was	O
confused	O
(	O
"	O
Basically	O
,	O
I	O
want	O
to	O
mimic	O
R's	O
melt	B-API
/	O
cast	O
without	O
getting	O
into	O
hierarchical	O
indexing	O
or	O
stacked	O
dataframes	O
"	O
--	O
so	O
was	O
already	O
aware	O
of	O
this	O
,	O
what	O
I	O
am	O
confused	O
on	O
is	O
how	O
to	O
get	O
this	O
into	O
a	O
flat	O
structure	O
with	O
concatenated	O
column	O
names	O
.	O

Following	O
the	O
official	O
docs	O
you	O
can	O
use	O
loc	B-API
#CODE	O

I	O
have	O
multiple	O
(	O
more	O
than	O
2	O
)	O
dataframes	O
I	O
would	O
like	O
to	O
merge	B-API
.	O

I	O
read	O
that	O
join	B-API
can	O
handle	O
multiple	O
dataframes	O
,	O
however	O
I	O
get	O
:	O
#CODE	O

I	O
have	O
tried	O
passing	O
`	O
rsuffix	O
=[	O
"	O
%i	O
"	O
%	O
(	O
i	O
)	O
for	O
i	O
in	O
range	O
(	O
len	B-API
(	O
data	O
))]`	O
to	O
join	B-API
and	O
still	O
get	O
the	O
same	O
error	O
.	O

I	O
am	O
interested	O
to	O
see	O
if	O
the	O
experts	O
have	O
a	O
more	O
algorithmic	O
approach	O
to	O
merge	B-API
a	O
list	O
of	O
data	O
frames	O
.	O

I	O
would	O
try	O
`	O
pandas.merge	B-API
`	O
instead	O
of	O
`	O
join	B-API
`	O
.	O

The	O
`	O
pandas.concat()	B-API
`	O
solution	O
is	O
_much_	O
better	O
--	O
I	O
thought	O
`	O
concat	B-API
`	O
gave	O
the	O
duplicated	O
column	O
name	O
error	O
when	O
`	O
axis=1	O
`	O
,	O
but	O
I	O
have	O
a	O
lot	O
to	O
learn	O
.	O

As	O
suggested	O
in	O
this	O
post	O
,	O
I'm	O
handling	O
that	O
with	O
a	O
MultiIndex	B-API
.	O

Forcing	O
dates	O
to	O
conform	B-API
to	O
a	O
given	O
frequency	O
in	O
pandas	O

Calculate	O
diff	B-API
of	O
a	O
numpy	O
array	O
using	O
custom	O
function	O
instead	O
of	O
subtraction	O

This	O
would	O
give	O
me	O
either	O
a	O
list	O
of	O
distances	O
with	O
`	O
len	B-API
(	O
distances	O
)	O
==	O
coord_array.shape	O
[	O
1	O
]`	O
,	O
or	O
maybe	O
a	O
third	O
column	O
in	O
the	O
same	O
array	O
.	O

It	O
is	O
important	O
to	O
say	O
that	O
I	O
already	O
have	O
a	O
function	O
that	O
returns	O
a	O
distance	O
between	O
two	O
points	O
(	O
two	O
coordinate	O
pairs	O
)	O
,	O
but	O
I	O
don't	O
know	O
how	O
to	O
apply	B-API
it	O
with	O
a	O
single	O
array	O
operation	O
instead	O
of	O
looping	O
through	O
row	O
pairs	O
.	O

How	O
to	O
shift	B-API
a	O
pandas	O
MultiIndex	B-API
Series	O
?	O

In	O
a	O
regular	O
time	O
series	O
you	O
can	O
shift	B-API
it	O
back	O
or	O
forward	O
in	O
time	O
.	O

We	O
can	O
shift	B-API
it	O
with	O
:	O
#CODE	O

These	O
values	O
are	O
median	B-API
values	O
I	O
calculated	O
from	O
elsewhere	O
,	O
and	O
I	O
have	O
also	O
their	O
variance	O
and	O
standard	O
deviation	O
(	O
and	O
standard	O
error	O
,	O
too	O
)	O
.	O

but	O
not	O
sure	O
how	O
to	O
proceed	O
from	O
here	O
,	O
and	O
how	O
to	O
join	B-API
the	O
new	O
column	O
back	O
to	O
the	O
original	O
data	O
frame	O
.	O

Based	O
on	O
the	O
values	O
in	O
two	O
columns	O
merge	B-API
values	O
in	O
other	O
columns	O

One	O
way	O
I	O
am	O
thinking	O
of	O
is	O
to	O
use	O
nested	O
loops	O
:	O
outer	O
loop	O
read	O
the	O
lines	O
sequentially	O
and	O
the	O
inner	O
loop	O
reads	O
all	O
lines	O
from	O
the	O
begining	O
and	O
look	O
for	O
map	B-API
.	O

All	O
this	O
does	O
is	O
(	O
1	O
)	O
sort	O
the	O
first	O
two	O
columns	O
so	O
that	O
`	O
e	O
c	O
`	O
becomes	O
`	O
c	O
e	O
`	O
,	O
(	O
2	O
)	O
group	O
the	O
terms	O
by	O
`	O
col	O
`	O
and	O
`	O
col	O
2	O
`	O
,	O
and	O
then	O
aggregate	B-API
(	O
`	O
agg	B-API
`)	O
`	O
col3	O
`	O
and	O
`	O
col4	O
`	O
by	O
comma-joining	O
the	O
sorted	O
set	O
of	O
the	O
flattened	O
terms	O
.	O

You	O
can	O
compress	O
to	O
the	O
zlib	O
format	O
instead	O
using	O
`	O
zlib.compress	O
`	O
or	O
`	O
zlib.compressobj	O
`	O
,	O
and	O
then	O
strip	B-API
the	O
zlib	O
header	O
and	O
trailer	O
and	O
add	O
a	O
gzip	O
header	O
and	O
trailer	O
,	O
since	O
both	O
the	O
zlib	O
and	O
gzip	O
formats	O
use	O
the	O
same	O
compressed	O
data	O
format	O
.	O

The	O
zlib	O
header	O
is	O
fixed	O
at	O
two	O
bytes	O
and	O
the	O
trailer	O
at	O
four	O
bytes	O
,	O
so	O
those	O
are	O
easy	O
to	O
strip	B-API
.	O

Then	O
you	O
can	O
prepend	O
a	O
basic	O
gzip	O
header	O
of	O
ten	O
bytes	O
:	O
`"	O
\x1f\x	O
8b	O
\x0	O
8\	O
0\0\0\0\0\0\xff	O
"`	O
(	O
C	O
string	O
format	O
)	O
and	O
append	B-API
a	O
four-byte	O
CRC	O
in	O
little-endian	O
order	O
.	O

I	O
thought	O
that	O
adding	O
a	O
column	O
of	O
row	O
numbers	O
(	O
`	O
df3	O
[	O
'	O
rownum	O
']	O
=	O
range	O
(	O
df3.shape	O
[	O
0	O
])`)	O
would	O
help	O
me	O
select	O
out	O
the	O
bottom-most	O
row	O
for	O
any	O
value	O
of	O
the	O
`	O
DatetimeIndex	B-API
`	O
,	O
but	O
I	O
am	O
stuck	O
on	O
figuring	O
out	O
the	O
`	O
group_by	O
`	O
or	O
`	O
pivot	B-API
`	O
(	O
or	O
???	O
)	O
statements	O
to	O
make	O
that	O
work	O
.	O

Unfortunately	O
,	O
I	O
don't	O
think	O
Pandas	O
allows	O
one	O
to	O
drop	B-API
dups	O
off	O
the	O
indices	O
.	O

If	O
you	O
DO	O
want	O
a	O
copy	O
,	O
you	O
can	O
(	O
in	O
general	O
)	O
use	O
the	O
copy	O
method	O
or	O
,	O
(	O
in	O
this	O
case	O
)	O
use	O
truncate	B-API
:	O
#CODE	O

pandas	O
:	O
apply	B-API
function	O
to	O
DataFrame	B-API
that	O
can	O
return	O
multiple	O
rows	O

I	O
am	O
trying	O
to	O
transform	B-API
DataFrame	B-API
,	O
such	O
that	O
some	O
of	O
the	O
rows	O
will	O
be	O
replicated	O
a	O
given	O
number	O
of	O
times	O
.	O

One	O
possibility	O
might	O
be	O
to	O
allow	O
`	O
DataFrame.applymap	B-API
`	O
function	O
return	O
multiple	O
rows	O
(	O
akin	O
`	O
apply	B-API
`	O
method	O
of	O
`	O
GroupBy	B-API
`)	O
.	O

How	O
I	O
do	O
find	O
median	B-API
using	O
pandas	O
on	O
a	O
dataset	O
?	O

You	O
could	O
try	O
applying	O
your	O
own	O
median	B-API
function	O
to	O
see	O
if	O
you	O
can	O
work	O
around	O
the	O
cause	O
of	O
the	O
error	O
,	O
something	O
like	O
:	O
#CODE	O

Here	O
is	O
a	O
different	O
approach	O
,	O
you	O
can	O
add	O
the	O
median	B-API
back	O
to	O
your	O
original	O
dataframe	B-API
,	O
the	O
median	B-API
for	O
the	O
metric	O
column	O
becomes	O
:	O
#CODE	O

Wether	O
its	O
useful	O
to	O
have	O
the	O
median	B-API
of	O
the	O
group	O
attached	O
to	O
each	O
datapoint	O
depends	O
a	O
bit	O
what	O
you	O
want	O
to	O
do	O
afterwards	O
.	O

I	O
created	O
a	O
DatetimeIndex	B-API
and	O
I	O
want	O
to	O
resample	B-API
the	O
data	O
with	O
that	O
index	O
.	O

Any	O
idea	O
how	O
to	O
resample	B-API
by	O
an	O
index	O
?	O

AFAIK	O
you	O
cannot	O
pass	O
in	O
a	O
DatetimeIndex	B-API
to	O
resample	B-API
.	O

As	O
a	O
workaround	O
,	O
just	O
resample	B-API
by	O
the	O
freq	B-API
alias	O
(	O
'	O
1Min	O
')	O
and	O
then	O
reindex	B-API
to	O
your	O
generated	O
index	O
?	O

I	O
started	O
a	O
github	O
issue	O
to	O
maybe	O
think	O
about	O
adding	O
in	O
additional	O
parameters	O
to	O
resample	B-API
.	O

Wes	O
replied	O
saying	O
he	O
plans	O
to	O
extend	O
`	O
resample	B-API
`	O
like	O
this	O
eventually	O
.	O

Is	O
there	O
any	O
work	O
around	O
I	O
could	O
apply	B-API
before	O
it	O
is	O
fixed	O
?	O

Or	O
use	O
a	O
boolean	O
mask	B-API
:	O
data.A	O
[	O
data.index.get_level_values	O
(	O
1	O
)	O
==	O
2	O
]	O
=	O
0	O

I've	O
played	O
around	O
with	O
groupby	B-API
and	O
transpose	B-API
to	O
no	O
avail	O
,	O
any	O
tips	O
would	O
be	O
great	O
appreciated	O
.	O

I	O
suppose	O
I	O
could	O
loop	O
through	O
and	O
append	B-API
to	O
the	O
DataFrame	B-API
,	O
however	O
I	O
feel	O
like	O
there	O
should	O
be	O
a	O
much	O
smarter	O
method	O
to	O
doing	O
this	O
.	O

You	O
can	O
use	O
the	O
`	O
pivot	B-API
`	O
function	O
:	O
#CODE	O

Could	O
you	O
upload	O
an	O
example	O
of	O
when	O
it	O
saves	O
with	O
the	O
graph	O
cut	B-API
off	O
?	O

Merge	B-API
Columns	O
within	O
a	O
DataFrame	B-API
that	O
have	O
the	O
Same	O
Name	O

How	O
do	O
I	O
stack	B-API
two	O
DataFrames	O
next	O
to	O
each	O
other	O
in	O
Pandas	O
?	O

and	O
I	O
would	O
like	O
to	O
stack	B-API
them	O
next	O
two	O
each	O
other	O
in	O
a	O
single	O
DataFrame	B-API
so	O
I	O
can	O
access	O
and	O
compare	O
columns	O
(	O
e.g.	O
High	O
)	O
across	O
stocks	O
(	O
GOOG	O
vs	O
.	O
AAPL	O
)	O
?	O

Have	O
a	O
look	O
at	O
the	O
`	O
join	B-API
`	O
method	O
of	O
dataframes	O
,	O
use	O
the	O
`	O
lsuffix	O
`	O
and	O
`	O
rsuffix	O
`	O
attributes	O
to	O
create	O
new	O
names	O
for	O
the	O
joined	O
columns	O
.	O

And	O
I	O
want	O
to	O
do	O
a	O
rolling	B-API
average	O
for	O
all	O
columns	O
,	O
after	O
groupby	B-API
`	O
STK_ID	O
`	O
,	O
the	O
rule	O
expressed	O
by	O
pseudocode	O
like	O
:	O
#CODE	O

not	O
exactly	O
as	O
expanding_mean()	B-API
,	O
for	O
the	O
rolling	B-API
window	O
depends	O
on	O
the	O
RPT_Date	O
and	O
is	O
range	O
from	O
2-5	O
periodically	O
.	O

I	O
notice	O
Pandas	O
can	O
apply	B-API
different	O
function	O
to	O
different	O
column	O
by	O
passing	O
a	O
dict	O
.	O

But	O
I	O
have	O
a	O
long	O
column	O
list	O
and	O
just	O
want	O
parameters	O
to	O
set	O
or	O
tip	O
to	O
simply	O
tell	O
Pandas	O
to	O
bypass	O
some	O
columns	O
and	O
apply	B-API
`	O
my_func()	O
`	O
to	O
rest	O
of	O
columns	O
?	O

One	O
simple	O
(	O
and	O
general	O
)	O
approach	O
is	O
to	O
create	O
a	O
view	O
of	O
the	O
dataframe	B-API
with	O
the	O
subset	O
you	O
are	O
interested	O
in	O
(	O
or	O
,	O
stated	O
for	O
your	O
case	O
,	O
a	O
view	O
with	O
all	O
columns	O
except	O
the	O
ones	O
you	O
want	O
to	O
ignore	O
)	O
,	O
and	O
then	O
use	O
APPLY	B-API
for	O
that	O
view	O
.	O

I	O
believe	O
the	O
appropriate	O
way	O
is	O
to	O
write	O
a	O
function	O
that	O
takes	O
the	O
current	O
row	O
,	O
then	O
figures	O
out	O
the	O
previous	O
row	O
,	O
and	O
calculates	O
the	O
difference	O
between	O
them	O
,	O
the	O
use	O
the	O
`	O
pandas	O
`	O
`	O
apply	B-API
`	O
function	O
to	O
update	O
the	O
dataframe	B-API
with	O
the	O
value	O
.	O

i.e.	O
instead	O
of	O
diff	B-API
(	O
1	O
)	O
is	O
there	O
something	O
like	O
value	O
(	O
1	O
)	O
or	O
value	O
(	O
1:3	O
)	O
.mean()	B-API
.	O

To	O
get	O
the	O
ultimate	O
perf	O
you'd	O
want	O
to	O
drop	B-API
down	O
into	O
C	O
or	O
Cython	O
and	O
build	O
the	O
raw	O
byte	O
string	O
yourself	O
using	O
C	O
string	O
functions	O
.	O

How	O
to	O
apply	B-API
condition	O
on	O
level	O
of	O
pandas.multiindex	B-API
?	O

I.e.	O
,	O
I	O
would	O
like	O
to	O
apply	B-API
np.mean	O
over	O
all	O
counts	O
of	O
the	O
detectors	O
of	O
1	O
channel	O
at	O
each	O
time	O
separately	O
.	O

Other	O
aggregation	O
functions	O
can	O
be	O
passed	O
via	O
`	O
agg	B-API
`	O
:	O
#CODE	O

Be	O
carefull	O
with	O
floats	O
groupby	B-API
(	O
this	O
is	O
independent	O
of	O
a	O
MultiIndex	B-API
or	O
not	O
)	O
,	O
groups	O
can	O
differ	O
due	O
to	O
numerical	O
representation	O
/	O
accuracy-limitations	O
related	O
to	O
floats	O
.	O

(	O
after	O
diving	O
in	O
Pandas	O
doc	O
,	O
I	O
think	O
`	O
cut	B-API
`	O
function	O
can	O
help	O
me	O
because	O
it's	O
a	O
discretization	O
problem	O
...	O
but	O
I'm	O
don't	O
understand	O
how	O
to	O
use	O
it	O
)	O

to	O
plot	O
the	O
results	O
you	O
can	O
use	O
the	O
matplotlib	O
function	O
hist	B-API
,	O
but	O
if	O
you	O
are	O
working	O
in	O
pandas	O
each	O
Series	O
has	O
its	O
own	O
handle	O
to	O
the	O
hist	B-API
function	O
,	O
and	O
you	O
can	O
give	O
it	O
the	O
chosen	O
binning	O
:	O
#CODE	O

In	O
the	O
specific	O
case	O
of	O
applying	O
a	O
`	O
diff	B-API
`	O
function	O
that	O
could	O
be	O
vectorized	O
(	O
applied	O
like	O
an	O
array	O
operation	O
instead	O
of	O
an	O
iterative	O
pairwise	O
loop	O
)	O
,	O
is	O
there	O
a	O
way	O
to	O
do	O
that	O
idiomatically	O
in	O
pandas	O
?	O

Should	O
I	O
create	O
a	O
"	O
coordinate	O
"	O
class	O
which	O
support	O
the	O
diff	B-API
(	O
`	O
__sub__	O
`)	O
operation	O
so	O
I	O
could	O
use	O
`	O
dataframe.latlng.diff	O
`	O
directly	O
?	O

As	O
a	O
follow-up	O
question	O
,	O
how	O
would	O
you	O
go	O
about	O
to	O
apply	B-API
the	O
same	O
function	O
on	O
groups	O
?	O

I	O
suspect	O
that	O
I	O
need	O
to	O
use	O
searchsort	O
and	O
asof	B-API
,	O
but	O
I	O
am	O
not	O
quite	O
sure	O
how	O
to	O
do	O
that	O
with	O
.	O

You're	O
looking	O
for	O
a	O
near	O
timestamp	O
,	O
where	O
`	O
asof	B-API
`	O
searches	O
for	O
the	O
latest	O
timestamp	O
.	O

It	O
is	O
only	O
applied	O
to	O
a	O
time	O
series	O
,	O
so	O
you	O
would	O
have	O
to	O
apply	B-API
`	O
reset_index	B-API
`	O
to	O
your	O
`	O
DataFrame	B-API
`	O

This	O
can	O
be	O
accomplished	O
quite	O
simply	O
with	O
the	O
DataFrame	B-API
method	O
`	O
apply	B-API
`	O
.	O

Now	O
that	O
we	O
have	O
our	O
`	O
DataFrame	B-API
`	O
and	O
`	O
Series	B-API
`	O
we	O
need	O
a	O
function	O
to	O
pass	O
to	O
`	O
apply	B-API
`	O
.	O

`	O
df.apply	B-API
`	O
acts	O
column-wise	O
by	O
default	O
,	O
but	O
it	O
can	O
can	O
also	O
act	O
row-wise	O
by	O
passing	O
`	O
axis=1	O
`	O
as	O
an	O
argument	O
to	O
`	O
apply	B-API
`	O
.	O

This	O
could	O
be	O
done	O
more	O
concisely	O
by	O
defining	O
the	O
anonymous	O
function	O
inside	O
`	O
apply	B-API
`	O
#CODE	O

In	O
case	O
of	O
a	O
multicolumn	O
groupby	B-API
these	O
subgroups	O
refer	O
to	O
several	O
columns	O
,	O
but	O
this	O
is	O
irrelevant	O
as	O
`	O
len	B-API
`	O
counts	O
by	O
the	O
rows	O
in	O
pandas	O
objects	O
.	O

to	O
find	O
a	O
way	O
to	O
group	O
the	O
data	O
in	O
a	O
way	O
that	O
I	O
can	O
aggregate	B-API
the	O
time	O
column	O
`	O
D_Time	O
`	O

Most	O
efficient	O
way	O
to	O
shift	B-API
MultiIndex	B-API
time	O
series	O

I	O
would	O
suggest	O
you	O
reshape	O
the	O
data	O
and	O
do	O
a	O
single	O
shift	B-API
versus	O
the	O
groupby	B-API
approach	O
:	O
#CODE	O

You	O
can	O
verify	O
it's	O
been	O
lagged	O
by	O
one	O
period	O
(	O
you	O
want	O
shift	B-API
(	O
1	O
)	O
instead	O
of	O
shift	B-API
(	O
-1	O
)):	O
#CODE	O

(	O
And	O
I	O
did	O
mean	O
shift	B-API
(	O
-1	O
);	O
it's	O
a	O
hazard	O
rate	O
calculation	O
,	O
so	O
it's	O
forward-looking	O
.	O
)	O

How	O
do	O
I	O
resample	B-API
/	O
align	B-API
a	O
pandas	O
timeseries	O
to	O
the	O
closest	O
calendar	O
quarters	O
?	O

Also	O
,	O
is	O
there	O
any	O
way	O
I	O
can	O
get	O
it	O
to	O
align	B-API
to	O
Dec	O
/	O
Mar	O
(	O
which	O
seem	O
to	O
be	O
closer	O
to	O
the	O
original	O
dates	O
)	O
with	O
the	O
timeseries	O
functions	O
?	O

I	O
know	O
no	O
easy	O
solution	O
to	O
get	O
to	O
align	B-API
to	O
the	O
closest	O
and	O
I	O
find	O
the	O
current	O
version	O
quite	O
logical	O
.	O

But	O
with	O
`	O
label=	O
'	O
left	O
'`	O
you	O
can	O
achieve	O
what	O
you	O
want	O
with	O
the	O
current	O
data	O
,	O
still	O
it	O
doesn't	O
align	B-API
to	O
the	O
closest	O
,	O
so	O
overall	O
you	O
probably	O
have	O
to	O
figure	O
out	O
something	O
else	O
(	O
like	O
using	O
apply	B-API
to	O
change	O
the	O
dates	O
so	O
they	O
would	O
conform	B-API
as	O
you	O
wish	O
)	O
.	O

`	O
lambda	O
L	O
:	O
L.split	O
(	O
'	O
,	O
')`	O
-	O
not	O
join	B-API
again	O
...	O

I	O
rewrote	O
the	O
answer	O
to	O
remove	O
the	O
map	B-API
function	O
as	O
it	O
was	O
more	O
confusing	O
than	O
helpful	O
.	O
thank	O
you	O
for	O
your	O
answer	O

Using	O
resample	B-API
to	O
align	B-API
multiple	O
timeseries	O
in	O
pandas	O

The	O
goal	O
is	O
to	O
align	B-API
the	O
data	O
to	O
calendar	O
quarter	O
markers	O
so	O
the	O
3	O
data	O
sets	O
can	O
be	O
compared	O
.	O

just	O
edited	O
the	O
question	O
and	O
added	O
desired	O
final	O
output	O
.	O
the	O
goal	O
(	O
if	O
it	O
doesn't	O
go	O
without	O
saying	O
)	O
is	O
to	O
get	O
this	O
programmatically	O
,	O
so	O
adjusting	O
different	O
resample	B-API
params	O
for	O
each	O
series	O
in	O
some	O
non-automatically	O
detectable	O
way	O
is	O
unfortunately	O
not	O
helpful	O

To	O
get	O
the	O
dtypes	B-API
we'd	O
need	O
to	O
transform	B-API
this	O
ndarray	O
into	O
a	O
structured	O
array	O
using	O
view	O
:	O
#CODE	O

The	O
above	O
gives	O
me	O
what	O
I	O
want	O
,	O
aggregate	B-API
stats	O
on	O
julian	O
day	O
of	O
the	O
year	O
BUT	O
I	O
would	O
then	O
like	O
to	O
reorder	O
the	O
group	O
so	O
the	O
last	O
half	O
(	O
183	O
days	O
)	O
is	O
placed	O
in	O
front	O
of	O
the	O
1st	O
half	O
.	O

Why	O
not	O
just	O
reindex	B-API
the	O
result	O
?	O

I	O
think	O
the	O
easiest	O
way	O
to	O
do	O
this	O
is	O
to	O
`	O
join	B-API
`	O
on	O
index	O
.	O

I've	O
got	O
some	O
radar	O
data	O
that's	O
in	O
a	O
bit	O
of	O
an	O
odd	O
format	O
,	O
and	O
I	O
can't	O
figure	O
out	O
how	O
to	O
correctly	O
pivot	B-API
it	O
using	O
the	O
pandas	O
library	O
.	O

Note	O
that	O
I	O
did	O
not	O
set	O
`	O
loc	B-API
`	O
as	O
the	O
index	O
yet	O
so	O
it	O
uses	O
an	O
autoincrement	O
integer	O
index	O
.	O

However	O
,	O
if	O
your	O
data	O
frame	O
is	O
already	O
using	O
`	O
loc	B-API
`	O
as	O
the	O
index	O
,	O
we	O
will	O
need	O
to	O
append	B-API
the	O
`	O
time	B-API
`	O
column	O
into	O
it	O
so	O
that	O
we	O
have	O
a	O
loc-time	O
hierarchal	O
index	O
.	O

This	O
can	O
be	O
done	O
using	O
the	O
new	O
`	O
append	B-API
`	O
option	O
in	O
the	O
`	O
set_index	B-API
`	O
method	O
.	O

So	O
I	O
edited	O
my	O
answer	O
to	O
suggest	O
that	O
you	O
use	O
the	O
`	O
append=True	O
`	O
option	O
while	O
adding	O
'	O
time	O
'	O
into	O
your	O
existing	O
'	O
loc	B-API
'	O
index	O
.	O

Now	O
to	O
extract	O
a	O
specific	O
Series	O
by	O
the	O
`	O
loc	B-API
`	O
,	O
since	O
`	O
loc	B-API
`	O
is	O
an	O
index	O
in	O
`	O
df_by_speed	O
`	O
,	O
it	O
is	O
as	O
simple	O
as	O
`	O
df_by_speed.ix	O
[	O
'	O
A	O
']`	O
where	O
A	O
is	O
the	O
location	O
name	O
.	O

You	O
can	O
use	O
the	O
pivot	B-API
method	O
here	O
:	O
#CODE	O

If	O
I	O
transpose	B-API
the	O
input	O
to	O
model.predict	O
,	O
I	O
do	O
get	O
a	O
result	O
but	O
with	O
a	O
shape	O
of	O
(	O
426,213	O
)	O
,	O
so	O
I	O
suppose	O
its	O
wrong	O
as	O
well	O
(	O
I	O
expect	O
one	O
vector	O
of	O
213	O
numbers	O
as	O
label	O
predictions	O
):	O
#CODE	O

I	O
tried	O
the	O
separate	O
date	O
and	O
time	O
route	O
,	O
and	O
created	O
a	O
multiindex	B-API
,	O
but	O
when	O
I	O
did	O
,	O
I	O
ended	O
up	O
with	O
two	O
index	O
columns	O
--	O
one	O
of	O
them	O
containing	O
the	O
proper	O
date	O
with	O
an	O
incorrect	O
time	O
instead	O
of	O
just	O
a	O
date	O
,	O
and	O
the	O
second	O
one	O
containing	O
an	O
incorrect	O
date	O
,	O
and	O
then	O
a	O
correct	O
time	O
,	O
instead	O
of	O
just	O
a	O
time	O
.	O

The	O
input	O
data	O
for	O
my	O
multiindex	B-API
attempt	O
looked	O
like	O
this	O
:	O
#CODE	O

Maybe	O
the	O
multiindex	B-API
approach	O
is	O
totally	O
wrong	O
,	O
but	O
it's	O
one	O
thing	O
I	O
tried	O
.	O

GroupBy	B-API
objects	O
also	O
have	O
an	O
apply	B-API
method	O
,	O
which	O
is	O
basically	O
syntactic	O
sugar	O
around	O
the	O
"	O
combine	O
"	O
step	O
done	O
with	O
pd.concat()	B-API
above	O
.	O

Benefits	O
of	O
panda's	O
multiindex	B-API
?	O

I	O
found	O
a	O
way	O
using	O
`	O
join	B-API
`	O
:	O
#CODE	O

This	O
is	O
not	O
so	O
direct	O
but	O
I	O
found	O
it	O
very	O
intuitive	O
(	O
the	O
use	O
of	O
map	B-API
to	O
create	O
new	O
columns	O
from	O
another	O
column	O
)	O
and	O
can	O
be	O
applied	O
to	O
many	O
other	O
cases	O
:	O
#CODE	O

Thanks	O
,	O
the	O
map	B-API
method	O
seems	O
pretty	O
powerful	O
.	O

I	O
would	O
like	O
to	O
apply	B-API
a	O
function	O
to	O
a	O
dataframe	B-API
and	O
receive	O
a	O
single	O
dictionary	O
as	O
a	O
result	O
.	O
pandas.apply	O
gives	O
me	O
a	O
Series	O
of	O
dicts	O
,	O
and	O
so	O
currently	O
I	O
have	O
to	O
combine	O
keys	O
from	O
each	O
.	O

I	O
had	O
overlooked	O
`	O
map	B-API
`	O
completely	O
,	O
and	O
my	O
rewritten	O
function	O
is	O
much	O
cleaner	O
now	O
.	O

pandas	O
pivot	B-API
dataframe	B-API
to	O
3d	O
data	O

There	O
seem	O
to	O
be	O
a	O
lot	O
of	O
possibilities	O
to	O
pivot	B-API
flat	O
table	O
data	O
into	O
a	O
3d	O
array	O
but	O
I'm	O
somehow	O
not	O
finding	O
one	O
that	O
works	O
:	O
Suppose	O
I	O
have	O
some	O
data	O
with	O
columns	O
=[	O
'	O
name	O
'	O
,	O
'	O
type	O
'	O
,	O
'	O
date	O
'	O
,	O
'	O
value	O
']	O
.	O

When	O
I	O
try	O
to	O
pivot	B-API
via	O
#CODE	O

`	O
pivot	B-API
`	O
only	O
supports	O
using	O
a	O
single	O
column	O
to	O
generate	O
your	O
columns	O
.	O

You	O
probably	O
want	O
to	O
use	O
`	O
pivot_table	B-API
`	O
to	O
generate	O
a	O
pivot	B-API
table	O
using	O
multiple	O
columns	O
e.g.	O
#CODE	O

The	O
hierarchical	O
columns	O
that	O
are	O
mentioned	O
in	O
the	O
API	O
reference	O
and	O
documentation	O
for	O
`	O
pivot	B-API
`	O
relates	O
to	O
cases	O
where	O
you	O
have	O
multiple	O
value	O
fields	O
rather	O
than	O
multiple	O
categories	O
.	O

However	O
,	O
if	O
you	O
want	O
separate	O
columns	O
for	O
different	O
value	O
fields	O
for	O
the	O
same	O
category	O
(	O
e.g.	O
'	O
type	O
')	O
,	O
then	O
you	O
should	O
use	O
`	O
pivot	B-API
`	O
without	O
specifying	O
the	O
value	O
column	O
and	O
your	O
category	O
as	O
the	O
columns	O
parameter	O
.	O

Thanks	O
,	O
I	O
guess	O
the	O
pandas	O
philosophy	O
is	O
that	O
you	O
should	O
probably	O
work	O
with	O
your	O
3d	O
data	O
in	O
a	O
2d	O
multiindex	B-API
array	O
...	O
probably	O
not	O
a	O
bad	O
idea	O
once	O
you	O
get	O
used	O
to	O
indexing	O
and	O
slicing	O
on	O
multiindexes	O
.	O

it	O
is	O
probably	O
more	O
intuitive	O
/	O
readable	O
to	O
stick	O
to	O
using	O
stack	B-API
/	O
unstacks	O
and	O
groupby	B-API
as	O
in	O
the	O
other	O
solution	O
below	O
.	O

`	O
pandas.append()	O
`	O
(	O
or	O
`	O
concat()	B-API
`	O
method	O
)	O
can	O
only	O
append	B-API
correctly	O
if	O
you	O
have	O
unique	O
column	O
names	O
.	O

However	O
,	O
my	O
goal	O
is	O
to	O
be	O
able	O
to	O
use	O
a	O
row-wise	O
function	O
in	O
the	O
`	O
DataFrame.apply()	B-API
`	O
method	O
(	O
so	O
I	O
can	O
apply	B-API
the	O
desired	O
functionality	O
to	O
other	O
functions	O
I	O
build	O
)	O
.	O

Row-wise	O
functionality	O
should	O
be	O
possible	O
with	O
apply	B-API
.	O

If	O
you	O
have	O
a	O
key	O
that	O
is	O
repeated	O
for	O
each	O
row	O
,	O
then	O
you	O
can	O
produce	O
a	O
cartesian	O
product	O
using	O
merge	B-API
(	O
like	O
you	O
would	O
in	O
SQL	O
)	O
.	O

This	O
won't	O
win	O
a	O
code	O
golf	O
competition	O
,	O
and	O
borrows	O
from	O
the	O
previous	O
answers	O
-	O
but	O
clearly	O
shows	O
how	O
the	O
key	O
is	O
added	O
,	O
and	O
how	O
the	O
join	B-API
works	O
.	O

So	O
,	O
I	O
created	O
a	O
list	O
of	O
all	O
the	O
weeks	O
I	O
wanted	O
to	O
have	O
,	O
then	O
a	O
list	O
of	O
all	O
the	O
store	O
IDs	O
I	O
wanted	O
to	O
map	B-API
them	O
against	O
.	O

The	O
merge	B-API
I	O
chose	O
left	O
,	O
but	O
would	O
be	O
semantically	O
the	O
same	O
as	O
inner	O
in	O
this	O
setup	O
.	O

`	O
combine_first	B-API
`	O
is	O
not	O
actually	O
an	O
`	O
append	B-API
`	O
operation	O
.	O

while	O
`	O
append	B-API
`	O
is	O
#URL	O

What	O
would	O
be	O
a	O
way	O
to	O
read	O
this	O
file	O
and	O
align	B-API
the	O
date	O
/	O
values	O
?	O

Just	O
replace	B-API
`'	O
/	O
Users	O
/	O
spencerlyon2	O
/	O
Desktop	O
/	O
test.csv	O
'`	O
with	O
the	O
path	O
to	O
your	O
file	O

How	O
can	O
I	O
replace	B-API
all	O
the	O
NaN	O
values	O
with	O
Zero's	O
in	O
a	O
column	O
of	O
a	O
pandas	O
dataframe	B-API

I	O
have	O
also	O
looked	O
at	O
this	O
article	O
How	O
do	O
I	O
replace	B-API
NA	O
values	O
with	O
zeros	O
in	O
R	O
?	O

Also	O
,	O
this	O
is	O
a	O
complex	O
example	O
(	O
though	O
I	O
really	O
ran	O
into	O
it	O
)	O
,	O
but	O
the	O
same	O
may	O
apply	B-API
to	O
fewer	O
levels	O
of	O
indexes	O
depending	O
on	O
how	O
you	O
slice	O
.	O

It's	O
one	O
line	O
,	O
reads	O
reasonably	O
well	O
(	O
sort	O
of	O
)	O
and	O
eliminates	O
any	O
unnecessary	O
messing	O
with	O
intermediate	O
variables	O
or	O
loops	O
while	O
allowing	O
you	O
to	O
apply	B-API
fillna	B-API
to	O
any	O
multi-level	O
slice	O
you	O
like	O
!	O

Merge	B-API
parameters	O
for	O
Pandas	O

I	O
have	O
a	O
loop	O
in	O
Python	O
which	O
sequentially	O
imports	O
CSV	O
files	O
,	O
assigns	O
them	O
to	O
a	O
temporary	O
DataFrame	B-API
object	O
and	O
then	O
attempts	O
to	O
merge	B-API
/	O
concact	O
them	O
to	O
a	O
'	O
master	O
'	O
DataFrame	B-API
.	O

The	O
MLS_Stats	O
DF	O
is	O
initially	O
empty	O
,	O
which	O
is	O
the	O
reasoning	O
for	O
the	O
if	O
loop	O
,	O
since	O
I	O
don't	O
think	O
you	O
can	O
merge	B-API
a	O
DF	O
with	O
an	O
empty	O
DF	O
.	O

For	O
each	O
merge	B-API
,	O
I	O
want	O
build	O
the	O
DataFrame	B-API
by	O
including	O
any	O
new	O
uniquely	O
indexed	O
rows	O
and	O
new	O
columns	O
,	O
but	O
exclude	O
overlapping	O
columns	O
.	O

You	O
can	O
filter	O
duplicate	O
rows	O
with	O
`	O
drop_duplicates	B-API
`	O
,	O
and	O
select	O
to	O
join	B-API
only	O
columns	O
that	O
are	O
not	O
yet	O
present	O
.	O

You	O
can	O
use	O
the	O
append	B-API
function	O
to	O
add	O
another	O
element	O
to	O
it	O
.	O

Only	O
,	O
make	O
a	O
series	O
of	O
the	O
new	O
element	O
,	O
before	O
you	O
append	B-API
it	O
:	O
#CODE	O

I	O
believe	O
append	B-API
returns	O
a	O
new	O
Series	O
(	O
rather	O
than	O
doing	O
it	O
in	O
place	O
)	O
so	O
you	O
want	O
`	O
test	O
=	O
test.append	O
(	O
pd.Series	B-API
(	O
200	O
,	O
index	O
=[	O
101	O
]))`	O

How	O
to	O
apply	B-API
a	O
function	O
to	O
two	O
columns	O
of	O
Pandas	O
dataframe	B-API

Now	O
I	O
want	O
to	O
apply	B-API
the	O
`	O
f	O
`	O
to	O
`	O
df	O
`'	O
s	O
two	O
columns	O
`'	O
col_1	O
'	O
,	O
'	O
col_2	O
'`	O
to	O
element-wise	O
calculate	O
a	O
new	O
column	O
`'	O
col_3	O
'`	O
,	O
somewhat	O
like	O
:	O
#CODE	O

can	O
you	O
apply	B-API
f	O
directly	O
to	O
columns	O
:	O
df	O
[	O
'	O
col_3	O
']	O
=	O
f	O
(	O
df	O
[	O
'	O
col_1	O
']	O
,	O
df	O
[	O
'	O
col_2	O
'])	O

Here's	O
an	O
example	O
using	O
`	O
apply	B-API
`	O
on	O
the	O
dataframe	B-API
,	O
which	O
I	O
am	O
calling	O
with	O
`	O
axis	O
=	O
1	O
`	O
.	O

Depending	O
on	O
your	O
use	O
case	O
,	O
it	O
is	O
sometimes	O
helpful	O
to	O
create	O
a	O
pandas	O
`	O
group	O
`	O
object	O
,	O
and	O
then	O
use	O
`	O
apply	B-API
`	O
on	O
the	O
group	O
.	O

Yes	O
,	O
i	O
tried	O
to	O
use	O
apply	B-API
,	O
but	O
can't	O
find	O
the	O
valid	O
syntax	O
expression	O
.	O

How	O
to	O
use	O
Pandas	O
'	O
apply	B-API
'	O
function	O
to	O
create	O
'	O
col_3	O
'	O
?	O

Use	O
apply	B-API
on	O
the	O
whole	O
dataframe	B-API
,	O
passing	O
in	O
rows	O
with	O
df.apply	B-API
(	O
f	O
,	O
axis=1	O
)	O
.	O

Since	O
you	O
haven't	O
provided	O
the	O
body	O
of	O
f	O
I	O
can't	O
help	O
in	O
anymore	O
detail	O
-	O
but	O
this	O
should	O
provide	O
the	O
way	O
out	O
without	O
fundamentally	O
changing	O
your	O
code	O
or	O
using	O
some	O
other	O
methods	O
rather	O
than	O
apply	B-API

pandas's	O
resample	B-API
with	O
fill_method	O
:	O
Need	O
to	O
know	O
data	O
from	O
which	O
row	O
was	O
copied	O
?	O

I	O
am	O
trying	O
to	O
use	O
resample	B-API
method	O
to	O
fill	O
the	O
gaps	O
in	O
timeseries	O
data	O
.	O

With	O
resample	B-API
,	O
I	O
will	O
get	O
this	O
#CODE	O

align	B-API
edge	O
(	O
default	O
)	O
|	O
center	O

For	O
vertical	O
bars	O
,	O
align	B-API
=	O
edge	O
aligns	O
bars	O
by	O
their	O
left	O
edges	O
in	O
left	O
,	O
while	O
align	B-API
=	O
center	O
interprets	O
these	O
values	O
as	O
the	O
x	O
coordinates	O
of	O
the	O
bar	O
centers	O
.	O

So	O
adding	O
try	O
adding	O
the	O
keyword	O
align	B-API
=	O
'	O
center	O
'	O
to	O
you	O
first	O
plot	O
call	O
and	O
that	O
might	O
get	O
aligned	O
your	O
x-axis	O
.	O

As	O
a	O
work-around	O
,	O
I'm	O
probably	O
going	O
to	O
simply	O
import	O
from	O
my	O
target	O
sql	O
and	O
do	O
a	O
join	B-API
.	O

Understanding	O
`	O
MultiIndex	B-API
`	O
dataframes	O
in	O
pandas	O
-	O
understanding	O
MultiIndex	B-API
and	O
Benefits	O
of	O
pandas	O
multiindex	B-API
?	O

If	O
I	O
`	O
reset_index	B-API
`	O
on	O
both	O
frames	O
I	O
can	O
now	O
merge	B-API
/	O
join	B-API
them	O
and	O
slice	O
however	O
I	O
want	O
,	O
but	O
how	O
can	O
I	O
do	O
it	O
using	O
the	O
(	O
multi	O
)	O
indexes	O
?	O

Note	O
that	O
you	O
can	O
use	O
xs	B-API
on	O
a	O
multiindex	B-API
.	O

My	O
approach	O
was	O
to	O
groupby	B-API
'	O
file	O
'	O
and	O
then	O
aggregate	B-API
on	O
'	O
first	O
'	O
:	O
#CODE	O

I	O
convert	O
this	O
to	O
a	O
sparse	O
series	O
/	O
dataframe	B-API
with	O
censored	O
observations	O
that	O
I	O
would	O
like	O
to	O
join	B-API
or	O
convert	O
to	O
a	O
series	O
/	O
dataframe	B-API
with	O
continuous	O
dates	O
.	O

I	O
feel	O
as	O
though	O
I'm	O
missing	O
a	O
more	O
elegant	O
solution	O
involving	O
a	O
join	B-API
.	O

You	O
can	O
just	O
use	O
reindex	B-API
on	O
a	O
time	O
series	O
using	O
your	O
date	O
range	O
.	O

I	O
used	O
`	O
loffset=	O
'	O
-1M	O
'`	O
to	O
tell	O
pandas	O
to	O
aggregate	B-API
one	O
period	O
earlier	O
than	O
its	O
default	O
(	O
moved	O
us	O
to	O
Jan-Jun	O
)	O
.	O

Assuming	O
you	O
had	O
a	O
`	O
DateTimeIndex	B-API
`	O
with	O
regular	O
frequency	O
you	O
could	O
always	O
use	O
`	O
df.resample	B-API
`	O
to	O
aggregate	B-API
the	O
data	O
at	O
another	O
regular	O
frequency	O
(	O
like	O
every	O
two	O
months	O
)	O
and	O
then	O
use	O
`	O
df.pct_change()	B-API
`	O
to	O
get	O
the	O
returns	O
.	O

Also	O
there	O
are	O
various	O
options	O
for	O
`	O
pct_change()	B-API
`	O
[	O
see	O
`	O
periods	O
`	O
,	O
`	O
freq	B-API
`]	O
that	O
allow	O
you	O
to	O
specify	O
how	O
many	O
data	O
points	O
should	O
be	O
used	O
to	O
compute	O
the	O
returns	O
(	O
`	O
periods	O
`	O
defaults	O
to	O
1	O
,	O
which	O
is	O
why	O
the	O
solution	O
gave	O
the	O
same	O
answer	O
as	O
your	O
function	O
)	O
.	O

You	O
might	O
also	O
want	O
to	O
looking	O
into	O
the	O
rolling	B-API
and	O
window	O
functions	O
for	O
other	O
types	O
of	O
analysis	O
of	O
financial	O
data	O
.	O

Because	O
you	O
have	O
a	O
relatively	O
small	O
data	O
set	O
,	O
the	O
easiest	O
way	O
is	O
to	O
resample	B-API
on	O
the	O
parameters	O
that	O
you	O
need	O
to	O
calculate	O
the	O
data	O
on	O
then	O
use	O
the	O
`	O
pct_change()	B-API
`	O
function	O
again	O
.	O

However	O
,	O
after	O
you've	O
read	O
it	O
in	O
,	O
you	O
could	O
strip	B-API
out	O
the	O
whitespace	O
by	O
doing	O
,	O
e.g.	O
,	O
`	O
df	O
[	O
"	O
Make	O
"]	O
=	O
df	O
[	O
"	O
Make	O
"]	O
.map	B-API
(	O
str.strip	B-API
)`	O
(	O
where	O
`	O
df	O
`	O
is	O
your	O
dataframe	B-API
)	O
.	O

I	O
don't	O
have	O
enough	O
reputation	O
to	O
leave	O
a	O
comment	O
,	O
but	O
the	O
answer	O
above	O
suggesting	O
using	O
the	O
map	B-API
function	O
along	O
with	O
strip	B-API
won't	O
work	O
if	O
you	O
have	O
NaN	O
values	O
,	O
since	O
strip	B-API
only	O
works	O
on	O
chars	O
and	O
NaN	O
are	O
floats	O
.	O

To	O
extract	O
the	O
Series	O
(	O
and	O
plot	O
)	O
from	O
the	O
panel	O
you	O
can	O
use	O
`	O
ix	B-API
`	O
with	O
the	O
following	O
syntax	O
:	O
#CODE	O

pandas	O
:	O
slice	O
a	O
MultiIndex	B-API
by	O
range	O
of	O
secondary	O
index	O

not	O
sure	O
if	O
this	O
is	O
ideal	O
but	O
it	O
works	O
by	O
creating	O
a	O
mask	B-API
#CODE	O

Use	O
`	O
ix	B-API
`	O
:	O
#CODE	O

(	O
It's	O
good	O
practice	O
to	O
do	O
in	O
a	O
single	O
ix	B-API
/	O
loc	B-API
/	O
iloc	B-API
since	O
this	O
version	O
allows	O
assignment	O
.	O
)	O

That	O
said	O
,	O
I	O
kinda	O
disagree	O
with	O
the	O
docs	O
that	O
ix	B-API
is	O
:	O

use	O
loc	B-API
for	O
labels	O

use	O
ix	B-API
for	O
both	O
(	O
if	O
you	O
really	O
have	O
to	O
)	O

It	O
feels	O
like	O
there	O
ought	O
to	O
be	O
a	O
way	O
to	O
do	O
this	O
in	O
one	O
pass	O
(	O
using	O
loc	B-API
/	O
without	O
chaining	O
)	O
,	O
however	O
assignment	O
(	O
`	O
s	O
[	O
'	O
b	O
']	O
.ix	B-API
[	O
1:10	O
]`)	O
works	O
so	O
I	O
guess	O
it's	O
ok	O
.	O

Surprisingly	O
(	O
for	O
me	O
at	O
least	O
)	O
,	O
although	O
comparable	O
for	O
small	O
Series	O
,	O
this	O
starts	O
to	O
become	O
slower	O
than	O
using	O
`	O
ix	B-API
`	O
when	O
the	O
Series	O
is	O
longer	O
than	O
250	O
.	O

you	O
can	O
also	O
use	O
a	O
mask	B-API
:	O

Using	O
a	O
mask	B-API
is	O
my	O
fallback	O
option	O
,	O
at	O
this	O
point	O
=)	O

Pandas	O
rolling	B-API
apply	B-API
with	O
missing	O
data	O

I	O
want	O
to	O
do	O
a	O
rolling	B-API
computation	O
on	O
missing	O
data	O
.	O

Sample	O
Code	O
:	O
(	O
For	O
sake	O
of	O
simplicity	O
I'm	O
giving	O
an	O
example	O
of	O
a	O
rolling	B-API
sum	O
but	O
I	O
want	O
to	O
do	O
something	O
more	O
generic	O
.	O
)	O
#CODE	O

I	O
think	O
that	O
during	O
the	O
"	O
rolling	B-API
"	O
,	O
window	O
with	O
missing	O
data	O
is	O
being	O
ignored	O
for	O
computation	O
.	O

I	O
think	O
a	O
partial	O
answer	O
to	O
this	O
question	O
is	O
probably	O
via	O
using	O
the	O
keyword	O
argument	O
min_periods	O
in	O
the	O
rolling	B-API
apply	B-API
function	O
.	O

The	O
best	O
way	O
to	O
do	O
this	O
in	O
pandas	O
is	O
to	O
use	O
drop	B-API
:	O
#CODE	O

Finally	O
,	O
to	O
drop	B-API
by	O
index	O
instead	O
of	O
by	O
name	O
,	O
try	O
this	O
to	O
delete	O
,	O
e.g.	O
the	O
1st	O
,	O
2nd	O
and	O
4th	O
columns	O
:	O
#CODE	O

@USER	O
I	O
don't	O
know	O
of	O
any	O
performance	O
improvement	O
,	O
but	O
readability-wise	O
,	O
`	O
drop	B-API
`	O
is	O
a	O
more	O
SQL-like	O
description	O
of	O
the	O
operation	O
in	O
question	O
.	O

I	O
think	O
in	O
version	O
0.16.2	O
drop	B-API
by	O
index	O
doesn't	O
work	O
-	O
do	O
nothing	O
.	O

How	O
to	O
drop	B-API
rows	O
of	O
Pandas	O
dataframe	B-API
whose	O
value	O
of	O
certain	O
column	O
is	O
NaN	O

Don't	O
`	O
drop	B-API
`	O
.	O

`	O
notnull	B-API
`	O
is	O
also	O
what	O
Wes	O
(	O
author	O
of	O
Pandas	O
)	O
suggested	O
in	O
his	O
comment	O
on	O
another	O
answer	O
.	O

Though	O
of	O
course	O
that	O
will	O
drop	B-API
rows	O
with	O
negative	O
numbers	O
,	O
too	O
.	O

You	O
could	O
use	O
dataframe	B-API
method	O
notnull	B-API
or	O
inverse	O
of	O
isnull	B-API
,	O
or	O
numpy.isnan	O
:	O
#CODE	O

You	O
can	O
use	O
groupby	B-API
and	O
then	O
apply	B-API
to	O
achieve	O
what	O
you	O
want	O
:	O
#CODE	O

pandas	O
:	O
slice	O
a	O
MultiIndex	B-API
DataFrame	B-API
by	O
range	O
of	O
secondary	O
index	O

I	O
think	O
you	O
want	O
to	O
`	O
resample	B-API
`	O
your	O
dataframe	B-API
,	O
but	O
I'm	O
not	O
sure	O
.	O

My	O
actual	O
goal	O
is	O
to	O
use	O
`	O
groupby	B-API
`	O
,	O
`	O
crosstab	B-API
`	O
and	O
/	O
or	O
`	O
resample	B-API
`	O
to	O
calculate	O
values	O
for	O
each	O
period	O
based	O
on	O
sums	O
/	O
means	O
/	O
etc	O
of	O
individual	O
entries	O
within	O
the	O
period	O
.	O

In	O
other	O
words	O
,	O
I	O
want	O
to	O
transform	B-API
data	O
from	O
:	O
#CODE	O

But	O
you	O
can	O
use	O
`	O
.shift	B-API
`	O
to	O
shift	B-API
it	O
by	O
any	O
number	O
of	O
days	O
(	O
or	O
any	O
frequency	O
for	O
that	O
matter	O
):	O
#CODE	O

However	O
,	O
this	O
doesn't	O
help	O
with	O
resampling	O
on	O
a	O
range	O
,	O
as	O
resample	B-API
will	O
still	O
use	O
bins	O
aligned	O
to	O
the	O
beginning	O
of	O
the	O
month	O
AFAIK	O
.	O

I	O
don't	O
have	O
a	O
simple	O
workaround	O
for	O
you	O
at	O
the	O
moment	O
because	O
`	O
resample	B-API
`	O
requires	O
passing	O
a	O
known	O
frequency	O
rule	O
.	O

I	O
want	O
to	O
find	O
all	O
values	O
in	O
a	O
Pandas	O
dataframe	B-API
that	O
contain	O
whitespace	O
(	O
any	O
arbitrary	O
amount	O
)	O
and	O
replace	B-API
those	O
values	O
with	O
NaNs	O
.	O

I	O
loop	O
through	O
each	O
column	O
and	O
do	O
boolean	O
replacement	O
against	O
a	O
column	O
mask	B-API
generated	O
by	O
applying	O
a	O
function	O
that	O
does	O
a	O
regex	O
search	O
of	O
each	O
value	O
,	O
matching	O
on	O
whitespace	O
.	O

And	O
finally	O
,	O
this	O
code	O
sets	O
the	O
target	O
strings	O
to	O
None	O
,	O
which	O
works	O
with	O
Pandas	O
'	O
functions	O
like	O
fillna()	B-API
,	O
but	O
it	O
would	O
be	O
nice	O
for	O
completeness	O
if	O
I	O
could	O
actually	O
insert	B-API
a	O
NaN	O
directly	O
instead	O
of	O
None	O
.	O

What	O
you	O
really	O
want	O
is	O
to	O
be	O
able	O
to	O
use	O
[	O
`	O
replace	B-API
`]	O
(	O
#URL	O
)	O
with	O
a	O
regex	O
...	O

I'm	O
pretty	O
new	O
to	O
Pandas	O
,	O
but	O
maybe	O
the	O
map	B-API
/	O
apply	B-API
function	O
are	O
what	O
I	O
need	O
?	O

Now	O
the	O
last	O
step	O
is	O
to	O
apply	B-API
/	O
map	B-API
it	O
back	O
to	O
the	O
borough	O
column	O
...	O
how	O
do	O
I	O
do	O
that	O
?	O

Edit	O
:	O
If	O
you've	O
already	O
created	O
your	O
dict	O
as	O
in	O
your	O
edited	O
post	O
,	O
just	O
use	O
`	O
d	O
[	O
'	O
Borough	O
']	O
=	O
d.City.map	O
(	O
paired	O
[	O
'	O
Borough	O
'])`	O
to	O
map	B-API
each	O
city	O
to	O
the	O
borough	O
from	O
your	O
dict	O
.	O

`	O
map	B-API
`	O
is	O
a	O
useful	O
method	O
to	O
know	O
about	O
.	O

It	O
can	O
map	B-API
values	O
either	O
with	O
a	O
Pandas	O
series	O
,	O
with	O
a	O
dict	O
,	O
or	O
with	O
a	O
function	O
that	O
returns	O
the	O
mapped	O
value	O
given	O
the	O
key	O
.	O

There	O
are	O
cases	O
when	O
when	O
the	O
same	O
city	O
may	O
be	O
paired	O
with	O
different	O
boroughs	O
,	O
for	O
instance	O
the	O
city	O
'	O
New	O
York	O
'	O
is	O
mapped	O
to	O
the	O
Borough	O
Manhattan	O
in	O
like	O
97%	O
of	O
occurrences	O
,	O
but	O
how	O
does	O
map	B-API
handle	O
that	O
situation	O
?	O

Another	O
way	O
of	O
doing	O
this	O
could	O
be	O
to	O
join	B-API
these	O
data	O
frames	O
,	O
it	O
will	O
remove	O
the	O
non-matching	O
entries	O
and	O
I	O
can	O
drop	B-API
count	O
column	O
afterwards	O
.	O

i	O
usually	O
just	O
use	O
a	O
mask	B-API
and	O
then	O
select	O
the	O
cols	O
i	O
need	O

a	O
cute	O
one-liner	O
:	O
data	O
[	O
data.groupby	O
(	O
'	O
tag	O
')	O
.pid	O
.transform	B-API
(	O
len	B-API
)	O
>	O
1	O
]	O

Ah	O
ha	O
,	O
currently	O
you	O
can	O
do	O
:	O
`	O
g.filter	O
(	O
lambda	O
x	O
:	O
len	B-API
(	O
x	O
)	O
>	O
1	O
,	O
dropna=False	O
)	O
.dropna()	B-API
`	O
to	O
keep	O
the	O
order	O
.	O

Mind	O
you	O
,	O
nor	O
does	O
transform	B-API
.	O

Of	O
course	O
I	O
can	O
just	O
manually	O
replace	B-API
the	O
truncated	O
words	O
,	O
but	O
I'm	O
curious	O
to	O
know	O
what	O
the	O
cause	O
is	O
?	O

I'm	O
also	O
puzzled	O
why	O
the	O
`	O
apply	B-API
`	O
version	O
along	O
`	O
axis=1	O
`	O
is	O
so	O
much	O
slower	O
.	O

This	O
isn't	O
exclusive	O
to	O
Pandas	O
;	O
in	O
general	O
,	O
any	O
numpy	O
operation	O
will	O
be	O
much	O
faster	O
if	O
you	O
treat	O
arrays	O
and	O
matrices	O
in	O
aggregate	B-API
instead	O
of	O
calling	O
Python	O
functions	O
or	O
inner	O
loops	O
on	O
individual	O
items	O
.	O

You'd	O
need	O
to	O
override	O
the	O
`	O
apply	B-API
`	O
and	O
`	O
onOffset	O
`	O
methods	O
to	O
take	O
into	O
account	O
your	O
holiday	O
calendar	O
.	O

If	O
that's	O
true	O
,	O
I	O
guess	O
I	O
have	O
to	O
figured	O
out	O
how	O
to	O
properly	O
convert	O
my	O
dataframe	B-API
into	O
a	O
timeseries	O
that	O
I	O
can	O
resample	B-API
.	O

I	O
am	O
able	O
to	O
get	O
the	O
desired	O
result	O
by	O
converting	O
my	O
dataframe	B-API
to	O
a	O
timeseries	O
using	O
this	O
command	O
:	O
"	O
ts	O
=	O
pd.TimeSeries	O
(	O
df	O
[	O
0	O
])"	O
,	O
and	O
then	O
I	O
can	O
resample	B-API
the	O
timeseries	O
.	O

You	O
can	O
resample	B-API
over	O
an	O
individual	O
column	O
(	O
since	O
each	O
of	O
these	O
is	O
a	O
timeseries	O
):	O
#CODE	O

Update	O
:	O
A	O
useful	O
workaround	O
is	O
to	O
just	O
smash	O
this	O
with	O
the	O
DatetimeIndex	B-API
constructor	O
(	O
which	O
is	O
usually	O
much	O
faster	O
than	O
an	O
apply	B-API
)	O
,	O
for	O
example	O
:	O
#CODE	O

In	O
0.15	O
this	O
will	O
be	O
vailable	O
in	O
the	O
dt	B-API
attribute	O
(	O
along	O
with	O
other	O
datetime	O
methods	O
):	O
#CODE	O

With	O
more	O
complicated	O
selections	O
like	O
this	O
one	O
you	O
can	O
use	O
`	O
apply	B-API
`	O
:	O
#CODE	O

problems	O
with	O
apply	B-API
function	O
in	O
pandas	O
after	O
update	O

I	O
tried	O
to	O
apply	B-API
'	O
manually	O
'	O
the	O
function	O
recursively	O
to	O
see	O
if	O
some	O
of	O
the	O
dates	O
passed	O
as	O
the	O
x	O
parameter	O
in	O
the	O
lambda	O
definition	O
where	O
wrong	O
,	O
but	O
managed	O
to	O
get	O
correct	O
results	O
any	O
time	O
.	O

But	O
the	O
`	O
apply	B-API
`	O
method	O
just	O
seem	O
not	O
to	O
work	O
anymore	O
,	O
and	O
cannot	O
understand	O
why	O
.	O

If	O
you	O
unstack	B-API
STK_ID	O
,	O
you	O
can	O
create	O
side	O
by	O
side	O
plots	O
per	O
RPT_Date	O
.	O

I	O
think	O
the	O
OP's	O
primary	O
concern	O
is	O
with	O
the	O
division	O
,	O
not	O
the	O
shift	B-API
.	O

`	O
shift	B-API
`	O
realigns	O
the	O
data	O
and	O
takes	O
an	O
optional	O
number	O
of	O
periods	O
.	O

Aah	O
,	O
shift	B-API
is	O
what	O
i	O
needed	O
.	O

Python	O
pandas	O
insert	B-API
long	O
integer	O

I'm	O
trying	O
to	O
insert	B-API
long	O
integers	O
in	O
a	O
Pandas	O
Dataframe	B-API
#CODE	O

If	O
I	O
used	O
`	O
cmov_mean	O
`	O
in	O
`	O
scikits.timeseries	O
`	O
,	O
what	O
should	O
I	O
use	O
when	O
I	O
"	O
resample	B-API
"	O
in	O
pandas	O
?	O

When	O
I	O
"	O
resample	B-API
"	O
my	O
daily	O
averages	O
to	O
monthly	O
and	O
then	O
plot	O
both	O
,	O
I	O
notice	O
a	O
big	O
time	O
offset	O
.	O

I	O
need	O
to	O
join	B-API
it	O
with	O
some	O
reference	O
tables	O
that	O
I	O
have	O
access	O
via	O
a	O
pyodbc	O
connection	O
.	O

Merge	B-API
of	O
multiple	O
data	O
frames	O
of	O
different	O
number	O
of	O
columns	O
into	O
one	O
big	O
data	O
frame	O

Also	O
what	O
if	O
instead	O
two	O
CSV	O
files	O
I	O
had	O
two	O
data	O
frames	O
and	O
wanted	O
to	O
do	O
the	O
same	O
,	O
for	O
example	O
if	O
I	O
loaded	O
first	O
csv	O
to	O
`	O
df1	O
`	O
and	O
second	O
one	O
in	O
`	O
df2	O
`	O
and	O
then	O
wanted	O
to	O
make	O
a	O
merge	B-API
to	O
`	O
df3	O
`	O
that	O
would	O
look	O
like	O
example	O
above	O
.	O

Why	O
not	O
try	O
the	O
`	O
concat	B-API
`	O
function	O
:	O
#CODE	O

Note	O
:	O
the	O
`	O
concat	B-API
`	O
does	O
have	O
some	O
additional	O
options	O
if	O
you	O
have	O
slightly	O
different	O
requirements	O
.	O

The	O
`	O
and	O
`	O
and	O
`	O
or	O
`	O
operators	O
are	O
special	O
in	O
Python	O
and	O
don't	O
interact	O
well	O
with	O
things	O
like	O
numpy	O
and	O
pandas	O
that	O
try	O
to	O
apply	B-API
to	O
them	O
elementwise	O
across	O
a	O
collection	O
.	O

Using	O
the	O
transpose	B-API
allows	O
you	O
to	O
select	O
rows	O
as	O
df	O
[	O
"	O
AA	O
"	O
:	O
"	O
AA	O
"]	O
which	O
then	O
return	O
a	O
MultiIndex	B-API
DataFrame	B-API
(	O
not	O
losing	O
information	O
)	O
,	O
however	O
,	O
df.xs	B-API
(	O
"	O
AA	O
"	O
,	O
axis=1	O
)	O
returns	O
a	O
DataFrmae	O
with	O
a	O
single	O
level	O
Index	O
(	O
thus	O
losing	O
information	O
)	O
.	O

However	O
,	O
if	O
I	O
do	O
the	O
same	O
in	O
a	O
MultiIndex	B-API
column	O
DataFrame	B-API
,	O
then	O
I	O
get	O
a	O
crash	O
.	O

build	O
dataframes	O
for	O
each	O
user	O
and	O
concat	B-API
,	O
very	O
clever	O
!	O

Finally	O
,	O
if	O
you	O
don't	O
like	O
the	O
way	O
the	O
frame	O
looks	O
you	O
can	O
use	O
the	O
transpose	B-API
function	O
of	O
panel	O
to	O
change	O
the	O
appearance	O
before	O
calling	O
to_frame()	B-API
see	O
documentation	O
here	O

How	O
to	O
keep	O
MultiIndex	B-API
when	O
using	O
pandas	O
merge	B-API

A	O
similar	O
question	O
was	O
asked	O
in	O
How	O
to	O
keep	O
index	O
when	O
using	O
pandas	O
merge	B-API
,	O
but	O
it	O
will	O
not	O
work	O
with	O
MultiIndexes	O
,	O
i.e	O
,	O
#CODE	O

How	O
can	O
one	O
make	O
the	O
merge	B-API
while	O
preserving	O
the	O
MultiIndex	B-API
in	O
the	O
left	O
dataframe	B-API
?	O

(	O
It	O
would	O
have	O
to	O
be	O
exactly	O
there	O
,	O
if	O
the	O
shift	B-API
was	O
detected	O
a	O
step	O
later	O
,	O
wouldn't	O
matter	O
.	O
)	O

Actually	O
,	O
many	O
of	O
DataFrameGroupBy	B-API
object	O
methods	O
such	O
as	O
(	O
apply	B-API
,	O
transform	B-API
,	O
aggregate	B-API
,	O
head	O
,	O
first	O
,	O
last	O
)	O
return	O
a	O
DataFrame	B-API
object	O
.	O

yes	O
,	O
df1	O
+	O
df2	O
will	O
try	O
and	O
align	B-API
the	O
columns	O
.	O

you	O
should	O
convert	O
your	O
time	O
steps	O
to	O
a	O
`	O
DatetiemIndex	O
`	O
and	O
than	O
resample	B-API
R2	O

I	O
would	O
try	O
to	O
copy	O
the	O
original	O
table	O
,	O
drop	B-API
columns	O
that	O
differ	O
(	O
`	O
result	O
`	O
and	O
`	O
run	O
`)	O
,	O
reindex	B-API
that	O
,	O
combine	O
both	O
things	O
again	O
with	O
the	O
new	O
index	O
as	O
multi-index	O
and	O
then	O
run	O
the	O
mean	O
method	O
for	O
that	O
outer	O
multi-index	O
level	O
.	O

I	O
know	O
that	O
the	O
returned	O
pivot	B-API
is	O
a	O
dataframe	B-API
so	O
I	O
can	O
calculate	O
it	O
through	O
other	O
means	O
,	O
but	O
just	O
curious	O
if	O
there	O
is	O
a	O
more	O
efficient	O
way	O
.	O

Define	O
the	O
function	O
you	O
want	O
to	O
apply	B-API
.	O

Then	O
,	O
apply	B-API
it	O
.	O

Was	O
wondering	O
if	O
the	O
pandas	O
pivot	B-API
had	O
any	O
similar	O
built	O
in	O
functionality	O
.	O

Efficient	O
way	O
to	O
apply	B-API
multiple	O
filters	O
to	O
pandas	O
DataFrame	B-API
or	O
Series	O

I	O
have	O
a	O
scenario	O
where	O
a	O
user	O
wants	O
to	O
apply	B-API
several	O
filters	O
to	O
a	O
Pandas	O
DataFrame	B-API
or	O
Series	O
object	O
.	O

I	O
want	O
to	O
take	O
a	O
dictionary	O
of	O
the	O
following	O
form	O
and	O
apply	B-API
each	O
operation	O
to	O
a	O
given	O
Series	O
object	O
and	O
return	O
a	O
'	O
filtered	O
'	O
Series	O
object	O
.	O

The	O
input	O
I	O
receive	O
is	O
a	O
dictionary	O
defining	O
what	O
filters	O
to	O
apply	B-API
.	O

My	O
example	O
could	O
do	O
something	O
like	O
`	O
df	O
[(	O
ge	B-API
(	O
df	O
[	O
'	O
col1	O
']	O
,	O
1	O
)	O
&	O
le	O
(	O
df	O
[	O
'	O
col1	O
']	O
,	O
1	O
)]`	O
.	O

Maybe	O
I	O
could	O
add	O
each	O
intermediate	O
boolean	O
array	O
to	O
a	O
big	O
array	O
and	O
then	O
just	O
use	O
`	O
map	B-API
`	O
to	O
apply	B-API
the	O
`	O
and	O
`	O
operator	O
to	O
them	O
?	O

The	O
call	O
to	O
`	O
reindex_like()	B-API
`	O
inserts	O
some	O
NaN	O
data	O
into	O
the	O
series	O
so	O
the	O
`	O
dtype	B-API
`	O
of	O
that	O
series	O
changes	O
from	O
`	O
bool	B-API
`	O
to	O
`	O
object	O
`	O
.	O

is	O
it	O
possible	O
to	O
do	O
fuzzy	O
match	O
merge	B-API
with	O
python	O
pandas	O
?	O

I	O
have	O
two	O
DataFrames	O
which	O
I	O
want	O
to	O
merge	B-API
based	O
on	O
a	O
column	O
.	O

However	O
,	O
due	O
to	O
alternate	O
spellings	O
,	O
different	O
number	O
of	O
spaces	O
,	O
absence	O
/	O
presence	O
of	O
diacritical	O
marks	O
,	O
I	O
would	O
like	O
to	O
be	O
able	O
to	O
merge	B-API
as	O
long	O
as	O
they	O
are	O
similar	O
to	O
one	O
another	O
.	O

I	O
want	O
to	O
merge	B-API
on	O
similar	O
values	O
between	O
two	O
DataFrames	O

I	O
would	O
just	O
do	O
a	O
separate	O
step	O
and	O
use	O
difflib	O
getclosest_matches	O
to	O
create	O
a	O
new	O
column	O
in	O
one	O
of	O
the	O
2	O
dataframes	O
and	O
the	O
merge	B-API
/	O
join	B-API
on	O
the	O
fuzzy	O
matched	O
column	O

Could	O
you	O
explain	O
how	O
to	O
use	O
`	O
difflib.get_closest_matches	O
`	O
to	O
create	O
such	O
a	O
column	O
and	O
then	O
merge	B-API
on	O
that	O
?	O

Similar	O
to	O
@USER	O
suggestion	O
,	O
you	O
can	O
apply	B-API
`	O
difflib	O
`	O
'	O
s	O
`	O
get_closest_matches	O
`	O
to	O
`	O
df2	O
`'	O
s	O
index	O
and	O
then	O
apply	B-API
a	O
`	O
join	B-API
`	O
:	O
#CODE	O

If	O
these	O
were	O
columns	O
,	O
in	O
the	O
same	O
vein	O
you	O
could	O
apply	B-API
to	O
the	O
column	O
then	O
`	O
merge	B-API
`	O
:	O
#CODE	O

Instead	O
of	O
directly	O
applying	O
`	O
get_close_matches	O
`	O
,	O
I	O
found	O
it	O
easier	O
to	O
apply	B-API
the	O
following	O
function	O
.	O

Then	O
you	O
can	O
insert	B-API
it	O
again	O
into	O
your	O
DataFrame	B-API
.	O

I	O
used	O
this	O
and	O
DataFrame.apply	B-API
to	O
apply	B-API
it	O
to	O
all	O
major	O
columns	O
in	O
the	O
dataframe	B-API
.	O

map	B-API
(	O
lambda	O
x	O
:	O
(	O
x	O
[	O
3	O
]	O
,	O
[	O
int	O
(	O
x	O
[	O
1	O
])	O
,	O
int	O
(	O
x	O
[	O
2	O
])])	O
,	O
[	O
line.split()	O
])	O

You	O
can	O
either	O
load	O
the	O
file	O
and	O
then	O
filter	O
using	O
`	O
df	O
[	O
df	O
[	O
'	O
field	O
']	O
constant	O
]`	O
,	O
or	O
if	O
you	O
have	O
a	O
very	O
large	O
file	O
and	O
you	O
are	O
worried	O
about	O
memory	O
running	O
out	O
,	O
then	O
use	O
an	O
iterator	O
and	O
apply	B-API
the	O
filter	O
as	O
you	O
concatenate	O
chunks	O
of	O
your	O
file	O
e.g.	O
:	O
#CODE	O

I	O
realize	O
Dataframe	B-API
takes	O
a	O
map	B-API
of	O
{	O
'	O
series_name	O
'	O
:	O
Series	O
(	O
data	O
,	O
index	O
)	O
}	O
.	O

However	O
,	O
it	O
automatically	O
sorts	O
that	O
map	B-API
even	O
if	O
the	O
map	B-API
is	O
an	O
OrderedDict()	O
.	O

or	O
just	O
concat	B-API
dataframes	O
#CODE	O

I	O
create	O
a	O
fresh	O
dataframe	B-API
with	O
the	O
appropriate	O
index	O
,	O
drop	B-API
the	O
data	O
to	O
a	O
dictionary	O
,	O
then	O
populate	O
the	O
new	O
dataframe	B-API
based	O
on	O
the	O
dictionary	O
values	O
(	O
skipping	O
missing	O
values	O
)	O
.	O

Resample	B-API
Searies	O
/	O
DataFrame	B-API
with	O
frequency	O
anchored	O
to	O
specific	O
time	O

Which	O
I	O
want	O
to	O
resample	B-API
to	O
say	O
'	O
5s	O
'	O
.	O

I	O
was	O
pleased	O
to	O
see	O
that	O
this	O
method	O
also	O
works	O
with	O
the	O
replace	B-API
function	O
.	O

i'd	O
use	O
the	O
pandas	O
replace	B-API
function	O
,	O
very	O
simple	O
and	O
powerful	O
as	O
you	O
can	O
use	O
regex	O
.	O

numpy	O
diff	B-API
on	O
a	O
pandas	O
Series	O

Pandas	O
implements	O
`	O
diff	B-API
`	O
like	O
so	O
:	O
#CODE	O

Because	O
np	O
is	O
taking	O
`	O
np.asanyarray()	O
`	O
of	O
the	O
series	O
before	O
finding	O
the	O
`	O
diff	B-API
`	O
.	O

I	O
am	O
attempting	O
to	O
left	O
merge	B-API
two	O
dataframes	O
,	O
but	O
I	O
am	O
running	O
into	O
an	O
issue	O
.	O

I	O
noticed	O
some	O
strange	O
behavior	O
when	O
using	O
IX	B-API
on	O
large	O
pandas	O
dataframes	O
.	O

Yes	O
,	O
`	O
ix	B-API
`	O
caches	O
results	O
.	O

How	O
do	O
I	O
do	O
the	O
equivalent	O
of	O
`	O
df	O
[	O
df	O
[	O
"	O
B	O
"]	O
==	O
2	O
]`	O
,	O
if	O
`	O
B	O
`	O
is	O
the	O
name	O
of	O
a	O
level	O
in	O
a	O
`	O
MultiIndex	B-API
`	O
instead	O
?	O

Swapping	O
the	O
name	O
I	O
want	O
to	O
use	O
to	O
the	O
start	O
of	O
the	O
`	O
MultiIndex	B-API
`	O
and	O
then	O
use	O
lookup	O
by	O
index	O
:	O
`	O
df.swaplevel	B-API
(	O
0	O
,	O
"	O
B	O
")	O
.ix	B-API
[	O
2	O
]`	O

Note	O
:	O
it	O
is	O
not	O
equal	O
to	O
`	O
dt	B-API
`	O
because	O
it's	O
become	O
"	O
offset-aware	O
"	O
:	O
#CODE	O

Think	O
of	O
np.datetime64	O
the	O
same	O
way	O
you	O
would	O
about	O
np.int8	O
,	O
np.int16	O
,	O
etc	O
and	O
apply	B-API
the	O
same	O
methods	O
to	O
convert	O
beetween	O
Python	O
objects	O
such	O
as	O
int	O
,	O
datetime	O
and	O
corresponding	O
numpy	O
objects	O
.	O

You	O
can	O
use	O
the	O
`	O
resample	B-API
`	O
method	O
(	O
#URL	O
)	O
if	O
you	O
have	O
a	O
time	O
series	O
(	O
if	O
the	O
time	O
is	O
used	O
as	O
the	O
index	O
):	O
#CODE	O

Feels	O
to	O
me	O
like	O
the	O
trick	O
is	O
to	O
select	O
all	O
unique	O
dates	O
present	O
,	O
create	O
24	O
hour	O
time	O
samples	O
for	O
each	O
of	O
these	O
dates	O
and	O
merge	B-API
the	O
two	O
sets	O
.	O

OK	O
,	O
then	O
indeed	O
,	O
the	O
easiest	O
way	O
will	O
probably	O
be	O
to	O
create	O
an	O
index	O
object	O
with	O
the	O
date	O
range	O
you	O
want	O
and	O
to	O
reindex	B-API
the	O
dataframe	B-API
.	O

This	O
gives	O
me	O
the	O
error	O
for	O
serie_5	O
(	O
the	O
second	O
concat	B-API
):	O
#CODE	O

Another	O
way	O
is	O
to	O
use	O
join	B-API
:	O
#CODE	O

just	O
create	O
a	O
Python	O
list	O
and	O
append	B-API
your	O
Series	O
into	O
it	O
and	O
then	O
provide	O
it	O
to	O
pandas.concat	B-API
as	O
@USER	O
was	O
writing	O
above	O
.	O

The	O
use	O
of	O
join	B-API
looks	O
generic	O
enough	O
!	O

I	O
wish	O
to	O
merge	B-API
the	O
values	O
from	O
b	O
into	O
a	O
.	O

Apply	B-API
can	O
also	O
do	O
aggregation	O
and	O
other	O
things	O

Because	O
my	O
lists	O
are	O
large	O
,	O
is	O
there	O
any	O
way	O
not	O
to	O
load	O
the	O
full	O
list	O
into	O
memory	O
but	O
,	O
rather	O
,	O
efficiently	O
append	B-API
values	O
one	O
at	O
a	O
time	O
?	O

`	O
append	B-API
`	O
is	O
a	O
wrapper	O
for	O
`	O
concat	B-API
`	O
,	O
so	O
`	O
concat	B-API
`	O
would	O
be	O
marginally	O
more	O
efficient	O
,	O
but	O
as	O
@USER	O
says	O
Pandas	O
is	O
probably	O
not	O
appropriate	O
for	O
updating	O
a	O
HDF5	O
file	O
every	O
second	O
.	O

If	O
memory	O
is	O
no	O
constraint	O
just	O
preallocate	O
a	O
huge	O
zeros	O
array	O
and	O
append	B-API
at	O
the	O
end	O
of	O
the	O
program	O
removing	O
any	O
excess	O
zeros	O
.	O

Another	O
option	O
is	O
to	O
use	O
messaging	O
to	O
transmit	O
from	O
one	O
process	O
to	O
another	O
(	O
and	O
then	O
append	B-API
in	O
memory	O
)	O
,	O
this	O
avoids	O
the	O
serialization	O
issue	O
.	O

`	O
tz	B-API
`	O
means	O
time	O
zone	O
and	O
`	O
Not	O
Windows	O
`	O
and	O
`	O
Windows	O
`	O
are	O
categories	O
extracted	O
from	O
the	O
User	O
Agent	O
in	O
the	O
original	O
data	O
,	O
so	O
we	O
can	O
see	O
that	O
there	O
are	O
3	O
Windows	O
users	O
and	O
0	O
Non-windows	O
users	O
in	O
Africa	O
/	O
Cairo	O
from	O
the	O
data	O
collected	O
.	O

I	O
need	O
to	O
merge	B-API
these	O
three	O
columns	O
and	O
have	O
the	O
entire	O
date	O
in	O
one	O
column	O
for	O
all	O
the	O
rows	O
.	O

You	O
are	O
looking	O
for	O
`	O
apply	B-API
`	O
(	O
`	O
merge	B-API
`	O
is	O
like	O
a	O
database	O
join	B-API
.	O
):	O
#CODE	O

merge	B-API
two	O
dataframe	B-API
and	O
create	O
a	O
new	O
one	O
with	O
multiindex	B-API

I	O
would	O
like	O
to	O
merge	B-API
the	O
two	O
dataframe	B-API
in	O
a	O
new	O
dataframe	B-API
with	O
a	O
multi-index	O
like	O
:	O

I	O
tried	O
to	O
reindex	B-API
like	O
this	O
but	O
it	O
doesn't	O
work	O
:	O
#CODE	O

Anybody	O
knows	O
how	O
to	O
reindex	B-API
this	O
dataframe	B-API
to	O
have	O
the	O
index	O
levels	O
in	O
sorted	O
order	O
?	O

I	O
am	O
trying	O
to	O
add	O
a	O
column	O
of	O
smaller	O
`	O
len	B-API
`	O
into	O
a	O
`	O
DataFrame	B-API
`	O
where	O
indexes	O
of	O
smaller	O
item	O
are	O
a	O
subset	O
of	O
a	O
larger	O
item	O
.	O

You	O
are	O
looking	O
for	O
an	O
outer	O
`	O
join	B-API
`	O
,	O
here	O
is	O
a	O
simple	O
example	O
:	O
#CODE	O

The	O
pandas	O
implementation	O
uses	O
a	O
rolling	B-API
window	O
of	O
the	O
previous	O
n	O
values	O
,	O
which	O
is	O
how	O
it's	O
usually	O
done	O
in	O
finance	O
(	O
see	O
this	O
Wikipedia	O
entry	O
for	O
simple	O
moving	O
average	O
)	O
.	O

`	O
len	B-API
(	O
np.arange	O
(	O
12	O
))`	O
and	O
`	O
len	B-API
(	O
pd.stats.moments.rolling_mean	O
(	O
np.arange	O
(	O
12	O
)	O
,	O
6	O
))`	O
both	O
equal	O
12	O
as	O
I	O
would	O
have	O
expected	O
-	O
what	O
result	O
were	O
you	O
expecting	O
?	O

I	O
have	O
faced	O
this	O
with	O
rolling	B-API
statistics	O
in	O
pandas	O
,	O
too	O
.	O

I'd	O
say	O
for	O
non-time-related	O
measurements	O
,	O
such	O
as	O
an	O
altitude	O
vs	O
.	O
distance	O
profile	O
,	O
a	O
central-based	O
moving	O
window	O
makes	O
more	O
sense	O
,	O
since	O
it	O
does	O
not	O
introduce	O
lag	O
or	O
shift	B-API
.	O

If	O
you	O
use	O
a	O
pandas	O
Series	O
rather	O
than	O
a	O
list	O
,	O
you	O
can	O
use	O
its	O
`	O
diff	B-API
`	O
method	O
:	O
#CODE	O

One	O
"	O
built-in	O
"	O
way	O
to	O
accomplish	O
it	O
might	O
be	O
accomplished	O
using	O
`	O
shift	B-API
`	O
twice	O
,	O
but	O
I	O
think	O
this	O
is	O
going	O
to	O
be	O
somewhat	O
messier	O
...	O

I	O
assume	O
what	O
you	O
are	O
trying	O
to	O
do	O
is	O
change	O
the	O
frequency	O
of	O
a	O
Time	O
Series	O
that	O
contains	O
data	O
,	O
in	O
which	O
case	O
you	O
can	O
use	O
`	O
resample	B-API
`	O
(	O
documentation	O
)	O
.	O

Then	O
you	O
can	O
change	O
the	O
frequency	O
to	O
seconds	O
using	O
resample	B-API
,	O
specifying	O
how	O
you	O
want	O
to	O
aggregate	B-API
the	O
values	O
(	O
mean	O
,	O
sum	O
etc	O
.	O
):	O
#CODE	O

Update	O
:	O
if	O
you're	O
doing	O
this	O
to	O
a	O
DatetimeIndex	B-API
/	O
datetime64	O
column	O
a	O
better	O
way	O
is	O
to	O
use	O
`	O
np.round	O
`	O
directly	O
rather	O
than	O
via	O
an	O
apply	B-API
/	O
map	B-API
:	O
#CODE	O

Hence	O
you	O
can	O
apply	B-API
this	O
to	O
the	O
entire	O
index	O
:	O
#CODE	O

I	O
have	O
corrected	O
this	O
and	O
added	O
how	O
to	O
apply	B-API
this	O
to	O
the	O
entire	O
dt_index	O
.	O

Think	O
I	O
figured	O
out	O
the	O
second	O
part	O
:	O
sp500	O
[	O
"	O
regression	O
"]	O
=	O
exp	O
(	O
sm.OLS	O
(	O
log	O
(	O
sp500	O
[	O
"	O
Adj	O
Close	O
"])	O
,	O
sm.add_constant	O
(	O
range	O
(	O
len	B-API
(	O
sp500.index	O
))	O
,	O
prepend=True	O
))	O
.fit()	O
.fittedvalues	O
)	O

You	O
might	O
also	O
want	O
to	O
report	O
bugs	O
on	O
github	O
issues	O
rather	O
than	O
stack	B-API
overflow	O
.	O

You	O
are	O
looking	O
for	O
a	O
`	O
merge	B-API
`	O
:	O
#CODE	O

The	O
keywords	O
are	O
the	O
same	O
as	O
for	O
`	O
join	B-API
`	O
,	O
but	O
`	O
join	B-API
`	O
uses	O
only	O
the	O
index	O
,	O
see	O
"	O
Database-style	O
DataFrame	B-API
joining	O
/	O
merging	O
"	O
.	O

If	O
you	O
try	O
and	O
join	B-API
on	O
a	O
column	O
you	O
get	O
an	O
error	O
:	O
#CODE	O

It	O
is	O
giving	O
me	O
an	O
error	O
when	O
i	O
run	O
merge	B-API
:	O
-	O
UnicodeDecodeError	O
:	O
'	O
ascii	O
'	O
codec	O
can't	O
decode	O
byte	O
0xc2	O
in	O
position	O
268	O
:	O
ordinal	O
not	O
in	O
range	O
(	O
128	O
)	O

The	O
`	O
for	O
`	O
loops	O
and	O
`	O
append	B-API
`	O
s	O
will	O
not	O
be	O
efficient	O
and	O
should	O
be	O
avoided	O
.	O

Try	O
rewrting	O
these	O
using	O
numpy	O
functions	O
and	O
/	O
or	O
the	O
DataFrame	B-API
`	O
apply	B-API
`	O
method	O
...	O

Also	O
,	O
would	O
you	O
agree	O
then	O
,	O
using	O
your	O
suggestion	O
,	O
if	O
we	O
want	O
to	O
apply	B-API
a	O
function	O
/	O
algorithm	O
restricted	O
every	O
unique	O
date	O
in	O
the	O
file	O
one	O
should	O
just	O
groupby	B-API
the	O
'	O
datetime	O
'	O
object	O
?	O

As	O
commented	O
,	O
in	O
newer	O
pandas	O
,	O
Series	O
has	O
a	O
`	O
replace	B-API
`	O
method	O
to	O
do	O
this	O
more	O
elegantly	O
:	O
#CODE	O

(	O
been	O
a	O
while	O
since	O
I	O
wrote	O
this	O
!	O
)	O
replace	B-API
definitely	O
best	O
option	O
,	O
another	O
is	O
to	O
use	O
`	O
.apply	B-API
(	O
{	O
'	O
March	O
'	O
:	O
0	O
,	O
'	O
April	O
'	O
:	O
1	O
,	O
'	O
Dec	O
'	O
:	O
3}	O
.get	B-API
)`	O
:)	O
In	O
0.15	O
we'll	O
have	O
Categorical	B-API
Series	O
/	O
columns	O
,	O
so	O
the	O
best	O
way	O
will	O
be	O
to	O
use	O
that	O
and	O
then	O
sort	O
will	O
just	O
work	O
.	O

@USER	O
I've	O
taken	O
the	O
liberty	O
of	O
replacing	O
the	O
second	O
line	O
with	O
the	O
'	O
replace	B-API
'	O
method	O
.	O

A	O
bit	O
late	O
to	O
the	O
game	O
,	O
but	O
here's	O
a	O
way	O
to	O
create	O
a	O
function	O
that	O
sorts	O
pandas	O
Series	O
,	O
DataFrame	B-API
,	O
and	O
multiindex	B-API
DataFrame	B-API
objects	O
using	O
arbitrary	O
functions	O
.	O

This	O
also	O
works	O
on	O
multiindex	B-API
DataFrames	O
and	O
Series	O
objects	O
:	O
#CODE	O

some	O
problem	O
with	O
ix	B-API
and	O
loc	B-API
,	O
the	O
pandas	O
documentation	O
could	O
be	O
clearer	O

When	O
you	O
do	O
`	O
len	B-API
(	O
df	O
[	O
'	O
column	O
name	O
'])`	O
you	O
are	O
just	O
getting	O
one	O
number	O
,	O
namely	O
the	O
number	O
of	O
rows	O
in	O
the	O
DataFrame	B-API
(	O
i.e.	O
,	O
the	O
length	O
of	O
the	O
column	O
itself	O
)	O
.	O

If	O
you	O
want	O
to	O
apply	B-API
`	O
len	B-API
`	O
to	O
each	O
element	O
in	O
the	O
column	O
,	O
use	O
`	O
df	O
[	O
'	O
column	O
name	O
']	O
.map	B-API
(	O
len	B-API
)`	O
.	O

I	O
came	O
up	O
with	O
a	O
way	O
using	O
a	O
list	O
comprehension	O
:	O
`	O
df	O
[[(	O
len	B-API
(	O
x	O
)	O
<	O
2	O
)	O
for	O
x	O
in	O
df	O
[	O
'	O
column	O
name	O
']]]`	O
but	O
yours	O
is	O
much	O
nicer	O
.	O

To	O
directly	O
answer	O
this	O
question's	O
title	O
(	O
which	O
I	O
understand	O
is	O
not	O
necessarily	O
the	O
OP's	O
problem	O
but	O
could	O
help	O
other	O
users	O
coming	O
across	O
this	O
question	O
)	O
one	O
way	O
to	O
do	O
this	O
is	O
to	O
use	O
the	O
drop	B-API
method	O
:	O

Finally	O
doing	O
pivot	B-API
table	O
and	O
putting	O
the	O
pivots	O
into	O
a	O
dataframe	B-API
and	O
plotting	O
the	O
dataframe	B-API
in	O
bar	O
mode	O
created	O
the	O
necessary	O
graphs	O
.	O

I	O
think	O
the	O
best	O
way	O
is	O
to	O
merge	B-API
all	O
dataframes	O
together	O
,	O
then	O
you	O
could	O
use	O
all	O
nice	O
Panda	O
functions	O
to	O
slice	O
and	O
mix-and-match	O
anyway	O
you	O
want	O
.	O

I	O
would	O
merge	B-API
them	O
like	O
this	O
:	O
#CODE	O

You	O
could	O
of	O
course	O
use	O
stack	B-API
/	O
unstack	B-API
to	O
structure	O
your	O
DataFrame	B-API
a	O
bit	O
different	O
depending	O
on	O
the	O
amount	O
of	O
data	O
and	O
the	O
way	O
you	O
will	O
be	O
using	O
it	O
most	O
.	O

Pandas	O
join	B-API
grouped	O
and	O
normal	O
dataframe	B-API

I	O
need	O
to	O
join	B-API
levels	O
with	O
lines	O
(	O
atom	O
,	O
ion	O
,	O
level	O
):	O
at	O
first	O
on	O
atom	O
,	O
ion	O
,	O
level_number_upper	O
and	O
then	O
atom	O
,	O
ion	O
,	O
level_number_lower	O
.	O

Is	O
there	O
a	O
way	O
to	O
precompute	O
the	O
join	B-API
-	O
memory	O
is	O
not	O
an	O
issue	O
,	O
but	O
speed	O
is	O
.	O

To	O
show	O
what	O
I	O
want	O
to	O
join	B-API
merge	B-API
here	O
a	O
code	O
snippet	O
#CODE	O

and	O
then	O
I	O
want	O
to	O
join	B-API
/	O
merge	B-API
grouped	O
data	O
with	O
lines	O
on	O
atomic_number	O
and	O
ion_number	O

Why	O
not	O
join	B-API
/	O
merge	B-API
first	O
then	O
do	O
the	O
groupby	B-API
?	O

It	O
would	O
cost	O
a	O
lot	O
of	O
performance	O
to	O
do	O
the	O
join	B-API
/	O
merge	B-API
before	O
the	O
groupby	B-API
.	O

Just	O
to	O
confirm	O
,	O
are	O
you	O
are	O
wanting	O
to	O
merge	B-API
/	O
join	B-API
a	O
groupby	B-API
object	O
with	O
a	O
dataframe	B-API
?	O

Well	O
no	O
-	O
I	O
want	O
to	O
join	B-API
/	O
merge	B-API
the	O
result	O
.	O

pandas	O
'	O
transform	B-API
doesn't	O
work	O
sorting	O
groupby	B-API
output	O

Good	O
enough	O
,	O
but	O
then	O
I	O
wanted	O
to	O
use	O
pandas	O
'	O
transform	B-API
to	O
do	O
the	O
same	O
like	O
this	O
:	O
#CODE	O

I	O
know	O
that	O
transform	B-API
requires	O
to	O
return	O
an	O
array	O
of	O
the	O
same	O
dimensions	O
that	O
it	O
accepts	O
as	O
input	O
,	O
so	O
I	O
thought	O
I'd	O
be	O
complying	O
with	O
that	O
requirement	O
just	O
sorting	O
both	O
slices	O
(	O
smokers	O
and	O
non-smokers	O
)	O
of	O
the	O
original	O
DataFrame	B-API
without	O
changing	O
their	O
respective	O
dimensions	O
.	O

`	O
transform	B-API
`	O
is	O
not	O
that	O
well	O
documented	O
,	O
but	O
it	O
seems	O
that	O
the	O
way	O
it	O
works	O
is	O
that	O
what	O
the	O
transform	B-API
function	O
is	O
passed	O
is	O
not	O
the	O
entire	O
group	O
as	O
a	O
dataframe	B-API
,	O
but	O
a	O
single	O
column	O
of	O
a	O
single	O
group	O
.	O

I	O
don't	O
think	O
it's	O
really	O
meant	O
for	O
what	O
you're	O
trying	O
to	O
do	O
,	O
and	O
your	O
solution	O
with	O
`	O
apply	B-API
`	O
is	O
fine	O
.	O

The	O
transform	B-API
does	O
not	O
call	O
`	O
func	O
(	O
group1	O
)`	O
and	O
`	O
func	O
(	O
group2	O
)`	O
.	O

This	O
makes	O
sense	O
if	O
you	O
think	O
about	O
what	O
transform	B-API
is	O
for	O
.	O

It's	O
meant	O
for	O
applying	O
transform	B-API
functions	O
on	O
the	O
groups	O
.	O

For	O
instance	O
,	O
the	O
example	O
in	O
the	O
pandas	O
docs	O
is	O
about	O
z-standardizing	O
using	O
`	O
transform	B-API
`	O
.	O

You	O
have	O
to	O
z-standardize	O
the	O
age	O
with	O
respect	O
to	O
the	O
mean	O
age	O
and	O
the	O
weight	O
with	O
respect	O
to	O
the	O
mean	O
weight	O
,	O
which	O
means	O
you	O
want	O
to	O
transform	B-API
separately	O
for	O
each	O
column	O
.	O

So	O
basically	O
,	O
you	O
don't	O
need	O
to	O
use	O
transform	B-API
here	O
.	O

`	O
apply	B-API
`	O
is	O
the	O
appropriate	O
function	O
here	O
,	O
because	O
`	O
apply	B-API
`	O
really	O
does	O
operate	O
on	O
each	O
group	O
as	O
a	O
single	O
DataFrame	B-API
,	O
while	O
`	O
transform	B-API
`	O
operates	O
on	O
each	O
column	O
of	O
each	O
group	O
.	O

Why	O
is	O
transform	B-API
so	O
poorly	O
documented	O
?	O

I	O
dont	O
think	O
you	O
have	O
it	O
quite	O
right	O
though	O
(	O
although	O
I	O
have	O
no	O
idea	O
how	O
it	O
in	O
fact	O
is	O
working	O
)	O
as	O
when	O
you	O
put	O
print	O
statments	O
in	O
you	O
functions	O
it	O
seems	O
clear	O
that	O
transform	B-API
is	O
actually	O
passing	O
columns	O
as	O
series	O
and	O
data	O
frames	O
.	O

Its	O
really	O
wierd	O
and	O
I	O
want	O
to	O
understand	O
exactly	O
what	O
is	O
going	O
on	O
behind	O
the	O
scenes	O
but	O
can	O
find	O
no	O
information	O
on	O
how	O
transform	B-API
is	O
in	O
fact	O
implemented	O
.	O

by	O
setting	O
`	O
index_col	O
=[	O
0	O
,	O
2	O
,	O
4	O
]`	O
you	O
are	O
creating	O
a	O
MultiIndex	B-API
that's	O
why	O
you	O
get	O
that	O
output	O
.	O

Just	O
read	O
single	O
and	O
merge	B-API
the	O
dataframes	O

Try	O
to	O
convert	O
the	O
'	O
sales	O
'	O
string	O
to	O
an	O
`	O
int	O
`	O
,	O
if	O
it	O
is	O
well	O
formed	O
then	O
it	O
goes	O
on	O
,	O
if	O
it	O
is	O
not	O
it	O
will	O
raise	O
a	O
`	O
ValueError	O
`	O
which	O
we	O
catch	O
and	O
replace	B-API
with	O
the	O
place	O
holder	O
.	O

If	O
it's	O
already	O
in	O
the	O
DataFrame	B-API
you	O
could	O
use	O
`	O
apply	B-API
`	O
to	O
convert	O
those	O
strings	O
which	O
are	O
numbers	O
into	O
integers	O
(	O
using	O
`	O
str.isdigit	B-API
`	O
):	O
#CODE	O

Although	O
,	O
`	O
apply	B-API
`	O
is	O
the	O
important	O
bit	O
of	O
my	O
answer	O
(	O
weirdly	O
no	O
other	O
answers	O
seem	O
to	O
use	O
it	O
)	O
.	O

Although	O
Chang's	O
answer	O
explains	O
how	O
to	O
plot	O
multiple	O
times	O
on	O
the	O
same	O
figure	O
,	O
in	O
this	O
case	O
you	O
might	O
be	O
better	O
off	O
in	O
this	O
case	O
using	O
a	O
`	O
groupby	B-API
`	O
and	O
`	O
unstack	B-API
`	O
ing	O
:	O

In	O
pandas	O
it	O
is	O
called	O
'	O
expanding	B-API
'	O
instead	O
of	O
cumulative	O
I	O
think	O
:	O

@USER	O
only	O
a	O
multiindex	B-API
has	O
a	O
levels	O
attribute	O
.	O

This	O
will	O
append	B-API
the	O
correct	O
values	O
but	O
does	O
not	O
update	O
the	O
index	O
properly	O
and	O
the	O
graph	O
is	O
messed	O
up	O
.	O

If	O
you	O
want	O
to	O
plot	O
the	O
bars	O
of	O
all	O
columns	O
and	O
the	O
mean	O
you	O
can	O
`	O
append	B-API
`	O
the	O
mean	O
:	O
#CODE	O

Have	O
you	O
seen	O
/	O
tried	O
the	O
built-in	O
rolling	B-API
mean	O
function	O
?	O

For	O
example	O
,	O
say	O
you	O
want	O
to	O
pivot	B-API
the	O
data	O
so	O
there	O
are	O
separate	O
columns	O
for	O

a	O
function	O
of	O
your	O
creation	O
)	O
can	O
easily	O
be	O
applied	O
to	O
the	O
columns	O
of	O
`	O
pivot	B-API
`	O
.	O

pd.rolling_mean()	B-API
,	O
like	O
all	O
rolling	B-API
/	O
moving	O
functions	O
in	O
pandas	O
,	O
even	O
accepts	O
a	O
`	O
center	B-API
`	O
parameter	O
for	O
centered	O
sliding	O
windows	O
.	O

Non	O
standard	O
interaction	O
among	O
two	O
tables	O
to	O
avoid	O
very	O
large	O
merge	B-API

However	O
,	O
standard	O
solutions	O
using	O
merge	B-API
/	O
join	B-API
would	O
take	O
too	O
much	O
RAM	O
in	O
the	O
long	O
run	O
.	O

The	O
last	O
major	O
improvement	O
I	O
can	O
think	O
of	O
would	O
be	O
to	O
replace	B-API
df.apply()	B-API
with	O
a	O
for	O
loop	O
to	O
avoid	O
calling	O
any	O
function	O
200M	O
times	O
(	O
or	O
however	O
large	O
A	O
is	O
)	O
.	O

This	O
is	O
slightly	O
faster	O
than	O
original	O
,	O
but	O
there	O
is	O
till	O
a	O
lot	O
of	O
overhead	O
(	O
for	O
me	O
4ms	O
for	O
the	O
merge	B-API
and	O
2.5ms	O
for	O
the	O
second	O
line	O
)	O
.	O

I	O
was	O
under	O
the	O
impression	O
that	O
apply	B-API
was	O
preferable	O
to	O
loops	O
.	O

I	O
would	O
like	O
to	O
read	O
in	O
a	O
csv	O
file	O
iteratively	O
,	O
append	B-API
each	O
chunk	O
into	O
HDFStore	B-API
object	O
,	O
and	O
then	O
work	O
with	O
subsets	O
of	O
the	O
data	O
.	O

If	O
you	O
replace	B-API
that	O
line	O
with	O
:	O

or	O
you	O
can	O
reindex	B-API
afterwards	O
#CODE	O

apply	B-API
on	O
group	O
replicating	O
complete	O
MultiIndex	B-API

If	O
I	O
were	O
to	O
export	O
to	O
a	O
list	O
then	O
I	O
could	O
use	O
the	O
numpy's	O
`	O
interp1d	O
`	O
function	O
and	O
apply	B-API
this	O
to	O
the	O
missing	O
values	O
.	O

I'm	O
surprised	O
you	O
accepted	O
the	O
answer	O
so	O
fast	O
(	O
no	O
offense	O
,	O
hayden	O
;)	O
because	O
I	O
thought	O
you	O
especially	O
wanted	O
to	O
interpolate	B-API
time	O
series	O
,	O
but	O
I	O
guess	O
you	O
didn't	O
mean	O
exactly	O
pandas.TimeSeries	O
.	O

How	O
do	O
you	O
apply	B-API
that	O
to	O
one	O
column	O
only	O
(	O
i.e.	O
'	O
data1	O
')	O

I'm	O
a	O
newbie	O
to	O
pandas	O
dataframe	B-API
,	O
and	O
I	O
wanted	O
to	O
apply	B-API
a	O
function	O
to	O
each	O
column	O
so	O
that	O
it	O
computes	O
for	O
each	O
element	O
x	O
,	O
x	O
/	O
max	O
of	O
column	O
.	O

Pandas	O
DataFrame	B-API
:	O
apply	B-API
function	O
to	O
all	O
columns	O

They	O
also	O
fail	O
if	O
I	O
drop	B-API
the	O
index	O
on	O
both	O
stacked	O
DataFrames	O
(	O
e.g.	O
,	O
do	O
`	O
wstk.reset_index	O
(	O
inplace=True	O
)`	O
before	O
the	O
join	B-API
)	O
.	O

Trying	O
to	O
use	O
the	O
awfully	O
useful	O
pandas	O
to	O
deal	O
with	O
data	O
as	O
time	O
series	O
,	O
I	O
am	O
now	O
stumbling	O
over	O
the	O
fact	O
that	O
there	O
do	O
not	O
seem	O
to	O
exist	O
libraries	O
that	O
can	O
directly	O
interpolate	B-API
(	O
with	O
a	O
spline	O
or	O
similar	O
)	O
over	O
data	O
that	O
has	O
DateTime	O
as	O
an	O
x-axis	O
?	O

)	O
as	O
x-argument	O
,	O
interestingly	O
,	O
the	O
Spline	O
class	O
does	O
create	O
an	O
interpolator	O
,	O
but	O
it	O
still	O
breaks	O
when	O
trying	O
to	O
interpolate	B-API
/	O
extrapolate	O
to	O
a	O
larger	O
DateTimeIndex	B-API
(	O
which	O
is	O
my	O
final	O
goal	O
here	O
)	O
.	O

To	O
simulate	O
different	O
consumption	O
rates	O
,	O
replace	B-API
all	O
real	O
outbound	O
timestamps	O

How	O
to	O
apply	B-API
function	O
to	O
date	O
indexed	O
DataFrame	B-API

Then	O
`	O
apply	B-API
`	O
this	O
to	O
each	O
state	O
in	O
the	O
DataFrame	B-API
:	O
#CODE	O

Using	O
`	O
join	B-API
`	O
or	O
`	O
merge	B-API
`	O
works	O
too	O
:	O
#CODE	O

Pandas	O
interpolate	B-API
changed	O
in	O
version	O
0.10	O
?	O

Calling	O
the	O
column's	O
`	O
interpolate	B-API
`	O
method	O
as	O
below	O
is	O
the	O
correct	O
way	O
.	O

Dataframe	B-API
merge	B-API
creates	O
duplicate	O
records	O
in	O
pandas	O
(	O
0.7.3	O
)	O

When	O
I	O
merge	B-API
two	O
CSV	O
files	O
,	O
of	O
the	O
format	O
(	O
date	O
,	O
someValue	O
)	O
,	O
I	O
see	O
some	O
duplicate	O
records	O
.	O

`'	O
viridis	O
'`	O
(	O
will	O
be	O
default	O
color	O
map	B-API
in	O
2.0	O
)	O

I	O
would	O
suggest	O
the	O
`	O
cubehelix	O
`	O
color	O
map	B-API
.	O

So	O
your	O
requirements	O
are	O
"	O
lots	O
of	O
colors	O
"	O
and	O
"	O
no	O
two	O
colors	O
should	O
map	B-API
to	O
the	O
same	O
grayscale	O
value	O
when	O
printed	O
"	O
,	O
right	O
?	O

The	O
white	O
line	O
is	O
the	O
luminance	O
of	O
each	O
color	O
,	O
so	O
you	O
can	O
see	O
that	O
each	O
color	O
will	O
map	B-API
to	O
a	O
different	O
grayscale	O
value	O
when	O
printed	O
.	O

Assuming	O
Y	O
is	O
a	O
column	O
in	O
your	O
dataframe	B-API
,	O
one	O
way	O
is	O
to	O
use	O
`	O
diff	B-API
`	O
and	O
cumsum	B-API
:	O
#CODE	O

diff	B-API
returns	O
timedelta	O
objects	O
now	O
in	O
pandas	O
master	O
.	O

But	O
I	O
do	O
not	O
see	O
how	O
to	O
'	O
normalize	B-API
'	O
fx	O
and	O
fy	O
so	O
that	O
they	O
have	O
the	O
same	O
levels	O
and	O
`	O
fx.lables	O
`	O
and	O
`	O
fy.lables	O
`	O
have	O
the	O
same	O
coding	O
.	O

For	O
example	O
,	O
I	O
know	O
that	O
every	O
data	O
point	O
has	O
to	O
take	O
one	O
of	O
the	O
five	O
values	O
[	O
a	O
,	O
b	O
,	O
c	O
,	O
d	O
,	O
e	O
]	O
and	O
I	O
already	O
have	O
an	O
index	O
`	O
Index	O
([	O
a	O
,	O
b	O
,	O
c	O
,	O
d	O
,	O
e	O
]	O
,	O
dtype	B-API
=o	O
bject	O
)`	O
and	O
I	O
want	O
to	O
factorize	B-API
vector	O
y	O
=[	O
'	O
a	O
'	O
,	O
'	O
c	O
'	O
,	O
'	O
e	O
']	O
into	O
a	O
Categoricial	O
variable	O
with	O
`	O
Index	O
([	O
a	O
,	O
b	O
,	O
c	O
,	O
d	O
,	O
e	O
]	O
,	O
dtype	B-API
=o	O
bject	O
)`	O
as	O
its	O
levels	O
.	O

In	O
[	O
6	O
]	O
,	O
it	O
should	O
be	O
range	O
(	O
len	B-API
(	O
fx.levels	O
))	O
.	O

You	O
can	O
`	O
unstack	B-API
`	O
the	O
groupby	B-API
:	O
#CODE	O

I	O
used	O
map	B-API
instead	O
.	O

The	O
problem	O
is	O
that	O
no	O
two	O
TimeSeries	O
have	O
the	O
exactly	O
the	O
same	O
index	O
,	O
i.e.	O
I	O
would	O
need	O
to	O
merge	B-API
all	O
the	O
TimeSeries	O
'	O
indexes	O
.	O

However	O
,	O
an	O
exception	O
is	O
thrown	O
when	O
attempting	O
to	O
aggregate	B-API
the	O
TimeSeries	O
into	O
a	O
DataFrame	B-API
and	O
I	O
believe	O
it	O
has	O
to	O
do	O
with	O
the	O
duplicate	O
index	O
elements	O
:	O
#CODE	O

pd.concat()	B-API
performs	O
an	O
'	O
outer	O
'	O
join	B-API
on	O
the	O
indexes	O
by	O
default	O
and	O
holes	O
can	O
be	O
filled	O
by	O
padding	O
forwards	O
and	O
/	O
or	O
backwards	O
in	O
time	O
.	O

Python	O
pandas	O
resample	B-API
added	O
dates	O
not	O
present	O
in	O
the	O
original	O
data	O

For	O
some	O
reason	O
`	O
resample	B-API
`	O
added	O
rows	O
for	O
days	O
that	O
were	O
not	O
present	O
in	O
the	O
intraday	O
data	O
.	O

Prior	O
to	O
0.10.0	O
,	O
pandas	O
labeled	O
resample	B-API
bins	O
with	O
the	O
right-most	O
edge	O
,	O
which	O
for	O
daily	O
resampling	O
,	O
is	O
the	O
next	O
day	O
.	O

`	O
resample	B-API
`	O
converts	O
to	O
a	O
regular	O
time	O
interval	O
,	O
so	O
if	O
there	O
are	O
no	O
samples	O
that	O
day	O
you	O
get	O
NaN	O
.	O

Because	O
I	O
need	O
to	O
be	O
able	O
to	O
rely	O
on	O
it	O
that	O
importing	O
,	O
say	O
,	O
a	O
random	O
number	O
module	O
,	O
won't	O
silently	O
change	O
,	O
say	O
,	O
the	O
pickle	O
module	O
to	O
apply	B-API
a	O
random	O
salt	O
to	O
everything	O
it	O
writes	O
..	O

Pandas	O
slicing	O
along	O
multiindex	B-API
and	O
separate	O
indices	O

I	O
can	O
slice	O
on	O
multiindex	B-API
,	O
but	O
I	O
give	O
it	O
a	O
raw	O
index	O
and	O
it	O
gives	O
me	O
back	O
a	O
tuple	O
.	O

Hopefully	O
there	O
is	O
a	O
better	O
way	O
than	O
`	O
np.array	O
(	O
map	B-API
(	O
np.array	O
,	O
df.index.values	O
))`	O
(	O
!	O
)	O

For	O
now	O
I	O
think	O
i	O
will	O
just	O
do	O
my_index	O
=	O
Series	O
(	O
arange	O
(	O
len	B-API
(	O
df	O
))	O
,	O
index=myselectedindex	O
)	O

Python	O
-	O
rolling	B-API
functions	O
for	O
GroupBy	B-API
object	O

Is	O
there	O
any	O
way	O
to	O
apply	B-API
rolling	B-API
functions	O
to	O
`	O
groupby	B-API
`	O
objects	O
?	O

How	O
exactly	O
do	O
you	O
expect	O
rolling	B-API
function	O
to	O
work	O
on	O
grouped	O
objects	O
(	O
I	O
mean	O
write	O
out	O
the	O
math	O
you	O
want	O
to	O
do	O
in	O
symbols	O
)	O
?	O

Yes	O
,	O
ideally	O
cumsum	B-API
and	O
any	O
rolling	B-API
function	O
(	O
mean	O
,	O
sum	O
,	O
std	O
)	O
.	O

I	O
think	O
you	O
could	O
apply	B-API
any	O
cumulative	O
or	O
"	O
rolling	B-API
"	O
function	O
in	O
this	O
manner	O
and	O
it	O
should	O
have	O
the	O
same	O
result	O
.	O

If	O
you	O
are	O
creating	O
a	O
timeseries	O
,	O
you	O
can	O
use	O
the	O
`	O
tz	B-API
`	O
argument	O
of	O
`	O
date_range	B-API
`	O
:	O
#CODE	O

(	O
Note	O
that	O
I	O
don't	O
actually	O
use	O
`	O
date_range()	B-API
`	O
so	O
using	O
its	O
`	O
tz	B-API
`	O
parameter	O
is	O
not	O
an	O
option	O
.	O
)	O

Update	O
:	O
In	O
recent	O
pandas	O
,	O
you	O
can	O
use	O
the	O
dt	B-API
accessor	O
to	O
broadcast	O
this	O
:	O
#CODE	O

Here's	O
one	O
way	O
(	O
depending	O
if	O
tz	B-API
is	O
already	O
set	O
it	O
might	O
be	O
a	O
`	O
tz_convert	B-API
`	O
rather	O
than	O
`	O
tz_localize	B-API
`	O
):	O
#CODE	O

If	O
you	O
take	O
the	O
first	O
and	O
last	O
duplicate	O
value	O
of	O
each	O
year	O
and	O
shift	B-API
the	O
data	O
in-between	O
by	O
an	O
hour	O
,	O
that	O
should	O
be	O
the	O
easiest	O
way	O
of	O
correcting	O
the	O
issue	O
.	O

I	O
tried	O
using	O
merge	B-API
and	O
join	B-API
but	O
I	O
am	O
not	O
sure	O
how	O
to	O
go	O
about	O
getting	O
the	O
desired	O
result	O
.	O

If	O
the	O
dicts	O
contain	O
both	O
numerical	O
and	O
string	O
values	O
,	O
then	O
you	O
could	O
combine	O
them	O
using	O
a	O
join	B-API
,	O
followed	O
by	O
a	O
groupy	O
and	O
aggregation	O
.	O

In	O
that	O
case	O
,	O
I	O
would	O
like	O
to	O
know	O
if	O
there	O
is	O
a	O
way	O
to	O
add	O
only	O
the	O
numbers	O
and	O
append	B-API
the	O
'	O
D	O
'	O
values	O
as	O
a	O
list	O

What	O
do	O
you	O
want	O
col1	O
and	O
col2	O
to	O
look	O
like	O
after	O
you	O
pivot	B-API
?	O

I	O
am	O
using	O
the	O
groupby	B-API
and	O
sum	O
to	O
quickly	O
aggregate	B-API
accros	O
two	O
data	O
sets	O

However	O
,	O
I	O
try	O
using	O
`	O
C	O
=	O
concat	B-API
([	O
A	O
,	O
B	O
])`	O
and	O
now	O
find	O
that	O
I	O
only	O
have	O
the	O
column	O
shares	O
as	O
an	O
index	O
and	O
cannot	O
group	O
by	O
sequence	O
.	O

Pass	O
the	O
`	O
axis	O
`	O
option	O
to	O
the	O
`	O
apply	B-API
`	O
function	O
:	O
#CODE	O

Does	O
apply	B-API
pass	O
the	O
columns	O
including	O
item1	O
,	O
item2	O
when	O
I	O
use	O
axis=0	O
?	O

`	O
ix	B-API
`'	O
s	O
main	O
purpose	O
is	O
to	O
allow	O
numpy	O
like	O
indexing	O
with	O
support	O
for	O
row	O
and	O
column	O
labels	O
.	O

I	O
don't	O
think	O
`	O
ix	B-API
`	O
supports	O
negative	O
indexing	O
at	O
all	O
.	O

You	O
can	O
resample	B-API
the	O
data	O
to	O
business	O
month	O
.	O

If	O
you	O
don't	O
want	O
the	O
mean	O
price	O
(	O
which	O
is	O
the	O
default	O
in	O
`	O
resample	B-API
`)	O
you	O
can	O
use	O
a	O
custom	O
resample	B-API
method	O
using	O
the	O
keyword	O
argument	O
`	O
how	O
`	O
:	O
#CODE	O

@USER	O
Don't	O
know	O
which	O
method	O
is	O
preferred	O
:	O
normally	O
I	O
would	O
use	O
`	O
resample	B-API
`	O
.	O

`	O
resample	B-API
`	O
should	O
work	O
,	O
not	O
sure	O
about	O
advantages	O
of	O
`	O
asfreq	B-API
`	O
.	O

The	O
ix	B-API
notation	O
allows	O
you	O
to	O
slice	O
columns	O
.	O

Now	O
we	O
have	O
renamed	O
the	O
columns	O
so	O
they	O
will	O
align	B-API
the	O
way	O
we	O
want	O
.	O

Since	O
pandas	O
in	O
it's	O
current	O
form	O
assumes	O
time	O
series	O
data	O
are	O
arranged	O
with	O
time	O
in	O
the	O
index	O
,	O
not	O
the	O
columns	O
,	O
transposing	O
the	O
DataFrame	B-API
,	O
at	O
least	O
temporarily	O
,	O
will	O
enable	O
the	O
use	O
of	O
many	O
built-in	O
methods	O
,	O
such	O
as	O
`	O
shift	B-API
`	O
/	O
`	O
diff	B-API
`	O
/	O
`	O
pct_change	B-API
`	O
/	O
etc	O
.	O

You	O
can	O
use	O
the	O
DataFrame	B-API
`	O
apply	B-API
`	O
method	O
:	O
#CODE	O

For	O
each	O
date	O
,	O
when	O
there	O
is	O
an	O
'	O
S	O
'	O
in	O
the	O
signal	O
column	O
append	B-API
the	O
corresponding	O
price	O
at	O
the	O
time	O
the	O
'	O
S	O
'	O
occurred	O
.	O

That	O
is	O
,	O
"	O
give	O
me	O
the	O
price	O
at	O
1620	O
;	O
(	O
even	O
when	O
it	O
doesn't	O
give	O
a	O
"	O
sell	O
signal	O
"	O
,	O
S	O
)	O
so	O
that	O
I	O
can	O
diff	B-API
.	O
with	O
the	O
"	O
extra	O
B's	O
"	O
--	O
for	O
the	O
special	O
case	O
where	O
B	O
>	O
S	O
.	O

`	O
from	O
numpy	O
import	O
*	O
`	O
will	O
replace	B-API
the	O
builtin	O
`	O
any	B-API
`	O
with	O
`	O
numpy	O
`'	O
s	O
any	O
,	O
which	O
doesn't	O
handle	O
genexps	O
,	O
and	O
so	O
`	O
any	O
((	O
False	O
for	O
i	O
in	O
range	O
(	O
3	O
)))	O
==	O
True	O
`	O
;	O
`	O
from	O
os	O
import	O
*	O
`	O
will	O
replace	B-API
`	O
open	O
`	O
with	O
`	O
os.open	O
`	O
,	O
and	O
so	O
most	O
`	O
open	O
`	O
calls	O
will	O
return	O
`	O
TypeError	O
:	O
an	O
integer	O
is	O
required	O
`	O
;	O
and	O
so	O
on	O
.	O

I	O
want	O
to	O
do	O
it	O
so	O
that	O
I	O
can	O
call	O
reindex	B-API
and	O
fill	O
in	O
the	O
dates	O
between	O
those	O
listed	O
in	O
the	O
table	O
.	O

Do	O
I	O
have	O
to	O
write	O
an	O
algorithm	O
which	O
is	O
then	O
going	O
to	O
go	O
back	O
and	O
say	O
on	O
User	O
2	O
,	O
insert	B-API
the	O
following	O
entry	O
(	O
6	O
,	O
35	O
)	O
.	O

You	O
may	O
find	O
it	O
faster	O
to	O
extract	O
the	O
index	O
as	O
a	O
column	O
and	O
use	O
`	O
apply	B-API
`	O
and	O
`	O
bfill	B-API
`	O
.	O

I'm	O
a	O
bit	O
confused	O
,	O
first	O
you	O
append	B-API
something	O
to	O
cash	O
then	O
you	O
reassign	O
it	O
to	O
an	O
empty	O
series	O
.	O

Update	O
:	O
in	O
0.15	O
you	O
will	O
have	O
access	O
to	O
a	O
dt	B-API
attribute	O
for	O
datetimelike	O
methods	O
:	O
#CODE	O

Here's	O
one	O
(	O
slow	O
!	O
)	O
workaround	O
to	O
do	O
it	O
using	O
`	O
apply	B-API
`	O
,	O
not	O
ideal	O
but	O
it	O
works	O
:	O
#CODE	O

It	O
seems	O
like	O
a	O
bug	O
(	O
that	O
you	O
can't	O
do	O
`	O
apply	B-API
(	O
lambda	O
x	O
:	O
x.month	O
)`)	O
,	O
perhaps	O
worth	O
adding	O
as	O
an	O
issue	O
on	O
github	O
.	O

This	O
happens	O
when	O
using	O
apply	B-API
as	O
well	O
#CODE	O

How	O
to	O
apply	B-API
quantile	B-API
to	O
pandas	O
groupby	B-API
object	O
?	O

Then	O
we	O
make	O
a	O
copy	O
,	O
and	O
use	O
tril_indices_from	O
to	O
get	O
at	O
the	O
lower	O
indices	O
to	O
mask	B-API
them	O
:	O
#CODE	O

`	O
map	B-API
`	O
before	O
(	O
or	O
even	O
after	O
)	O
the	O
`	O
zip	O
`	O
?	O

Indeed	O
,	O
they	O
are	O
all	O
"	O
numbers	O
"	O
.	O
apply	B-API
(	O
float	O
)	O
for	O
some	O
reason	O
was	O
rejected	O
w	O
/	O
ValueError	O
:	O
could	O
not	O
convert	O
string	O
to	O
float	O
:	O
price	O
.	O

Merge	B-API
multi-indexed	O
with	O
single-indexed	O
data	O
frames	O
in	O
pandas	O

How	O
can	O
I	O
merge	B-API
the	O
two	O
data	O
frames	O
with	O
only	O
one	O
of	O
the	O
multi-indexes	O
,	O
in	O
this	O
case	O
the	O
'	O
first	O
'	O
index	O
?	O

Note	O
:	O
you	O
are	O
almost	O
doing	O
a	O
`	O
join	B-API
`	O
here	O
(	O
except	O
the	O
df1	O
is	O
MultiIndex	B-API
)	O
...	O

you	O
can	O
*	O
nearly	O
*	O
merge	B-API
like	O
this	O
:	O
`	O
df1.merge	O
(	O
df2	O
,	O
left_on	O
=d	O
f1.index.get_level_values	O
(	O
'	O
first	O
')	O
,	O
right_on	O
=d	O
f2.index.get_level_values	O
(	O
'	O
first	O
'))`	O

The	O
mnemotechnic	O
for	O
what	O
level	O
you	O
have	O
to	O
use	O
in	O
the	O
reindex	B-API
method	O
:	O

According	O
to	O
the	O
documentation	O
,	O
as	O
of	O
pandas	O
0.14	O
,	O
you	O
can	O
simply	O
join	B-API
single-index	O
and	O
multiindex	B-API
dataframes	O
.	O

You	O
can	O
replace	B-API
`	O
nan	O
`	O
with	O
`	O
None	O
`	O
in	O
your	O
numpy	O
array	O
:	O
#CODE	O

Unfortunately	O
neither	O
this	O
,	O
nor	O
using	O
`	O
replace	B-API
`	O
,	O
works	O
with	O
`	O
None	O
`	O
see	O
this	O
(	O
closed	O
)	O
issue	O
.	O

The	O
way	O
I	O
currently	O
do	O
it	O
is	O
that	O
I	O
reindex	B-API
`	O
df	O
`	O
with	O
every	O
second	O
in	O
the	O
year	O
and	O
use	O
forward	O
filling	O
like	O
:	O
#CODE	O

These	O
are	O
the	O
lines	O
I	O
tried	O
to	O
replace	B-API
the	O
True	O
and	O
False	O
,	O
and	O
got	O
a	O
dataframe	B-API
filled	O
with	O
all	O
True	O
values	O
:	O
#CODE	O

`	O
applymap()	B-API
`	O
can	O
be	O
used	O
to	O
apply	B-API
a	O
function	O
to	O
every	O
element	O
of	O
a	O
`	O
dataframe	B-API
`	O
#CODE	O

It	O
seems	O
to	O
be	O
because	O
the	O
type	O
of	O
the	O
objects	O
in	O
the	O
`	O
DataFrame	B-API
`	O
is	O
actually	O
`	O
numpy.bool_	O
`	O
,	O
not	O
Python's	O
`	O
bool	B-API
`	O
.	O

I	O
am	O
having	O
a	O
real	O
strange	O
behaviour	O
when	O
trying	O
to	O
reindex	B-API
a	O
dataframe	B-API
in	O
pandas	O
.	O

and	O
then	O
I	O
try	O
to	O
reindex	B-API
inside	O
a	O
larger	O
date	O
range	O
:	O
#CODE	O

I	B-API
get	O
strange	O
behaviour	O
when	O
trying	O
to	O
reindex	B-API
the	O
dataframe	B-API
.	O

If	O
I	O
reindex	B-API
one	O
larger	O
part	O
of	O
the	O
dataset	O
I	O
get	O
this	O
error	O
:	O
#CODE	O

Is	O
there	O
a	O
way	O
to	O
replace	B-API
the	O
'	O
nan	O
'	O
label	O
with	O
""	O
in	O
the	O
x-axis	O
?	O

It's	O
good	O
practice	O
to	O
do	O
that	O
first	O
before	O
you	O
apply	B-API
.	O

Is	O
there	O
a	O
shorter	O
way	O
of	O
dropping	O
a	O
column	O
MultiIndex	B-API
level	O
(	O
in	O
my	O
case	O
,	O
basic_amt	O
)	O
except	O
transposing	O
it	O
twice	O
?	O

For	O
the	O
rows	O
which	O
have	O
'	O
'	O
in	O
front	O
I	O
want	O
to	O
cut	B-API
that	O
and	O
move	O
into	O
column	O
C	O
before	O
the	O
'	O
=	O
'	O
sign	O
.	O

If	O
I	O
use	O
normal	O
slice	O
it	O
will	O
cut	B-API
values	O
where	O
there	O
is	O
no	O
'	O
'	O
sign	O
.	O

And	O
`	O
startswith	B-API
`	O
does	O
not	O
work	O
on	O
float	O
values	O
.	O

If	O
you	O
want	O
to	O
use	O
`	O
startswith	B-API
`	O
with	O
a	O
float	O
,	O
you	O
can	O
just	O
first	O
convert	O
it	O
to	O
a	O
str	O
with	O
str()	O
.	O

Then	O
you	O
can	O
use	O
Series	O
`	O
apply	B-API
`	O
with	O
this	O
function	O
:	O
#CODE	O

I	O
know	O
I	O
could	O
resample	B-API
the	O
prices	O
and	O
fill	O
in	O
the	O
details	O
(	O
`	O
ffill	B-API
`	O
,	O
right	O
?	O
)	O
,	O
but	O
that	O
doesn't	O
seem	O
like	O
such	O
a	O
nice	O
solution	O
,	O
because	O
I	O
have	O
to	O
assume	O
the	O
frequency	O
I'm	O
going	O
to	O
be	O
indexing	O
it	O
at	O
and	O
it	O
reduces	O
readability	O
with	O
too	O
many	O
unnecessary	O
data	O
points	O
.	O

Check	O
`	O
asof	B-API
`	O
#CODE	O

I'm	O
trying	O
to	O
merge	B-API
a	O
series	O
of	O
dataframes	O
in	O
pandas	O
.	O

I	O
have	O
a	O
list	O
of	O
dfs	O
,	O
`	O
dfs	O
`	O
and	O
a	O
list	O
of	O
their	O
corresponding	O
labels	O
`	O
labels	O
`	O
and	O
I	O
want	O
to	O
merge	B-API
all	O
the	O
dfs	O
into	O
1	O
df	O
in	O
such	O
that	O
the	O
common	O
labels	O
from	O
a	O
df	O
get	O
the	O
suffix	O
from	O
its	O
label	O
in	O
the	O
`	O
labels	O
`	O
list	O
.	O

I'm	O
trying	O
to	O
make	O
a	O
series	O
of	O
merges	O
that	O
at	O
each	O
merge	B-API
grows	O
at	O
most	O
by	O
number	O
of	O
columns	O
N	O
,	O
where	O
N	O
is	O
the	O
number	O
of	O
columns	O
in	O
the	O
"	O
next	O
"	O
df	O
in	O
the	O
list	O
.	O

Unionize	O
the	O
non-common	O
column	O
names	O
(	O
as	O
in	O
outer	O
join	B-API
)	O
.	O

Here	O
is	O
my	O
attempt	O
at	O
an	O
implementation	O
of	O
this	O
,	O
which	O
does	O
not	O
handle	O
suffixes	O
but	O
illustrates	O
the	O
kind	O
of	O
merge	B-API
I'm	O
looking	O
for	O
:	O
#CODE	O

New	O
columns	O
are	O
added	O
in	O
an	O
outer-join	O
style	O
,	O
but	O
columns	O
that	O
are	O
common	O
(	O
and	O
not	O
part	O
of	O
the	O
index	O
)	O
are	O
used	O
in	O
the	O
join	B-API
via	O
the	O
`	O
on=	O
`	O
keyword	O
.	O

Is	O
the	O
above	O
merge	B-API
operation	O
something	O
that	O
can	O
be	O
done	O
more	O
elegantly	O
in	O
pandas	O
or	O
that	O
already	O
exists	O
as	O
a	O
builtin	O
?	O

The	O
cardinality	O
of	O
the	O
"	O
join	B-API
space	O
"	O
is	O
the	O
issue	O
and	O
may	O
need	O
to	O
be	O
worked	O
around	O
.	O

@USER	O
:	O
Yes	O
,	O
I	O
want	O
an	O
outer	O
join	B-API
but	O
I	O
want	O
it	O
to	O
use	O
the	O
indices	O
of	O
the	O
left	O
and	O
right	O
df	O
.	O

I	O
can	O
explain	O
what's	O
unclear	O
if	O
you	O
let	O
me	O
know	O
what	O
-	O
I	O
basically	O
want	O
an	O
outer	O
merge	B-API
that	O
adds	O
columns	O
together	O
based	O
on	O
a	O
unique	O
index	O

On	O
the	O
other	O
hand	O
,	O
you	O
may	O
want	O
to	O
look	O
into	O
an	O
operation	O
like	O
`	O
pd.concat	B-API
([	O
df1	O
,	O
df2	O
,	O
df3	O
]	O
,	O
keys	O
=[	O
'	O
d1	O
'	O
,	O
'	O
d2	O
'	O
,	O
'	O
d3	O
']	O
,	O
axis=1	O
)`	O
,	O
which	O
produces	O
a	O
dataframe	B-API
with	O
MultiIndex	B-API
columns	O
.	O

Can	O
you	O
explain	O
though	O
why	O
this	O
does	O
not	O
cause	O
combinatorial	O
issues	O
while	O
merge	B-API
does	O
?	O

From	O
the	O
documentation	O
,	O
this	O
seems	O
like	O
an	O
outer	O
join	B-API
on	O
an	O
index	O
with	O
merge	B-API
,	O
but	O
they	O
behave	O
very	O
differently	O
...	O

Good	O
question	O
--	O
it	O
seems	O
to	O
be	O
a	O
limitation	O
of	O
the	O
current	O
merge	B-API
implementation	O
.	O

`	O
Groupby	B-API
`	O
the	O
ID	O
and	O
apply	B-API
the	O
lambda	O
function	O
`	O
diff()	B-API
.sum()	B-API
`	O
to	O
each	O
group	O
.	O

Use	O
`	O
transform	B-API
`	O
instead	O
of	O
`	O
apply	B-API
`	O
because	O
`	O
transform	B-API
`	O
returns	O
an	O
indexed	O
series	O
which	O
you	O
can	O
use	O
to	O
assign	O
to	O
a	O
new	O
column	O
'	O
diff	B-API
'	O
.	O

very	O
smart	O
,	O
you	O
changed	O
diff	B-API
(	O
1	O
)	O
to	O
diff	B-API
(	O
-1	O
)	O
so	O
that	O
diff	B-API
would	O
be	O
taken	O
between	O
i	O
and	O
i-1	O
,	O
but	O
then	O
the	O
signs	O
were	O
all	O
negative	O
,	O
hence	O
-diff	O
(	O
-1	O
)	O
.	O

i.e.	O
,	O
what	O
if	O
the	O
row	O
with	O
shift	B-API
==	O
-560	O
was	O
bad	O
?	O

Here's	O
a	O
solution	O
to	O
separately	O
aggregate	B-API
each	O
contiguous	O
block	O
of	O
bad	O
status	O
(	O
part	O
2	O
of	O
your	O
question	O
?	O
)	O
.	O

As	O
@USER	O
comments	O
this	O
fails	O
for	O
NaN's	O
and	O
isn't	O
particularly	O
robust	O
either	O
,	O
in	O
practise	O
using	O
something	O
similar	O
to	O
@USER	O
'	O
s	O
answer	O
is	O
probably	O
recommended	O
(	O
Note	O
:	O
we	O
want	O
a	O
bool	B-API
rather	O
than	O
raise	O
if	O
there's	O
an	O
issue	O
):	O
#CODE	O

@USER	O
you're	O
right	O
you	O
want	O
to	O
be	O
using	O
assert_frame_equal	O
afterwards	O
(	O
I	O
don't	O
think	O
pandas	O
exports	O
a	O
similar	O
)	O
,	O
although	O
beware	O
of	O
using	O
it	O
from	O
quant's	O
answer	O
as	O
that	O
can	O
raise	O
(	O
rather	O
than	O
return	O
bool	B-API
)	O
.	O

@USER	O
I	O
think	O
you	O
want	O
to	O
do	O
something	O
similar	O
to	O
quants	O
but	O
return	O
a	O
bool	B-API
,	O
have	O
included	O
a	O
recipe	O
.	O

Instead	O
merge	B-API
,	O
join	B-API
,	O
or	O
concatenate	O
them	O
into	O
a	O
single	O
`	O
DataFrame	B-API
`	O
beforehand	O
as	O
pandas	O
gives	O
you	O
multiple	O
ways	O
of	O
doing	O
so	O
.	O

I	O
think	O
you	O
are	O
going	O
to	O
be	O
better	O
doing	O
a	O
`	O
concat	B-API
`	O
of	O
these	O
DataFrames	O
before	O
exporting	O
(	O
via	O
`	O
to_excel	B-API
`	O
)	O
.	O

Unfortunately	O
I	O
think	O
I	O
should	O
have	O
to	O
study	O
a	O
lot	O
merge	B-API
,	O
join	B-API
,	O
concatenate	O
functions	O
in	O
order	O
to	O
have	O
usable	O
and	O
correctly	O
formatted	O
data	O
on	O
the	O
sheet	O
.	O

python	O
pandas	O
custom	O
agg	B-API
function	O

My	O
agg	B-API
function	O
before	O
integrating	O
dataframes	O
was	O
u	O
"	O
|	O
"	O
.join	B-API
(	O
sorted	O
(	O
set	O
(	O
x	O
)))	O
.	O

Ideally	O
I	O
want	O
to	O
have	O
any	O
number	O
of	O
columns	O
in	O
the	O
group	O
and	O
agg	B-API
returns	O
the	O
u	O
"	O
|	O
"	O
.join	B-API
(	O
sorted	O
(	O
set()	O
)	O
for	O
each	O
column	O
item	O
like	O
two	O
above	O
.	O

I	O
was	O
hacking	O
out	O
the	O
aweful	O
`	O
grp2.agg	O
(	O
lambda	O
x	O
:	O
u	O
"	O
|	O
"	O
.join	B-API
(	O
sorted	O
(	O
set	O
(	O
map	B-API
(	O
str	O
,	O
x.tolist()	O
)))))`	O
.	O

I	O
can	O
create	O
a	O
mask	B-API
explicitly	O
:	O
#CODE	O

[	O
Updated	O
to	O
adapt	O
to	O
modern	O
`	O
pandas	O
`	O
,	O
which	O
has	O
`	O
isnull	B-API
`	O
as	O
a	O
method	O
of	O
`	O
DataFrame	B-API
`	O
s	O
..	O
]	O

You	O
can	O
use	O
`	O
isnull	B-API
`	O
and	O
`	O
any	B-API
`	O
to	O
build	O
a	O
boolean	O
Series	O
and	O
use	O
that	O
to	O
index	O
into	O
your	O
frame	O
:	O
#CODE	O

You	O
could	O
use	O
the	O
function	O
`	O
isnull	B-API
`	O
instead	O
of	O
the	O
method	O
:	O
#CODE	O

I've	O
also	O
tried	O
doing	O
this	O
with	O
concat	B-API
and	O
I	O
get	O
the	O
same	O
results	O
.	O

Are	O
you	O
trying	O
to	O
merge	B-API
or	O
concat	B-API
these	O
DataFrames	O
somehow	O
?	O

You	O
should	O
be	O
able	O
to	O
use	O
`	O
concat	B-API
`	O
and	O
`	O
unstack	B-API
`	O
.	O

If	O
so	O
,	O
could	O
you	O
possibly	O
append	B-API
the	O
output	O
of	O
`	O
s.head()	O
.to_dict()	B-API
`	O
for	O
both	O
Series	O
to	O
your	O
question	O
?	O

If	O
you	O
have	O
a	O
list	O
/	O
Series	O
for	O
this	O
ordering	O
(	O
in	O
this	O
case	O
`	O
ser	O
[:	O
3	O
]`	O
will	O
do	O
)	O
you	O
can	O
`	O
reindex	B-API
`	O
before	O
plotting	O
:	O
#CODE	O

I	O
suppose	O
I	O
could	O
use	O
`	O
pd.read_table	B-API
(	O
"	O
test.txt	O
"	O
,	O
na_filter=False	O
)`	O
and	O
subsequently	O
replace	B-API
'	O
NULL	O
'	O
values	O
with	O
NaN	O
and	O
change	O
the	O
column	O
dtype	B-API
.	O

One	O
day	O
I	O
hope	O
to	O
replace	B-API
my	O
use	O
of	O
SAS	O
with	O
python	O
and	O
pandas	O
,	O
but	O
I	O
currently	O
lack	O
an	O
out-of-core	O
workflow	O
for	O
large	O
datasets	O
.	O

I	O
would	O
then	O
have	O
to	O
append	B-API
these	O
new	O
columns	O
into	O
the	O
database	O
structure	O
.	O

I	O
rarely	O
append	B-API
rows	O
,	O
but	O
I	O
do	O
perform	O
many	O
operations	O
that	O
create	O
new	O
columns	O
.	O

Finally	O
,	O
I	O
would	O
like	O
to	O
append	B-API
these	O
new	O
columns	O
into	O
the	O
on-disk	O
data	O
structure	O
.	O

At	O
the	O
very	O
end	O
of	O
this	O
process	O
,	O
I	O
apply	B-API
some	O
learning	O
techniques	O
that	O
create	O
an	O
equation	O
out	O
of	O
those	O
compound	O
columns	O
.	O

e.g.	O
I	O
have	O
tables	O
on	O
disk	O
that	O
I	O
read	O
via	O
queries	O
,	O
create	O
data	O
and	O
append	B-API
back	O
.	O

The	O
second	O
link	O
makes	O
me	O
a	O
bit	O
worried	O
that	O
I	O
can't	O
append	B-API
new	O
columns	O
to	O
the	O
tables	O
in	O
HDFStore	B-API
?	O

You	O
cannot	O
append	B-API
columns	O
once	O
a	O
table	O
is	O
created	O
.	O

Is	O
there	O
any	O
reason	O
I	O
couldn't	O
just	O
transpose	B-API
a	O
dataframe	B-API
,	O
add	O
it	O
to	O
an	O
HDFStore	B-API
,	O
and	O
then	O
index	O
it	O
by	O
the	O
"	O
column	O
"	O
names	O
?	O

This	O
would	O
allow	O
me	O
to	O
access	O
only	O
the	O
"	O
columns	O
"	O
(	O
in	O
the	O
form	O
of	O
rows	O
)	O
that	O
I	O
need	O
,	O
transpose	B-API
them	O
back	O
,	O
and	O
then	O
append	B-API
any	O
new	O
ones	O
I	O
create	O
.	O

I	O
can	O
also	O
add	O
columns	O
(	O
though	O
not	O
drop	B-API
or	O
rename	O
)	O
and	O
append	B-API
observations	O
.	O

querying	O
:	O
gt	B-API
=	O
greater	O
than	O
...	O

How	O
about	O
a	O
join	B-API
since	O
I	O
normally	O
get	O
10	O
data	O
sources	O
to	O
paste	O
together	O
:	O
#CODE	O

then	O
(	O
in	O
my	O
case	O
sometimes	O
I	O
have	O
to	O
agg	B-API
on	O
`	O
aJoinDF	O
`	O
first	O
before	O
its	O
"	O
mergeable	O
"	O
.	O
)	O
#CODE	O

Finally	O
you	O
can	O
read	O
into	O
pandas	O
your	O
3	O
to	O
memory	O
max	O
key	O
indicators	O
and	O
do	O
pivots	O
/	O
agg	B-API
/	O
data	O
exploration	O
.	O

You	O
can	O
also	O
use	O
the	O
two	O
methods	O
built	O
into	O
MongoDB	O
(	O
MapReduce	O
and	O
aggregate	B-API
framework	O
)	O
.	O

See	O
here	O
for	O
more	O
info	O
about	O
the	O
aggregate	B-API
framework	O
,	O
as	O
it	O
seems	O
to	O
be	O
easier	O
than	O
MapReduce	O
and	O
looks	O
handy	O
for	O
quick	O
aggregate	B-API
work	O
.	O

Hi	O
,	O
I'm	O
playing	O
around	O
with	O
your	O
example	O
as	O
well	O
and	O
I	O
run	O
into	O
this	O
error	O
when	O
trying	O
to	O
insert	B-API
into	O
a	O
database	O
:	O
`	O
In	O
[	O
96	O
]:	O
test.insert	O
((	O
a	O
[	O
1	O
]	O
.to_dict()	B-API
for	O
a	O
in	O
df.iterrows()	B-API
))	O
---------------	O

Then	O
I	O
"	O
transpose	B-API
"	O
the	O
row-oriented	O
HDF5	O
file	O
into	O
a	O
column-oriented	O
HDF5	O
file	O
.	O

The	O
table	O
transpose	B-API
looks	O
like	O
:	O
#CODE	O

I	O
subsequently	O
process	O
each	O
file	O
separately	O
and	O
aggregate	B-API
results	O
at	O
the	O
end	O

And	O
although	O
the	O
query	O
language	O
and	O
pandas	O
are	O
different	O
,	O
it's	O
usually	O
not	O
complicated	O
to	O
translate	B-API
part	O
of	O
the	O
logic	O
from	O
one	O
to	O
another	O
.	O

I	O
think	O
type	O
change	O
is	O
fine	O
as	O
long	O
as	O
the	O
timestamp	O
they	O
map	B-API
to	O
is	O
preserved	O
#CODE	O

I	O
want	O
to	O
do	O
a	O
map	B-API
with	O
a	O
customized	O
function	O
where	O
I'm	O
expecting	O
pandas.lib.Timestamp	O
type	O
.	O

How	O
do	O
I	O
turn	O
a	O
row	O
into	O
a	O
map	B-API
?	O

How	O
can	O
I	O
turn	O
a	O
row	O
into	O
a	O
map	B-API
,	O
or	O
otherwise	O
do	O
simple	O
concise	O
custom	O
printing	O
of	O
rows	O
?	O

This	O
will	O
get	O
you	O
a	O
map	B-API
:	O
`	O
speeds.ix	O
[	O
3	O
]	O
.to_dict()	B-API
`	O

This	O
will	O
convert	O
to	O
a	O
map	B-API
:	O
`	O
speeds.ix	O
[	O
3	O
]	O
.to_dict()	B-API
`	O

Trouble	O
with	O
pandas	O
cut	B-API

I	O
can	O
then	O
append	B-API
this	O
to	O
my	O
dataframe	B-API
to	O
have	O
a	O
new	O
column	O
.	O

Then	O
,	O
you	O
can	O
groupby	B-API
by	O
the	O
new	O
column	O
(	O
here	O
it's	O
called	O
index	O
)	O
,	O
and	O
use	O
`	O
transform	B-API
`	O
with	O
a	O
lambda	O
function	O
.	O

Can	O
you	O
paste	O
the	O
entire	O
stack	B-API
trace	O
?	O

File	O
"	O
/	O
misc	O
/	O
apps	O
/	O
linux	O
/	O
python-2.6.1	O
/	O
lib	O
/	O
python2.6	O
/	O
site-packages	O
/	O
pandas-0.10.0-py2.6-linux-x86_	O
#URL	O
line	O
1817	O
,	O
in	O
transform	B-API

I	O
pasted	O
your	O
stack	B-API
trace	O
into	O
your	O
original	O
question	O
.	O

I	O
am	O
getting	O
a	O
TypeError	O
:	O
Transform	B-API
function	O
invalid	O
for	O
data	O
types	O
.	O

Also	O
,	O
you	O
shouldn't	O
have	O
to	O
drop	B-API
the	O
NaNs	O
.	O

How	O
do	O
I	O
join	B-API
two	O
dataframes	O
(	O
pandas	O
)	O
with	O
different	O
indices	O
?	O

I'm	O
working	O
on	O
a	O
way	O
to	O
transform	B-API
sequence	O
/	O
genotype	O
data	O
from	O
a	O
csv	O
format	O
to	O
a	O
genepop	O
format	O
.	O

I	O
want	O
to	O
insert	B-API
the	O
values	O
from	O
`	O
df2	O
`	O
into	O
`	O
df1	O
`	O
,	O
keeping	O
empty	O
rows	O
where	O
`	O
df1.index	O
=	O
'	O
POP	O
'`	O
.	O

I	O
tried	O
`	O
join	B-API
`	O
,	O
`	O
combine	B-API
`	O
,	O
`	O
combine_first	B-API
`	O
and	O
`	O
concat	B-API
`	O
,	O
but	O
they	O
all	O
seem	O
to	O
take	O
the	O
rows	O
that	O
exist	O
in	O
both	O
df's	O
.	O

`	O
df1.join	O
(	O
df2	O
)`	O
should	O
default	O
to	O
a	O
`	O
left	O
`	O
join	B-API
which	O
only	O
preserves	O
the	O
columns	O
from	O
df1	O
.	O

It	O
sounds	O
like	O
you	O
want	O
an	O
'	O
outer	O
'	O
`	O
join	B-API
`	O
:	O
#CODE	O

My	O
current	O
solution	O
is	O
to	O
define	O
a	O
temporary	O
dataframe	B-API
w	O
,	O
based	O
on	O
the	O
fancy	O
boolean	O
indexing	O
,	O
set	O
the	O
corresponding	O
values	O
in	O
'	O
y	O
'	O
to	O
0	O
in	O
w	O
,	O
and	O
then	O
merge	B-API
w	O
back	O
to	O
d	O
using	O
the	O
index	O
.	O

And	O
I'm	O
trying	O
to	O
efficiently	O
join	B-API
where	O
the	O
keys	O
match	O
and	O
the	O
date	O
is	O
between	O
the	O
valid_from	O
and	O
valid_to	O
.	O

I	O
was	O
wondering	O
if	O
anybody	O
had	O
a	O
better	O
idea	O
for	O
a	O
join	B-API
such	O
as	O
this	O
.	O

(	O
Note	O
:	O
the	O
`	O
value	O
`	O
column	O
of	O
`	O
df2	O
`	O
is	O
accessed	O
as	O
`	O
value_y	O
`	O
after	O
the	O
merge	B-API
because	O
it	O
conflicts	O
with	O
a	O
column	O
of	O
the	O
same	O
name	O
in	O
`	O
df	O
`	O
and	O
the	O
default	O
merge-conflict	O
suffixes	O
are	O
`	O
_x	O
,	O
_y	O
`	O
for	O
the	O
left	O
and	O
right	O
frames	O
,	O
respectively	O
.	O
)	O

Thanks	O
@USER	O
,	O
I	O
didn't	O
know	O
that	O
qcut	B-API
/	O
cut	B-API
had	O
a	O
labels-attribute	O
(	O
isn't	O
showing	O
in	O
IPython	O
autocompletion	O
unfortunately	O
)	O
.	O

2	O
,	O
Use	O
date	O
as	O
the	O
primary	O
index	O
and	O
time	O
as	O
the	O
secondary	O
index	O
in	O
a	O
multiindex	B-API
dataframe	B-API

multiindex	B-API
dataframe	B-API
#CODE	O

My	O
naive	O
inclination	O
would	O
be	O
to	O
prefer	O
a	O
single	O
index	O
over	O
the	O
multiindex	B-API
.	O

However	O
,	O
I	O
am	O
not	O
very	O
experienced	O
with	O
Pandas	O
,	O
and	O
there	O
could	O
be	O
some	O
advantage	O
to	O
having	O
the	O
multiindex	B-API
when	O
doing	O
time-of-day	O
analysis	O
.	O

How	O
can	O
you	O
elegantly	O
apply	B-API
condition	O
a	O
,	O
b	O
,	O
c	O
,	O
etc	O
.	O
and	O
make	O
sure	O
you	O
then	O
plot	O
"	O
the	O
rest	O
"	O
(	O
things	O
not	O
in	O
any	O
of	O
these	O
conditions	O
)	O
as	O
the	O
last	O
step	O
?	O

To	O
find	O
points	O
skipped	O
due	O
to	O
NA	O
,	O
try	O
the	O
`	O
isnull	B-API
`	O
method	O
:	O
`	O
df	O
[	O
df.col3.isnull()	O
]`	O

pandas	O
rolling	B-API
computation	O
with	O
window	O
based	O
on	O
values	O
instead	O
of	O
counts	O

I'm	O
looking	O
for	O
a	O
way	O
to	O
do	O
something	O
like	O
the	O
various	O
`	O
rolling_*	O
`	O
functions	O
of	O
`	O
pandas	O
`	O
,	O
but	O
I	O
want	O
the	O
window	O
of	O
the	O
rolling	B-API
computation	O
to	O
be	O
defined	O
by	O
a	O
range	O
of	O
values	O
(	O
say	O
,	O
a	O
range	O
of	O
values	O
of	O
a	O
column	O
of	O
the	O
DataFrame	B-API
)	O
,	O
not	O
by	O
the	O
number	O
of	O
rows	O
in	O
the	O
window	O
.	O

If	O
I	O
do	O
something	O
like	O
`	O
rolling_sum	B-API
(	O
d	O
,	O
5	O
)`	O
,	O
I	O
get	O
a	O
rolling	B-API
sum	O
in	O
which	O
each	O
window	O
contains	O
5	O
rows	O
.	O

But	O
what	O
I	O
want	O
is	O
a	O
rolling	B-API
sum	O
in	O
which	O
each	O
window	O
contains	O
a	O
certain	O
range	O
of	O
values	O
of	O
`	O
RollBasis	O
`	O
.	O

I	O
can't	O
do	O
it	O
with	O
the	O
rolling	B-API
functions	O
,	O
because	O
their	O
windows	O
always	O
roll	O
by	O
number	O
of	O
rows	O
,	O
not	O
by	O
values	O
.	O

For	O
this	O
to	O
work	O
correctly	O
(	O
at	O
least	O
in	O
pandas	O
0.14	O
)	O
,	O
I	O
think	O
you	O
need	O
to	O
replace	B-API
chunk	O
=	O
indexed_what	O
[	O
indexer	O
]	O
by	O
chunk	O
=	O
indexed_what.iloc	O
[	O
indexer	O
]	O
.	O

"	O
AssertionError	O
when	O
using	O
apply	B-API
after	O
GroupBy	B-API
"	O
.	O

In	O
some	O
cases	O
I	O
can	O
get	O
`	O
apply	B-API
`	O
working	O
after	O
`	O
groupby	B-API
`	O
and	O
in	O
other	O
cases	O
not	O
.	O

I	O
am	O
having	O
difficulties	O
understanding	O
how	O
to	O
work	O
with	O
DataFrame	B-API
with	O
MultiIndex	B-API
.	O

Pandas	O
Merge	B-API
(	O
pd.merge	B-API
)	O
How	O
to	O
set	O
the	O
index	O
and	O
join	B-API

I	O
tried	O
the	O
following	O
merge	B-API
:	O
#CODE	O

I	O
want	O
it	O
to	O
merge	B-API
based	O
on	O
both	O
date	O
and	O
cusip	O
/	O
idc_id	O
.	O

Reset	O
the	O
indices	O
and	O
then	O
merge	B-API
on	O
multiple	O
(	O
column-	O
)	O
keys	O
:	O
#CODE	O

You	O
could	O
append	B-API
`'	O
cuspin	O
'`	O
and	O
`'	O
idc_id	O
'`	O
as	O
a	O
indices	O
to	O
your	O
DataFrames	O
before	O
you	O
`	O
join	B-API
`	O
(	O
here's	O
how	O
it	O
would	O
work	O
on	O
the	O
first	O
couple	O
of	O
rows	O
):	O
#CODE	O

`	O
strip	B-API
`	O
only	O
removes	O
the	O
specified	O
characters	O
at	O
the	O
beginning	O
and	O
end	O
of	O
the	O
string	O
.	O

If	O
you	O
want	O
to	O
remove	O
all	O
`	O
\n	O
`	O
,	O
you	O
need	O
to	O
use	O
`	O
replace	B-API
`	O
.	O

You	O
could	O
use	O
`	O
regex	O
`	O
parameter	O
of	O
`	O
replace	B-API
`	O
method	O
to	O
achieve	O
that	O
:	O
#CODE	O

Maybe	O
a	O
nice	O
trick	O
/	O
slightly	O
dirty	O
way	O
to	O
get	O
around	O
the	O
unicode	O
issues	O
is	O
to	O
convert	O
unicode	O
columns	O
into	O
string	O
columns	O
with	O
the	O
"	O
xmlcharrefreplace	O
"	O
option	O
;	O
later	O
on	O
you	O
can	O
translate	B-API
this	O
back	O
into	O
unicode	O
if	O
you	O
want	O
to	O
.	O

Now	O
groupby	B-API
both	O
columns	O
and	O
apply	B-API
the	O
lambda	O
function	O
:	O
#CODE	O

I	O
tried	O
looking	O
at	O
various	O
join	B-API
,	O
merge	B-API
etc	O
.	O
operators	O
in	O
the	O
docs	O
,	O
but	O
couldn't	O
find	O
anything	O
offering	O
similar	O
logic	O
.	O

`	O
alternating	O
=	O
big	O
[(	O
big.index.to_pydatetime()	O
-	O
start	O
)	O
.total_seconds()	B-API
/	O
17	O
%	O
2	O
==	O
0	O
]`	O
,	O
but	O
I	O
can't	O
seem	O
to	O
find	O
a	O
way	O
to	O
map	B-API
the	O
total_seconds()	B-API
call	O
to	O
all	O
elements	O
.	O

Renaming	O
a	O
pandas	O
pivot	B-API
table	O
without	O
losing	O
axis	O
labels	O

When	O
I	O
invoke	O
rename	O
on	O
a	O
pivot	B-API
table	O
,	O
I	O
lose	O
the	O
axis	O
labels	O
:	O
#CODE	O

When	O
you	O
pivot	B-API
,	O
the	O
values	O
of	O
x	O
and	O
y	O
are	O
the	O
labels	O
,	O
and	O
that	O
is	O
expected	O
behaviour	O
.	O

You	O
can	O
use	O
the	O
`	O
DataFrame	B-API
`	O
`	O
drop	B-API
`	O
function	O
to	O
remove	O
columns	O
.	O

This	O
does	O
indeed	O
work	O
well	O
,	O
but	O
in	O
this	O
instance	O
I	O
only	O
need	O
to	O
keep	O
about	O
5-6	O
out	O
of	O
40-50	O
series	O
of	O
data	O
,	O
and	O
the	O
series	O
I	O
want	O
to	O
drop	B-API
may	O
fluctuate	O
based	O
on	O
changes	O
in	O
the	O
input	O
data	O
file	O
.	O

I	O
just	O
had	O
to	O
do	O
something	O
similar	O
to	O
what	O
you've	O
done	O
,	O
and	O
in	O
my	O
case	O
,	O
I've	O
pre-computed	O
the	O
list	O
of	O
things	O
I	O
need	O
to	O
drop	B-API
,	O
and	O
then	O
passed	O
in	O
the	O
list	O
to	O
the	O
drop()	B-API
function	O
.	O

@USER	O
Zelleke	O
,	O
what	O
if	O
i	O
had	O
about	O
50	O
columns	O
i	O
want	O
to	O
drop	B-API
and	O
50	O
columns	O
i	O
want	O
to	O
keep	O
.	O
and	O
the	O
number	O
of	O
columns	O
can	O
change	O
each	O
instance	O
i	O
run	O
it	O
.	O

maybe	O
replace	B-API
the	O
num	O
with	O
enumerate	O
in	O
the	O
for	O
loop	O
?	O

Pandas	O
:	O
Read	O
Timestamp	O
from	O
CSV	O
in	O
GMT	O
then	O
resample	B-API

Then	O
I	O
would	O
like	O
the	O
resample	B-API
to	O
one	O
minute	O
intervals	O
,	O
HOWEVER	O
,	O
I	O
would	O
like	O
to	O
be	O
able	O
to	O
have	O
it	O
skip	O
gaps	O
which	O
are	O
larger	O
than	O
a	O
user	O
specified	O
value	O
.	O

If	O
this	O
is	O
not	O
possible	O
,	O
is	O
there	O
way	O
to	O
resample	B-API
to	O
to	O
one	O
minute	O
,	O
but	O
in	O
the	O
gaps	O
,	O
put	O
in	O
an	O
arbitrary	O
value	O
like	O
0.0	O
?	O

The	O
only	O
thing	O
I	O
could	O
figure	O
out	O
that	O
might	O
be	O
the	O
issue	O
is	O
in	O
the	O
dataframe	B-API
dtypes	B-API
were	O
all	O
object	O
(	O
vs	O
int64	O
)	O
but	O
once	O
I	O
drop	B-API
to	O
the	O
series	O
,	O
it	O
went	O
to	O
longs	O
.	O

I	O
actually	O
think	O
it	O
won't	O
always	O
make	O
sense	O
to	O
apply	B-API
`	O
reshape	B-API
`	O
to	O
a	O
Series	O
(	O
do	O
you	O
ignore	O
the	O
index	O
?	O
)	O
,	O
and	O
that	O
you're	O
correct	O
in	O
thinking	O
it's	O
just	O
numpy's	O
reshape	O
:	O

@USER	O
the	O
fact	O
that	O
it	O
causes	O
an	O
exception	O
when	O
you	O
try	O
to	O
do	O
it	O
is	O
surely	O
a	O
bug	O
,	O
either	O
it	O
should	O
let	O
you	O
do	O
it	O
to	O
a	O
DataFrame	B-API
(	O
and	O
reindex	B-API
)	O
or	O
the	O
method	O
shouldn't	O
be	O
available	O
?	O

How	O
to	O
drop	B-API
extra	O
copy	O
of	O
duplicate	O
index	O
of	O
Pandas	O
Series	O
?	O

So	O
how	O
to	O
drop	B-API
extra	O
duplicate	O
rows	O
of	O
series	O
,	O
keep	O
the	O
unique	O
rows	O
and	O
only	O
one	O
copy	O
of	O
the	O
duplicate	O
rows	O
in	O
an	O
efficient	O
way	O
?	O

One	O
way	O
would	O
be	O
using	O
`	O
drop	B-API
`	O
and	O
`	O
index.get_duplicates	O
`	O
:	O
#CODE	O

Not	O
totally	O
drop	B-API
the	O
duplicated	O
ones	O
.	O

You	O
can	O
groupby	B-API
the	O
index	O
and	O
apply	B-API
a	O
function	O
that	O
returns	O
one	O
value	O
per	O
index	O
group	O
.	O

@USER	O
sorry	O
,	O
"	O
arbitrary	O
"	O
of	O
length	O
len	B-API
(	O
s	O
)	O
:)	O
.	O

Below	O
is	O
my	O
snippet	O
:	O
import	O
pandas	O
as	O
pd	O
;	O
idx_tp	O
=	O
[(	O
'	O
600809	O
'	O
,	O
'	O
20061231	O
')	O
,	O
(	O
'	O
600809	O
'	O
,	O
'	O
20070331	O
')	O
,	O
(	O
'	O
600809	O
'	O
,	O
'	O
20070630	O
')	O
,	O
(	O
'	O
600809	O
'	O
,	O
'	O
20070331	O
')]	O
;	O
dt	B-API
=	O
[	O
'	O
demo	O
'	O
,	O
'	O
demo	O
'	O
,	O
'	O
demo	O
'	O
,	O
'	O
demo	O
']	O
;	O
idx	O
=	O
pd.MultiIndex.from_tuples	B-API
(	O
idx_tp	O
,	O
names	O
=	O
[	O
'	O
STK_ID	O
'	O
,	O
'	O
RPT_Date	O
'])	O
;	O
s	O
=	O
pd.Series	B-API
(	O
dt	B-API
,	O
index=idx	O
);	O
#	O
s.groupby	O
(	O
s.index	O
)	O
.first()	B-API
will	O
crash	O
on	O
my	O
machine	O

@USER	O
passing	O
a	O
MultiIndex	B-API
to	O
series.groupby	B-API
and	O
then	O
applying	O
a	O
function	O
also	O
crashed	O
for	O
me	O
.	O

How	O
do	O
I	O
elegantly	O
apply	B-API
this	O
in	O
Pandas	O
?	O

Pandas	O
has	O
set	O
logic	O
for	O
intersection	B-API
and	O
union	O
,	O
but	O
nothing	O
for	O
disjoint	O
.	O

The	O
`	O
Target	O
`	O
is	O
just	O
a	O
constant	O
,	O
so	O
instead	O
of	O
trying	O
to	O
find	O
the	O
root	O
for	O
`	O
f	O
(	O
x	O
)	O
=	O
0	O
`	O
,	O
you'd	O
define	O
`	O
g	O
(	O
x	O
)	O
=	O
f	O
(	O
x	O
)	O
-	O
Target	O
`	O
and	O
apply	B-API
`	O
newton	O
`	O
to	O
`	O
g	O
`	O
.	O

I'm	O
trying	O
to	O
identify	O
the	O
rows	O
with	O
unicode	O
and	O
strip	B-API
the	O
$	O
sign	O
and	O
comma	O
,	O
converting	O
to	O
float	O
.	O

However	O
when	O
I	O
use	O
the	O
apply	B-API
function	O
to	O
my	O
case	O
I	O
get	O
an	O
'	O
unhashable	O
type	O
'	O
error	O
.	O

You	O
are	O
just	O
printing	O
these	O
and	O
not	O
`	O
apply	B-API
`	O
-ing	O
them	O
to	O
the	O
DataFrame	B-API
,	O
here's	O
one	O
way	O
to	O
do	O
it	O
:	O

If	O
I	O
understand	O
you	O
right	O
,	O
you're	O
looking	O
for	O
the	O
`	O
apply	B-API
`	O
method	O
:	O
#CODE	O

Update	O
:	O
I	O
now	O
recommend	O
installing	O
the	O
scientific	O
python	O
stack	B-API
using	O
Anaconda	O
.	O

@USER	O
it	O
may	O
be	O
preferable	O
to	O
install	O
pandas	O
via	O
the	O
fedora	O
package	O
#URL	O
I	O
now	O
recommend	O
using	O
conda	O
(	O
much	O
easier	O
for	O
the	O
python	O
data	O
stack	B-API
)	O
.	O

apply	B-API
a	O
function	O
to	O
a	O
pandas	O
Dataframe	B-API
whose	O
retuned	O
value	O
is	O
based	O
on	O
other	O
rows	O

I	O
want	O
to	O
apply	B-API
the	O
same	O
process	O
to	O
the	O
whole	O
quantity	O
column	O
.	O

Here	O
,	O
we	O
groupby	B-API
`	O
[	O
'	O
item	O
'	O
,	O
'	O
price	O
']`	O
and	O
apply	B-API
the	O
function	O
above	O
.	O

After	O
building	O
basic	O
class	O
with	O
`	O
__str__	O
`	O
and	O
plotData()	O
methods	O
I	O
would	O
like	O
to	O
apply	B-API
some	O
filters	O
and	O
build	O
a	O
new	O
class	O
where	O
additional	O
column	O
is	O
the	O
filter	O
.	O

To	O
convert	O
back	O
to	O
what	O
we	O
started	O
with	O
we	O
could	O
`	O
apply	B-API
`	O
`	O
Timestamp	O
`	O
to	O
the	O
column	O
and	O
`	O
set_index	B-API
`	O
:	O
#CODE	O

I'm	O
currently	O
trying	O
to	O
build	O
a	O
fairly	O
simple	O
script	O
that	O
will	O
compare	O
two	O
DataFrames	O
from	O
a	O
CSV	O
and	O
perform	O
an	O
inner	O
merge	B-API
to	O
remove	O
duplicates	O
.	O

rank	O
data	O
over	O
a	O
rolling	B-API
window	O
in	O
pandas	O
DataFrame	B-API

I	O
am	O
trying	O
to	O
rank	O
a	O
Timeseries	O
over	O
a	O
rolling	B-API
window	O
of	O
N	O
days	O
.	O

I	O
don't	O
seem	O
to	O
be	O
able	O
to	O
find	O
a	O
rolling	B-API
rank	O
function	O
.	O

If	O
I	O
wanted	O
to	O
rank	O
the	O
data	O
over	O
a	O
rolling	B-API
window	O
of	O
3	O
days	O
,	O
the	O
answer	O
should	O
be	O
:	O
#CODE	O

To	O
limit	O
memory	O
usage	O
,	O
simply	O
replace	B-API
the	O
dict	O
cache	O
with	O
something	O
like	O
a	O
LRU	O
.	O

I	O
try	O
to	O
apply	B-API
exactly	O
the	O
same	O
logic	O
to	O
my	O
original	O
problem	O
with	O
large	O
dataframe	B-API
inside	O
a	O
class	O
.	O

I	O
found	O
in	O
here	O
that	O
there	O
could	O
be	O
a	O
problem	O
with	O
type	O
of	O
the	O
columns	O
but	O
Depth	O
is	O
type	O
`	O
numpy.float64	O
`	O
Hper	O
is	O
type	O
`	O
float	O
`	O
Vper	O
is	O
type	O
`	O
float	O
`	O
so	O
I	O
understand	O
how	O
it	O
can	O
apply	B-API
to	O
my	O
problem	O
.	O

No	O
,	O
`	O
reindex	B-API
`	O
doesn't	O
do	O
any	O
sorting	O
.	O

You	O
can	O
use	O
`	O
iget	B-API
`	O
to	O
retrieve	O
by	O
position	O
:	O

I	O
have	O
a	O
Panda	O
Series	O
and	O
based	O
on	O
a	O
random	O
number	O
I	O
want	O
to	O
pick	O
a	O
row	O
(	O
5	O
in	O
the	O
code	O
example	O
below	O
)	O
and	O
drop	B-API
that	O
row	O
.	O

I	O
want	O
to	O
drop	B-API
row	O
"	O
5	O
NaN	O
"	O
and	O
keep	O
-	O
0.000052	O
with	O
an	O
index	O
0	O
to	O
8	O
.	O

Somewhat	O
confusingly	O
,	O
`	O
reindex	B-API
`	O
does	O
not	O
mean	O
"	O
create	O
a	O
new	O
index	O
"	O
.	O

So	O
at	O
your	O
last	O
step	O
just	O
do	O
`	O
sample_mean_series.index	O
=	O
range	O
(	O
len	B-API
(	O
sample_mean_series	O
))`	O
.	O

Using	O
`	O
reindex	B-API
[	O
blah	O
]`	O
just	O
selects	O
rows	O
,	O
basically	O
like	O
doing	O
`	O
df.ix	B-API
[	O
blah	O
]`	O
,	O
and	O
like	O
that	O
it	O
gives	O
you	O
NaN	O
if	O
the	O
ones	O
you	O
ask	O
for	O
don't	O
exist	O
.	O

It	O
does	O
have	O
some	O
options	O
for	O
filling	O
in	O
the	O
NaNs	O
,	O
but	O
I've	O
never	O
really	O
understood	O
the	O
point	O
of	O
reindex	B-API
,	O
let	O
alone	O
its	O
name	O
.	O

Not	O
sure	O
where	O
to	O
drop	B-API
sample	O
data	O
.	O

In	O
some	O
circles	O
this	O
operation	O
is	O
known	O
as	O
the	O
"	O
asof	B-API
"	O
join	B-API
.	O

What	O
about	O
using	O
`	O
Series.searchsorted()	B-API
`	O
to	O
return	O
the	O
index	O
of	O
`	O
y	O
`	O
where	O
you	O
would	O
insert	B-API
`	O
x	O
`	O
.	O

If	O
you	O
want	O
to	O
combine	O
`	O
join	B-API
`	O
your	O
MultiIndex	B-API
into	O
one	O
Index	O
(	O
assuming	O
you	O
have	O
just	O
string	O
entries	O
in	O
your	O
columns	O
)	O
you	O
could	O
:	O
#CODE	O

Note	O
:	O
we	O
must	O
`	O
strip	B-API
`	O
the	O
whitespace	O
for	O
when	O
there	O
is	O
no	O
second	O
index	O
.	O

And	O
if	O
you	O
want	O
to	O
retain	O
any	O
of	O
the	O
aggregation	O
info	O
from	O
the	O
second	O
level	O
of	O
the	O
multiindex	B-API
you	O
can	O
try	O
this	O
:	O
#CODE	O

pandas	O
:	O
merge	B-API
rows	O
on	O
timestamp	O

I'd	O
like	O
to	O
merge	B-API
the	O
rows	O
based	O
on	O
the	O
first	O
column	O
and	O
have	O
the	O
output	O
look	O
like	O
this	O
:	O
#CODE	O

I	O
am	O
still	O
struggling	O
to	O
get	O
a	O
combination	O
of	O
groupby	B-API
and	O
stack	B-API
to	O
recast	O
the	O
dataframe	B-API
.	O

Construct	O
the	O
index	O
as	O
desired	O
and	O
apply	B-API
it	O
to	O
the	O
dataframe	B-API

Now	O
create	O
the	O
desired	O
index	O
and	O
apply	B-API
it	O
.	O

I'm	O
trying	O
to	O
transform	B-API
monthly	O
returns	O
data	O
I	O
have	O
for	O
thousands	O
of	O
stocks	O
in	O
postgres	O
from	O
the	O
form	O
:	O
#CODE	O

My	O
suggestion	O
would	O
be	O
to	O
first	O
`	O
set_index	B-API
`	O
as	O
date	O
and	O
company	O
name	O
,	O
then	O
you	O
can	O
`	O
unstack	B-API
`	O
the	O
company	O
name	O
and	O
`	O
resample	B-API
`	O
.	O

@USER	O
the	O
column	O
is	O
a	O
MultiIndex	B-API
(	O
which	O
is	O
like	O
a	O
double	O
header	O
,	O
and	O
useful	O
if	O
there	O
were	O
more	O
columns	O
in	O
the	O
`	O
df2	O
`	O
,	O
but	O
not	O
so	O
useful	O
here	O
)	O
,	O
you	O
can	O
"	O
correct	O
"	O
this	O
via	O
`	O
df2.columns	O
=	O
df2.columns.get_level_values	O
(	O
1	O
)`	O
.	O

For	O
posterity	O
:	O
in	O
my	O
actual	O
,	O
messier	O
dataset	O
,	O
I	O
needed	O
to	O
also	O
use	O
`	O
groupby	B-API
(	O
levels	O
=[	O
0	O
,	O
1	O
])	O
.last()	B-API
`	O
to	O
remove	O
duplicate	O
indices	O
so	O
I	O
could	O
`	O
unstack	B-API
(	O
level=1	O
)`	O
the	O
dataframe	B-API
,	O
and	O
then	O
,	O
to	O
get	O
the	O
final	O
result	O
,	O
I	O
had	O
to	O
call	O
[	O
'	O
return	O
']	O
on	O
the	O
dataframe	B-API
:	O
e.g.	O
with	O
Andy's	O
`	O
df4	O
`	O
,,	O
`	O
df4	O
[	O
'	O
return	O
']`	O
got	O
me	O
the	O
DataFrame	B-API
I	O
needed	O
.	O

The	O
first	O
resample	B-API
starts	O
at	O
2000-01-03	O
and	O
the	O
second	O
resample	B-API
starts	O
at	O
2000-01-04	O

The	O
docs	O
show	O
how	O
to	O
apply	B-API
multiple	O
functions	O
on	O
a	O
groupby	B-API
object	O
at	O
a	O
time	O
using	O
a	O
dict	O
with	O
the	O
output	O
column	O
names	O
as	O
the	O
keys	O
:	O
#CODE	O

What	O
I	O
want	O
to	O
do	O
is	O
apply	B-API
multiple	O
functions	O
to	O
several	O
columns	O
(	O
but	O
certain	O
columns	O
will	O
be	O
operated	O
on	O
multiple	O
times	O
)	O
.	O

but	O
as	O
expected	O
I	O
get	O
a	O
KeyError	O
(	O
since	O
the	O
keys	O
have	O
to	O
be	O
a	O
column	O
if	O
`	O
agg	B-API
`	O
is	O
called	O
from	O
a	O
DataFrame	B-API
)	O
.	O

Because	O
the	O
aggregate	B-API
function	O
works	O
on	O
Series	O
,	O
references	O
to	O
the	O
other	O
column	O
names	O
are	O
lost	O
.	O

This	O
is	O
starting	O
to	O
get	O
pretty	O
messy	O
,	O
though	O
--	O
I	O
think	O
for	O
readability	O
manual	O
looping	O
may	O
be	O
preferable	O
,	O
plus	O
I'm	O
not	O
sure	O
there's	O
a	O
way	O
to	O
give	O
it	O
my	O
preferred	O
name	O
in	O
the	O
`	O
agg	B-API
`	O
argument	O
(	O
instead	O
of	O
`	O
`)	O
.	O

How	O
do	O
I	O
resample	B-API
a	O
time	O
series	O
in	O
pandas	O
to	O
a	O
weekly	O
frequency	O
where	O
the	O
weeks	O
start	O
on	O
an	O
arbitrary	O
day	O
?	O

You	O
can	O
pass	O
anchored	O
offsets	O
to	O
`	O
resample	B-API
`	O
,	O
among	O
other	O
options	O
they	O
cover	O
this	O
case	O
.	O

Pandas	O
Drop	B-API
Rows	O
Outside	O
of	O
Time	O
Range	O

I	O
have	O
been	O
looking	O
for	O
solutions	O
but	O
none	O
of	O
them	O
separate	O
the	O
Date	O
from	O
the	O
Time	O
,	O
and	O
all	O
I	O
want	O
to	O
do	O
is	O
drop	B-API
the	O
rows	O
that	O
are	O
outside	O
of	O
a	O
Time	O
range	O
.	O

Note	O
:	O
the	O
same	O
syntax	O
(	O
using	O
`	O
ix	B-API
`	O
)	O
works	O
for	O
a	O
DataFrame	B-API
:	O
#CODE	O

@USER	O
--	O
My	O
first	O
thought	O
was	O
also	O
that	O
it	O
worked	O
the	O
same	O
,	O
but	O
I	O
think	O
DataFrame	B-API
tries	O
to	O
apply	B-API
it	O
to	O
the	O
columns	O
(	O
without	O
the	O
ix	B-API
)	O
.	O

@USER	O
I	O
think	O
it's	O
good	O
practice	O
to	O
use	O
ix	B-API
with	O
Series	O
as	O
well	O
,	O
and	O
that	O
way	O
the	O
syntax	O
is	O
identical	O
,	O
so	O
I	O
updated	O
the	O
first	O
part	O
.	O

@USER	O
thanks	O
for	O
mentioning	O
that	O
,	O
I	O
will	O
append	B-API
:)	O

I'm	O
trying	O
to	O
transform	B-API
a	O
(	O
well	O
,	O
many	O
)	O
column	O
of	O
return	O
data	O
to	O
a	O
column	O
of	O
closing	O
prices	O
.	O

If	O
abs	B-API
(	O
stuff	O
)	O
>	O
1	O
,	O
the	O
result	O
will	O
be	O
negative	O
.	O

If	O
you	O
can't	O
/	O
don't	O
want	O
to	O
replace	B-API
your	O
reading	O
with	O
`	O
pandas.read_csv	B-API
`	O
,	O
then	O
probably	O
my	O
`	O
numpy.delete	O
`	O
is	O
easiest	O
,	O
but	O
I	O
think	O
you're	O
better	O
off	O
with	O
his	O
answer	O
.	O

`	O
read_csv	B-API
`	O
is	O
much	O
simpler	O
,	O
harder	O
to	O
get	O
wrong	O
,	O
and	O
probably	O
faster	O
than	O
what	O
he	O
has	O
,	O
and	O
there's	O
no	O
good	O
reason	O
not	O
to	O
drop	B-API
the	O
column	O
in	O
`	O
pandas	O
`	O
instead	O
of	O
post-deleting	O
after	O
`	O
to_records	B-API
`	O
.	O

currently	O
to	O
create	O
my	O
time	O
axis	O
I'm	O
using	O
the	O
following	O
:	O
`	O
x	O
=	O
mdates.num2date	O
(	O
x	O
,	O
tz=None	O
)`	O
`	O
x	O
=	O
[	O
dt.replace	O
(	O
tzinfo=None	O
)	O
for	O
dt	B-API
in	O
x	O
]`	O

You	O
may	O
be	O
trying	O
to	O
force	O
the	O
use	O
of	O
`	O
hist	B-API
`	O
...	O
consider	O
taking	O
a	O
step	O
back	O
to	O
construct	O
a	O
bar	O
plot	O
.	O

Pandas	O
dataframe	B-API
resample	B-API
at	O
every	O
nth	O
row	O

I	O
am	O
planning	O
to	O
resample	B-API
the	O
dataframe	B-API
so	O
that	O
if	O
the	O
dataset	O
passes	O
certain	O
size	O
,	O
I	O
will	O
resample	B-API
it	O
so	O
there	O
are	O
ultimately	O
only	O
the	O
SIZE_LIMIT	O
number	O
of	O
rows	O
.	O

I	O
need	O
to	O
apply	B-API
some	O
function	O
for	O
every	O
columns	O
and	O
create	O
new	O
columns	O
in	O
this	O
DataFrame	B-API
with	O
special	O
name	O
.	O

You	O
can	O
use	O
`	O
join	B-API
`	O
to	O
do	O
the	O
combining	O
:	O
#CODE	O

where	O
you	O
could	O
replace	B-API
`	O
df*2	O
`	O
with	O
`	O
df.apply	B-API
(	O
your_function	O
)`	O
if	O
you	O
liked	O
.	O

I	O
would	O
skip	O
the	O
`	O
apply	B-API
`	O
method	O
and	O
just	O
define	O
the	O
columns	O
directly	O
.	O

But	O
for	O
whatever	O
reason	O
I	O
avoid	O
`	O
apply	B-API
`	O
unless	O
I	O
really	O
need	O
it	O
.	O

BY	O
avoiding	O
the	O
`	O
join	B-API
`	O
this	O
also	O
has	O
the	O
nice	O
benefit	O
of	O
not	O
having	O
to	O
reassign	O
the	O
dataframe	B-API
.	O

In	O
particular	O
I	O
want	O
the	O
inner	O
join	B-API
of	O
the	O
tables	O
.	O

I	O
could	O
not	O
load	O
the	O
table	O
B	O
on	O
memory	O
as	O
a	O
pandas	O
dataframe	B-API
to	O
use	O
the	O
normal	O
merge	B-API
function	O
on	O
pandas	O
.	O

straightfoward	O
disk	O
based	O
merge	B-API
,	O
with	O
all	O
tables	O
on	O
disk	O
.	O

See	O
this	O
answer	O
for	O
a	O
comment	O
on	O
how	O
doing	O
a	O
join	B-API
operation	O
will	O
actually	O
be	O
an	O
'	O
inner	O
'	O
join	B-API
.	O

For	O
your	O
merge_a_b	O
operation	O
I	O
think	O
you	O
can	O
use	O
a	O
standard	O
pandas	O
join	B-API

table	O
;	O
instead	O
of	O
storing	O
the	O
merge	B-API
results	O
per	O
se	O
,	O
store	O
the	O
row	O
index	O
;	O
later	O

I	O
am	O
avoiding	O
to	O
use	O
join	B-API
/	O
concat	B-API
/	O
merge	B-API
option	O
of	O
pandas	O
since	O
they	O
all	O
spit	O
out	O
a	O
"	O
segmentation	O
fault	O
:	O
11	O
"	O
every	O
now	O
and	O
then	O
.	O

Which	O
is	O
probably	O
like	O
a	O
inefficient	O
"	O
join	B-API
"	O
.	O

To	O
avoid	O
it	O
replace	B-API
last	O
line	O
with	O
:	O
#CODE	O

I	O
basically	O
replace	B-API
the	O
stars	O
in	O
my	O
example	O
code	O
above	O
with	O
`	O
`	O
.	O

Pandas	O
DatetimeIndex	B-API
truncate	B-API
error	O

`	O
df	O
`	O
was	O
created	O
by	O
concatenating	O
multiple	O
dataframes	O
together	O
using	O
the	O
`	O
concat	B-API
`	O
function	O
.	O

Let's	O
say	O
I	O
wanted	O
to	O
do	O
the	O
rolling	B-API
sum	O
over	O
a	O
1ms	O
window	O
to	O
get	O
this	O
:	O
#CODE	O

add	O
column	O
with	O
time	O
rounded	O
to	O
millisec	O
and	O
groupby	B-API
it	O
,	O
apply	B-API
cumsum	B-API
within	O
each	O
group	O

You	O
need	O
a	O
way	O
of	O
handling	O
NaNs	O
and	O
depending	O
on	O
your	O
application	O
,	O
you	O
may	O
need	O
the	O
prevailing	O
value	O
asof	B-API
the	O
lagged	O
time	O
or	O
not	O
(	O
ie	O
difference	O
between	O
using	O
kdb+	O
bin	O
vs	O
np.searchsorted	O
)	O
.	O

ugh	O
,	O
the	O
second	O
asof	B-API
(	O
s.asof	O
(	O
lag	O
))	O
is	O
wrong	O
.	O

What	O
you	O
really	O
need	O
are	O
the	O
indices	O
from	O
the	O
first	O
asof	B-API
.	O

I	O
have	O
tried	O
concat	B-API
:	O
#CODE	O

but	O
I	O
need	O
the	O
output	O
that	O
adds	O
values	O
of	O
existing	O
indices	O
and	O
keeps	O
new	O
indices	O
if	O
they	O
appear	O
,	O
so	O
a	O
mix	O
of	O
concat	B-API
and	O
'	O
+	O
'	O
.	O

Or	O
you	O
could	O
align	B-API
the	O
two	O
first	O
,	O
and	O
then	O
simply	O
add	O
them	O
with	O
`	O
+	O
`	O
:	O
#CODE	O

Why	O
not	O
just	O
take	O
the	O
[	O
transpose	B-API
]	O
(	O
#URL	O
)	O
??	O

You	O
could	O
replace	B-API
:	O
#CODE	O

Is	O
there	O
a	O
way	O
to	O
first	O
compute	O
the	O
cumsums	O
and	O
then	O
apply	B-API
'	O
ohcl	O
'	O
to	O
the	O
data	O
?	O

I	O
wasn't	O
able	O
to	O
get	O
your	O
resample	B-API
suggestion	O
to	O
work	O
.	O

Here's	O
a	O
way	O
to	O
aggregate	B-API
the	O
data	O
at	O
the	O
business	O
day	O
level	O
and	O
compute	O
the	O
OHLC	O
stats	O
in	O
one	O
pass	O
:	O
#CODE	O

The	O
outer	O
key	O
references	O
the	O
columns	O
you	O
want	O
to	O
apply	B-API
the	O
functions	O
to	O
.	O

The	O
inner	O
key	O
contains	O
the	O
names	O
of	O
your	O
aggregation	O
functions	O
and	O
the	O
inner	O
values	O
are	O
the	O
functions	O
you	O
want	O
to	O
apply	B-API
:	O
#CODE	O

boolean	O
mask	B-API
in	O
pandas	O
panel	O

1	O
)	O
I	O
create	O
a	O
mask	B-API
and	O
mask	B-API
the	O
data	O
as	O
follows	O
:	O
#CODE	O

What	O
I	O
cannot	O
figure	O
out	O
how	O
to	O
do	O
is	O
filter	O
all	O
of	O
my	O
data	O
based	O
on	O
a	O
mask	B-API
without	O
a	O
for	O
loop	O
.	O

Assuming	O
that	O
Date	O
is	O
the	O
index	O
rather	O
than	O
a	O
column	O
then	O
you	O
can	O
do	O
an	O
"	O
outer	O
"	O
`	O
join	B-API
`	O
:	O
#CODE	O

I	O
get	O
:	O
``	O
275	O
#	O
FIXME	O
:	O
This	O
doesn't	O
handle	O
MultiIndex	B-API

How	O
to	O
drop	B-API
a	O
list	O
of	O
rows	O
from	O
Pandas	O
dataframe	B-API
?	O

Then	O
I	O
want	O
to	O
drop	B-API
rows	O
with	O
certain	O
sequence	O
numbers	O
which	O
indicated	O
in	O
a	O
list	O
,	O
suppose	O
here	O
is	O
`	O
[	O
1	O
,	O
2	O
,	O
4	O
]	O
,	O
`	O
then	O
left	O
:	O
#CODE	O

This	O
is	O
because	O
of	O
using	O
integer	O
indices	O
(	O
`	O
ix	B-API
`	O
selects	O
those	O
by	O
label	O
over	O
-3	O
rather	O
than	O
position	O
,	O
and	O
this	O
is	O
by	O
design	O
:	O
see	O
integer	O
indexing	O
in	O
pandas	O
"	O
gotchas	O
"	O
*	O
)	O
.	O

*	O
In	O
newer	O
versions	O
of	O
pandas	O
prefer	O
loc	B-API
or	O
iloc	B-API
to	O
remove	O
the	O
ambiguity	O
of	O
ix	B-API
as	O
position	O
or	O
label	O
:	O
#CODE	O

Note	O
:	O
Series	O
has	O
a	O
similar	O
`	O
iget	B-API
`	O
method	O
.	O

Using	O
the	O
`	O
map	B-API
`	O
lets	O
you	O
put	O
in	O
any	O
condition	O
you	O
want	O
,	O
in	O
this	O
case	O
you	O
can	O
do	O
this	O
more	O
simply	O
(	O
as	O
pointed	O
out	O
in	O
the	O
comments	O
by	O
DSM	O
)	O
#CODE	O

Like	O
the	O
last	O
non	O
map	B-API
solution	O
from	O
DSM	O
,	O
worked	O
for	O
me	O

Python	O
pandas	O
,	O
how	O
to	O
truncate	B-API
DatetimeIndex	B-API
and	O
fill	O
missing	O
data	O
only	O
in	O
certain	O
interval	O

for	O
each	O
date	O
in	O
the	O
DataFrame	B-API
truncate	B-API
to	O
only	O
have	O
data	O
in	O
the	O

the	O
pandas	O
truncate	B-API
functions	O
only	O
allows	O
me	O
to	O
truncate	B-API
according	O
to	O
date	O
,	O
but	O
I	O
would	O
like	O
to	O
truncate	B-API
according	O
to	O
datetime.time	O
here	O
.	O

for	O
each	O
date	O
in	O
the	O
DataFrame	B-API
truncate	B-API
to	O
only	O
have	O
data	O
in	O
the	O
range	O
of	O
9:00	O
:	O
00AM	O
-	O
11:30	O
:	O
00AM	O
and	O
13:00	O
:	O
00	O
-	O
15:15	O
:	O
00	O

Merge	B-API
this	O
dataframe	B-API
with	O
the	O
original	O
one	O
using	O
outer	O
join	B-API
.	O

@USER	O
You	O
can	O
probably	O
create	O
a	O
two-level	O
index	O
`	O
[	O
'	O
date	O
'	O
,	O
'	O
time	O
']`	O
and	O
then	O
apply	B-API
time	O
filtering	O
for	O
the	O
second	O
level	O
,	O
but	O
that	O
is	O
beyond	O
my	O
current	O
level	O
of	O
pandas-fu	O
now	O
.	O

So	O
you	O
can	O
use	O
`	O
map	B-API
`	O
and	O
a	O
`	O
lambda	O
`	O
:	O
#CODE	O

Note	O
,	O
however	O
,	O
that	O
while	O
you	O
can	O
attach	O
attributes	O
to	O
a	O
DataFrame	B-API
,	O
operations	O
performed	O
on	O
the	O
DataFrame	B-API
(	O
such	O
as	O
`	O
groupby	B-API
`	O
,	O
`	O
pivot	B-API
`	O
,	O
`	O
join	B-API
`	O
or	O
`	O
loc	B-API
`	O
to	O
name	O
just	O
a	O
few	O
)	O
may	O
return	O
a	O
new	O
DataFrame	B-API
without	O
the	O
metadata	O
attached	O
.	O

When	O
I	O
do	O
df	O
[	O
'	O
tracking	O
']	O
=	O
pd.np.arange	O
(	O
len	B-API
(	O
df	O
))	O
I	O
get	O
'	O
tracking	O
not	O
in	O
this	O
series	O
!	O

To	O
pick	O
the	O
last	O
row	O
using	O
`	O
irow	B-API
`	O
:	O
#CODE	O

I've	O
delved	O
into	O
the	O
code	O
to	O
realize	O
that	O
the	O
repr	O
function	O
on	O
Series	O
eventually	O
calls	O
'	O
_format_datetime64	O
'	O
,	O
which	O
checks	O
'	O
isnull	B-API
'	O
and	O
will	O
print	O
out	O
'	O
NaT	O
'	O
That	O
explains	O
the	O
difference	O
between	O
these	O
two	O
.	O

I	O
suppose	O
there	O
may	O
be	O
other	O
pandas	O
functions	O
that	O
call	O
'	O
isnull	B-API
'	O
and	O
act	O
based	O
on	O
the	O
answer	O
,	O
which	O
might	O
seem	O
to	O
partially	O
work	O
for	O
NA	O
timestamps	O
in	O
this	O
case	O
.	O

Pandas	O
append	B-API
data	O
frames	O
,	O
add	O
a	O
field	O
,	O
and	O
then	O
flood	O
the	O
field	O
with	O
a	O
default	O
value	O
?	O

I	O
want	O
to	O
append	B-API
them	O
into	O
a	O
master	O
data	O
frame	O
.	O

I	O
think	O
that's	O
not	O
the	O
best	O
shape	O
for	O
your	O
DataFrame	B-API
--	O
I	O
think	O
columns	O
like	O
"	O
letter	O
"	O
,	O
"	O
number	O
"	O
,	O
"	O
acc	O
"	O
,	O
"	O
rt	O
"	O
or	O
something	O
(	O
giving	O
them	O
more	O
meaningful	O
names	O
)	O
would	O
be	O
easier	O
to	O
pivot	B-API
.	O

